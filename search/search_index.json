{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastCRUD","text":"<p> Powerful CRUD methods and automatic endpoint creation for FastAPI. </p> <p> </p> <p> FastCRUD is a Python package for FastAPI, offering robust async CRUD operations and flexible endpoint creation utilities, streamlined through advanced features like auto-detected join conditions, dynamic sorting, and offset and cursor pagination. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async: Leverages Python's async capabilities for non-blocking database operations.</li> <li>SQLAlchemy 2.0: Works with the latest SQLAlchemy version for robust database interactions.</li> <li>SQLModel Support: You can optionally use SQLModel 0.14 or newer instead of SQLAlchemy.</li> <li>Powerful CRUD Functionality: Full suite of efficient CRUD operations with support for joins.</li> <li>Dynamic Query Building: Supports building complex queries dynamically, including filtering, sorting, and pagination.</li> <li>Advanced Join Operations: Facilitates performing SQL joins with other models with automatic join condition detection.</li> <li>Built-in Offset Pagination: Comes with ready-to-use offset pagination.</li> <li>Cursor-based Pagination: Implements efficient pagination for large datasets, ideal for infinite scrolling interfaces.</li> <li>Modular and Extensible: Designed for easy extension and customization to fit your requirements.</li> <li>Auto-generated Endpoints: Streamlines the process of adding CRUD endpoints with custom dependencies and configurations.</li> </ul>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your model, schemas and database connection:</p> <pre><code># imports here\n\n# define your model\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n# your schemas\nclass ItemSchema(BaseModel):\n    name: str\n\n# database connection\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> <pre><code>from fastcrud import crud_router\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install fastcrud\n</code></pre> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>FastCRUD offers two primary ways to use its functionalities:</p> <ol> <li>By using <code>crud_router</code> for automatic endpoint creation.</li> <li>By integrating <code>FastCRUD</code> directly into your FastAPI endpoints for more control.</li> </ol> <p>Below are examples demonstrating both approaches:</p>"},{"location":"#using-crud_router-for-automatic-endpoint-creation","title":"Using crud_router for Automatic Endpoint Creation","text":"<p>Warning</p> <p>For now, your primary column must be named <code>id</code> or automatic endpoint creation will not work.</p> <p>Here's a quick example to get you started:</p>"},{"location":"#define-your-model-and-schema","title":"Define Your Model and Schema","text":"models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"#set-up-fastapi-and-fastcrud","title":"Set Up FastAPI and FastCRUD","text":"main.py<pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import crud_router\nfrom fastcrud import FastCRUD\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom item import Base, Item, ItemCreateSchema, ItemUpdateSchema\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n\n# CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemCreateSchema,\n    update_schema=ItemUpdateSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"#using-fastcrud-in-user-defined-fastapi-endpoints","title":"Using FastCRUD in User-Defined FastAPI Endpoints","text":"<p>For more control over your endpoints, you can use FastCRUD directly within your custom FastAPI route functions. Here's an example:</p> api/v1/item.py<pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastcrud import FastCRUD\nfrom yourapp.models import Item\nfrom yourapp.schemas import ItemCreateSchema, ItemUpdateSchema\n\n# Assume async_session is already set up as per the previous example\n\n# Instantiate FastCRUD with your model\nitem_crud = FastCRUD(Item)\n\n@app.post(\"/custom/items/\")\nasync def create_item(item_data: ItemCreateSchema, db: AsyncSession = Depends(get_session)):\n    return await item_crud.create(db, item_data)\n\n@app.get(\"/custom/items/{item_id}\")\nasync def read_item(item_id: int, db: AsyncSession = Depends(get_session)):\n    item = await item_crud.get(db, id=item_id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n\n# You can add more routes for update and delete operations in a similar fashion\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>"},{"location":"installing/","title":"Installing","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"installing/#installing","title":"Installing","text":"<p>To install, just run:  <pre><code>pip install fastcrud\n</code></pre></p> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"quick-start/","title":"Quick-Start","text":"<p>If you are using SQLModel, go to Using SQLModel instead.</p>"},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your SQLAlchemy model, Pydantic schemas and database connection, just skip to Using FastCRUD</p>"},{"location":"quick-start/#basic-setup","title":"Basic Setup","text":"<p>Define your SQLAlchemy model</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your Pydantic schemas</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre>"},{"location":"quick-start/#using-fastcrud","title":"Using FastCRUD","text":"<p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from fastcrud import crud_router\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"sqlmodel/","title":"Using FastCRUD with SQLModel","text":"<p>Since SQLModel is just a combination of SQLAlchemy and Pydantic, the process simplifies as SQLModel combines the model and schema definitions.</p> <p>Wherever in the docs you see a SQLAlchemy model or Pydantic schema being used, you may just replace it with SQLModel and it will work. For the quick start:</p> <p>Define your SQLModel model</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass Item(SQLModel):\n    __tablename__ = 'items'\n    id: int = Field(primary_key=True)\n    name: str\n\nclass ItemCreateSchema(SQLModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your schemas</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass Item(SQLModel):\n    __tablename__ = 'items'\n    id: int = Field(primary_key=True)\n    name: str\n\nclass ItemCreateSchema(SQLModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass Item(SQLModel):\n    __tablename__ = 'items'\n    id: int = Field(primary_key=True)\n    name: str\n\nclass ItemCreateSchema(SQLModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from fastcrud import crud_router\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>By following the above setup, FastCRUD auto-generates CRUD endpoints for your model, accessible through the <code>/docs</code> route of your FastAPI application.</p>"},{"location":"advanced/crud/","title":"Advanced Use of FastCRUD","text":"<p>FastCRUD offers a flexible and powerful approach to handling CRUD operations in FastAPI applications, leveraging the SQLAlchemy ORM. Beyond basic CRUD functionality, FastCRUD provides advanced features like <code>allow_multiple</code> for updates and deletes, and support for advanced filters (e.g., less than, greater than). These features enable more complex and fine-grained data manipulation and querying capabilities.</p>"},{"location":"advanced/crud/#allow-multiple-updates-and-deletes","title":"Allow Multiple Updates and Deletes","text":"<p>One of FastCRUD's advanced features is the ability to update or delete multiple records at once based on specified conditions. This is particularly useful for batch operations where you need to modify or remove several records that match certain criteria.</p>"},{"location":"advanced/crud/#updating-multiple-records","title":"Updating Multiple Records","text":"<p>To update multiple records, you can set the <code>allow_multiple=True</code> parameter in the <code>update</code> method. This allows FastCRUD to apply the update to all records matching the given filters.</p> <pre><code># Assuming setup for FastCRUD instance `item_crud` and SQLAlchemy async session `db`\n\n# Update all items priced below $10 to a new price\nawait item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    allow_multiple=True,\n    price__lt=10\n)\n</code></pre>"},{"location":"advanced/crud/#deleting-multiple-records","title":"Deleting Multiple Records","text":"<p>Similarly, you can delete multiple records by using the <code>allow_multiple=True</code> parameter in the <code>delete</code> or <code>db_delete</code> method, depending on whether you're performing a soft or hard delete.</p> <pre><code># Soft delete all items not sold in the last year\nawait item_crud.delete(\n    db=db,\n    allow_multiple=True,\n    last_sold__lt=datetime.datetime.now() - datetime.timedelta(days=365)\n)\n</code></pre>"},{"location":"advanced/crud/#advanced-filters","title":"Advanced Filters","text":"<p>FastCRUD supports advanced filtering options, allowing you to query records using operators such as greater than (<code>__gt</code>), less than (<code>__lt</code>), and their inclusive counterparts (<code>__gte</code>, <code>__lte</code>). These filters can be used in any method that retrieves or operates on records, including <code>get</code>, <code>get_multi</code>, <code>exists</code>, <code>count</code>, <code>update</code>, and <code>delete</code>.</p>"},{"location":"advanced/crud/#using-advanced-filters","title":"Using Advanced Filters","text":"<p>The following examples demonstrate how to use advanced filters for querying and manipulating data:</p>"},{"location":"advanced/crud/#fetching-records-with-advanced-filters","title":"Fetching Records with Advanced Filters","text":"<pre><code># Fetch items priced between $5 and $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__gte=5,\n    price__lte=20\n)\n</code></pre>"},{"location":"advanced/crud/#counting-records","title":"Counting Records","text":"<pre><code># Count items added in the last month\nitem_count = await item_crud.count(\n    db=db,\n    added_at__gte=datetime.datetime.now() - datetime.timedelta(days=30)\n)\n</code></pre>"},{"location":"advanced/crud/#conclusion","title":"Conclusion","text":"<p>The advanced features of FastCRUD, such as <code>allow_multiple</code> and support for advanced filters, empower developers to efficiently manage database records with complex conditions. By leveraging these capabilities, you can build more dynamic, robust, and scalable FastAPI applications that effectively interact with your data model.</p>"},{"location":"advanced/endpoint/","title":"Advanced Use of EndpointCreator","text":""},{"location":"advanced/endpoint/#available-automatic-endpoints","title":"Available Automatic Endpoints","text":"<p>FastCRUD automates the creation of CRUD (Create, Read, Update, Delete) endpoints for your FastAPI application. Here's an overview of the available automatic endpoints and how they work:</p>"},{"location":"advanced/endpoint/#create","title":"Create","text":"<ul> <li>Endpoint: <code>/create</code></li> <li>Method: <code>POST</code></li> <li>Description: Creates a new item in the database.</li> <li>Request Body: JSON object based on the <code>create_schema</code>.</li> <li>Example Request: <code>POST /yourmodel/create</code> with JSON body.</li> </ul>"},{"location":"advanced/endpoint/#read","title":"Read","text":"<ul> <li>Endpoint: <code>/get/{id}</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves a single item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to retrieve.</li> <li>Example Request: <code>GET /yourmodel/get/1</code>.</li> <li>Example Return: <pre><code>{\n    \"id\": 1,\n    \"name\": \"Item 1\",\n    \"description\": \"Description of item 1\"\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#read-multiple","title":"Read Multiple","text":"<ul> <li>Endpoint: <code>/get_multi</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves multiple items with optional pagination.</li> <li>Query Parameters:</li> <li><code>offset</code> (optional): The offset from where to start fetching items.</li> <li><code>limit</code> (optional): The maximum number of items to return.</li> <li>Example Request: <code>GET /yourmodel/get_multi?offset=3&amp;limit=4</code>.</li> <li>Example Return: <pre><code>{\n  \"data\": [\n    {\"id\": 4, \"name\": \"Item 4\", \"description\": \"Description of item 4\"},\n    {\"id\": 5, \"name\": \"Item 5\", \"description\": \"Description of item 5\"},\n    {\"id\": 6, \"name\": \"Item 6\", \"description\": \"Description of item 6\"},\n    {\"id\": 7, \"name\": \"Item 7\", \"description\": \"Description of item 7\"}\n  ],\n  \"total_count\": 50\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#read-paginated","title":"Read Paginated","text":"<ul> <li>Endpoint: <code>/get_paginated</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves multiple items with pagination.</li> <li>Query Parameters:</li> <li><code>page</code>: The page number, starting from 1.</li> <li><code>itemsPerPage</code>: The number of items per page.</li> <li>Example Request: <code>GET /yourmodel/get_paginated?page=1&amp;itemsPerPage=3</code>.</li> <li>Example Return: <pre><code>{\n  \"data\": [\n    {\"id\": 1, \"name\": \"Item 1\", \"description\": \"Description of item 1\"},\n    {\"id\": 2, \"name\": \"Item 2\", \"description\": \"Description of item 2\"},\n    {\"id\": 3, \"name\": \"Item 3\", \"description\": \"Description of item 3\"}\n  ],\n  \"total_count\": 50,\n  \"has_more\": true,\n  \"page\": 1,\n  \"items_per_page\": 3\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#update","title":"Update","text":"<ul> <li>Endpoint: <code>/update/{id}</code></li> <li>Method: <code>PATCH</code></li> <li>Description: Updates an existing item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to update.</li> <li>Request Body: JSON object based on the <code>update_schema</code>.</li> <li>Example Request: <code>PATCH /yourmodel/update/1</code> with JSON body.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#delete","title":"Delete","text":"<ul> <li>Endpoint: <code>/delete/{id}</code></li> <li>Method: <code>DELETE</code></li> <li>Description: Deletes (soft delete if configured) an item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to delete.</li> <li>Example Request: <code>DELETE /yourmodel/delete/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#db-delete-hard-delete","title":"DB Delete (Hard Delete)","text":"<ul> <li>Endpoint: <code>/db_delete/{id}</code> (Available if a <code>delete_schema</code> is provided)</li> <li>Method: <code>DELETE</code></li> <li>Description: Permanently deletes an item by its ID, bypassing the soft delete mechanism.</li> <li>Path Parameters: <code>id</code> - The ID of the item to hard delete.</li> <li>Example Request: <code>DELETE /yourmodel/db_delete/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>You can control which CRUD operations are exposed by using <code>included_methods</code> and <code>deleted_methods</code>. These parameters allow you to specify exactly which CRUD methods should be included or excluded when setting up the router. By default, all CRUD endpoints are included.</p>"},{"location":"advanced/endpoint/#using-included_methods","title":"Using <code>included_methods</code>","text":"<p>Using <code>included_methods</code> you may define exactly the methods you want to be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"]  # Only these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#using-deleted_methods","title":"Using <code>deleted_methods</code>","text":"<p>Using <code>deleted_methods</code> you define the methods that will not be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    deleted_methods=[\"update\", \"delete\"]  # All but these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre> <p>Warning</p> <pre><code>If `included_methods` and `deleted_methods` are both provided, a ValueError will be raised.\n</code></pre>"},{"location":"advanced/endpoint/#customizing-endpoint-names","title":"Customizing Endpoint Names","text":"<p>You can customize the names of the auto generated endpoints by passing an <code>endpoint_names</code> dictionary when initializing the <code>EndpointCreator</code> or calling the <code>crud_router</code> function. This dictionary should map the CRUD operation names (<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>db_delete</code>, <code>read_multi</code>, <code>read_paginated</code>) to your desired endpoint names.</p>"},{"location":"advanced/endpoint/#example-using-crud_router","title":"Example: Using <code>crud_router</code>","text":"<p>Here's how you can customize endpoint names using the <code>crud_router</code> function:</p> <pre><code>from fastapi import FastAPI\nfrom yourapp.crud import crud_router\nfrom yourapp.models import YourModel\nfrom yourapp.schemas import CreateYourModelSchema, UpdateYourModelSchema\nfrom yourapp.database import async_session\n\napp = FastAPI()\n\n# Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add\",\n    \"read\": \"fetch\",\n    \"update\": \"modify\",\n    \"delete\": \"remove\",\n    \"read_multi\": \"list\",\n    \"read_paginated\": \"paginate\"\n}\n\n# Setup CRUD router with custom endpoint names\napp.include_router(crud_router(\n    session=async_session,\n    model=YourModel,\n    create_schema=CreateYourModelSchema,\n    update_schema=UpdateYourModelSchema,\n    path=\"/yourmodel\",\n    tags=[\"YourModel\"],\n    endpoint_names=custom_endpoint_names\n))\n</code></pre> <p>In this example, the standard CRUD endpoints will be replaced with <code>/add</code>, <code>/fetch/{id}</code>, <code>/modify/{id}</code>, <code>/remove/{id}</code>, <code>/list</code>, and <code>/paginate</code>.</p>"},{"location":"advanced/endpoint/#example-using-endpointcreator","title":"Example: Using <code>EndpointCreator</code>","text":"<p>If you are using <code>EndpointCreator</code>, you can also pass the <code>endpoint_names</code> dictionary to customize the endpoint names similarly:</p> <pre><code># Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add_new\",\n    \"read\": \"get_single\",\n    \"update\": \"change\",\n    \"delete\": \"erase\",\n    \"db_delete\": \"hard_erase\",\n    \"read_multi\": \"get_all\",\n    \"read_paginated\": \"get_page\"\n}\n\n# Initialize and use the custom EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=YourModel,\n    create_schema=CreateYourModelSchema,\n    update_schema=UpdateYourModelSchema,\n    path=\"/yourmodel\",\n    tags=[\"YourModel\"],\n    endpoint_names=custom_endpoint_names\n)\n\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router)\n</code></pre> <p>Tip</p> <p>You only need to pass the names of the endpoints you want to change in the endpoint_names dict.</p>"},{"location":"advanced/endpoint/#extending-endpointcreator","title":"Extending EndpointCreator","text":"<p>You can create a subclass of <code>EndpointCreator</code> and override or add new methods to define custom routes. Here's an example:</p>"},{"location":"advanced/endpoint/#creating-a-custom-endpointcreator","title":"Creating a Custom EndpointCreator","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#adding-custom-routes","title":"Adding custom routes","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#overriding-add_routes_to_router","title":"Overriding <code>add_routes_to_router</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<pre><code># Assuming MyCustomEndpointCreator was created\n\n...\n\n# Use the custom EndpointCreator with crud_router\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    endpoint_creator=MyCustomEndpointCreator,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"]  # Including selective methods\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#custom-soft-delete","title":"Custom Soft Delete","text":"<p>To implement custom soft delete columns using <code>EndpointCreator</code> and <code>crud_router</code> in FastCRUD, you need to specify the names of the columns used for indicating deletion status and the deletion timestamp in your model. FastCRUD provides flexibility in handling soft deletes by allowing you to configure these column names directly when setting up CRUD operations or API endpoints.</p> <p>Here's how to specify custom soft delete columns when utilizing <code>EndpointCreator</code> and <code>crud_router</code>:</p>"},{"location":"advanced/endpoint/#defining-models-with-custom-soft-delete-columns","title":"Defining Models with Custom Soft Delete Columns","text":"<p>First, ensure your SQLAlchemy model is equipped with the custom soft delete columns. Here's an example model with custom columns for soft deletion:</p> <pre><code>from sqlalchemy import Column, Integer, String, DateTime, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom datetime import datetime\n\nBase = declarative_base()\n\nclass MyModel(Base):\n    __tablename__ = 'my_model'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)  # Custom soft delete column\n    archived_at = Column(DateTime)  # Custom timestamp column for soft delete\n</code></pre>"},{"location":"advanced/endpoint/#using-endpointcreator-and-crud_router-with-custom-soft-delete-or-update-columns","title":"Using <code>EndpointCreator</code> and <code>crud_router</code> with Custom Soft Delete or Update Columns","text":"<p>When initializing <code>crud_router</code> or creating a custom <code>EndpointCreator</code>, you can pass the names of your custom soft delete columns through the <code>FastCRUD</code> initialization. This informs FastCRUD which columns to check and update for soft deletion operations.</p> <p>Here's an example of using <code>crud_router</code> with custom soft delete columns:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\napp = FastAPI()\n\n# Assuming async_session is your AsyncSession generator\n# and MyModel is your SQLAlchemy model\n\n# Initialize FastCRUD with custom soft delete columns\nmy_model_crud = FastCRUD(MyModel,\n                         is_deleted_column='archived',  # Custom 'is_deleted' column name\n                         deleted_at_column='archived_at'  # Custom 'deleted_at' column name\n                        )\n\n# Setup CRUD router with the FastCRUD instance\napp.include_router(crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=my_model_crud,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n))\n</code></pre> <p>You may also directly pass the names of the columns to crud_router or EndpointCreator:</p> <pre><code>app.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    is_deleted_column='archived',\n    deleted_at_column='archived_at'\n))\n</code></pre> <p>You can also customize your <code>updated_at</code> column:</p> <pre><code>app.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    updated_at_column='date_updated'\n))\n</code></pre> <p>This setup ensures that the soft delete functionality within your application utilizes the <code>archived</code> and <code>archived_at</code> columns for marking records as deleted, rather than the default <code>is_deleted</code> and <code>deleted_at</code> fields.</p> <p>By specifying custom column names for soft deletion, you can adapt FastCRUD to fit the design of your database models, providing a flexible solution for handling deleted records in a way that best suits your application's needs.</p>"},{"location":"advanced/endpoint/#conclusion","title":"Conclusion","text":"<p>The <code>EndpointCreator</code> class in FastCRUD offers flexibility and control over CRUD operations and custom endpoint creation. By extending this class or using the <code>included_methods</code> and <code>deleted_methods</code> parameters, you can tailor your API's functionality to your specific requirements, ensuring a more customizable and streamlined experience.</p>"},{"location":"advanced/overview/","title":"Advanced Usage Overview","text":"<p>The Advanced section of our documentation delves into the sophisticated capabilities and features of our application, tailored for users looking to leverage advanced functionalities. This part of our guide aims to unlock deeper insights and efficiencies through more complex use cases and configurations.</p>"},{"location":"advanced/overview/#key-topics","title":"Key Topics","text":""},{"location":"advanced/overview/#1-advanced-filtering-and-searching","title":"1. Advanced Filtering and Searching","text":"<p>Explore how to implement advanced filtering and searching capabilities in your application. This guide covers the use of comparison operators (such as greater than, less than, etc.), pattern matching, and more to perform complex queries.</p> <ul> <li>Advanced Filtering Guide</li> </ul>"},{"location":"advanced/overview/#2-bulk-operations-and-batch-processing","title":"2. Bulk Operations and Batch Processing","text":"<p>Learn how to efficiently handle bulk operations and batch processing. This section provides insights into performing mass updates, deletes, and inserts, optimizing performance for large datasets.</p> <ul> <li>Bulk Operations Guide</li> </ul>"},{"location":"advanced/overview/#3-soft-delete-mechanisms-and-strategies","title":"3. Soft Delete Mechanisms and Strategies","text":"<p>Understand the implementation of soft delete mechanisms within our application. This guide covers configuring and using custom columns for soft deletes, restoring deleted records, and filtering queries to exclude soft-deleted entries.</p> <ul> <li>Soft Delete Strategies Guide</li> </ul>"},{"location":"advanced/overview/#4-advanced-use-of-endpointcreator-and-crud_router","title":"4. Advanced Use of EndpointCreator and crud_router","text":"<p>This topic extends the use of <code>EndpointCreator</code> and <code>crud_router</code> for advanced endpoint management, including creating custom routes, selective method exposure, and integrating soft delete functionalities.</p> <ul> <li>Advanced Endpoint Management Guide</li> </ul>"},{"location":"advanced/overview/#prerequisites","title":"Prerequisites","text":"<p>Advanced usage assumes a solid understanding of the basic features and functionalities of our application. Knowledge of FastAPI, SQLAlchemy, and Pydantic is highly recommended to fully grasp the concepts discussed.</p>"},{"location":"api/crud_router/","title":"CRUD Router API Reference","text":"<p><code>crud_router</code> is a utility function for creating and configuring a FastAPI router with CRUD endpoints for a given model.</p>"},{"location":"api/crud_router/#function-definition","title":"Function Definition","text":"<p>Creates and configures a FastAPI router with CRUD endpoints for a given model.</p> <p>This utility function streamlines the process of setting up a router for CRUD operations, using a custom <code>EndpointCreator</code> if provided, and managing dependency injections as well as selective method inclusions or exclusions.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>model</code> <code>DeclarativeBase</code> <p>The SQLAlchemy model.</p> required <code>crud</code> <code>Optional[FastCRUD]</code> <p>An optional FastCRUD instance. If not provided, uses FastCRUD(model).</p> <code>None</code> <code>create_schema</code> <code>Type[CreateSchemaType]</code> <p>Pydantic schema for creating an item.</p> required <code>update_schema</code> <code>Type[UpdateSchemaType]</code> <p>Pydantic schema for updating an item.</p> required <code>delete_schema</code> <code>Optional[Type[DeleteSchemaType]]</code> <p>Optional Pydantic schema for deleting an item.</p> <code>None</code> <code>path</code> <code>str</code> <p>Base path for the CRUD endpoints.</p> <code>''</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Optional list of tags for grouping endpoints in the documentation.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>True</code> <code>create_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to include. If None, all methods are included.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to exclude.</p> <code>None</code> <code>endpoint_creator</code> <code>Optional[Type[EndpointCreator]]</code> <p>Optional custom class derived from EndpointCreator for advanced customization.</p> <code>None</code> <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".</p> <code>'updated_at'</code> <code>endpoint_names</code> <code>Optional[dict[str, str]]</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>None</code> <p>Returns:</p> Type Description <code>APIRouter</code> <p>Configured APIRouter instance with the CRUD endpoints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both 'included_methods' and 'deleted_methods' are provided.</p> <p>Examples:</p> <p>Basic Setup: <pre><code>router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n</code></pre></p> <p>With Custom Dependencies: <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    # Implement user retrieval logic\n    return ...\n\nrouter = crud_router(\n    session=async_session,\n    model=UserModel,\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    path=\"/users\",\n    tags=[\"Users\"]\n)\n</code></pre></p> <p>Adding Delete Endpoints: <pre><code>router = crud_router(\n    session=async_session,\n    model=ProductModel,\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    delete_schema=DeleteProductSchema,\n    path=\"/products\",\n    tags=[\"Products\"]\n)\n</code></pre></p> <p>Customizing Path and Tags: <pre><code>router = crud_router(\n    session=async_session,\n    model=OrderModel,\n    crud=CRUDOrderModel(OrderModel),\n    create_schema=CreateOrderSchema,\n    update_schema=UpdateOrderSchema,\n    path=\"/orders\",\n    tags=[\"Orders\", \"Sales\"]\n)\n</code></pre></p> <p>Integrating Multiple Models: <pre><code>product_router = crud_router(\n    session=async_session,\n    model=ProductModel,\n    crud=CRUDProductModel(ProductModel),\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    path=\"/products\",\n    tags=[\"Inventory\"]\n)\n\ncustomer_router = crud_router(\n    session=async_session,\n    model=CustomerModel,\n    crud=CRUDCustomerModel(CustomerModel),\n    create_schema=CreateCustomerSchema,\n    update_schema=UpdateCustomerSchema,\n    path=\"/customers\",\n    tags=[\"CRM\"]\n)\n</code></pre></p> <p>With Selective CRUD Methods: <pre><code># Only include 'create' and 'read' methods\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    included_methods=[\"create\", \"read\"],\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n</code></pre></p> <p>Using a Custom EndpointCreator: <pre><code>class CustomEndpointCreator(EndpointCreator):\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n        async def add_routes_to_router(self, ...):\n            # First, add standard CRUD routes\n            super().add_routes_to_router(...)\n\n            # Now, add custom routes\n            self.router.add_api_route(\n                path=\"/custom\",\n                endpoint=self._custom_route(),\n                methods=[\"GET\"],\n                tags=self.tags,\n                # Other parameters as needed\n            )\n\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    endpoint_creator=CustomEndpointCreator,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n\napp.include_router(my_router)\n</code></pre></p> <p>Customizing Endpoint Names: <pre><code>router = crud_router(\n    session=async_session,\n    model=TaskModel,\n    create_schema=CreateTaskSchema,\n    update_schema=UpdateTaskSchema,\n    path=\"/tasks\",\n    tags=[\"Task Management\"],\n    endpoint_names={\n        \"create\": \"add_task\",\n        \"read\": \"get_task\",\n        \"update\": \"modify_task\",\n        \"delete\": \"remove_task\",\n        \"db_delete\": \"permanently_remove_task\",\n        \"read_multi\": \"list_tasks\",\n        \"read_paginated\": \"paginate_tasks\"\n    }\n)\n</code></pre></p> Source code in <code>fastcrud/endpoint/crud_router.py</code> <pre><code>def crud_router(\n    session: AsyncSession,\n    model: DeclarativeBase,\n    create_schema: Type[CreateSchemaType],\n    update_schema: Type[UpdateSchemaType],\n    crud: Optional[FastCRUD] = None,\n    delete_schema: Optional[Type[DeleteSchemaType]] = None,\n    path: str = \"\",\n    tags: Optional[List[str]] = None,\n    include_in_schema: bool = True,\n    create_deps: List[Callable] = [],\n    read_deps: List[Callable] = [],\n    read_multi_deps: List[Callable] = [],\n    read_paginated_deps: list[Callable] = [],\n    update_deps: List[Callable] = [],\n    delete_deps: List[Callable] = [],\n    db_delete_deps: List[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n    endpoint_creator: Optional[Type[EndpointCreator]] = None,\n    is_deleted_column: str = \"is_deleted\",\n    deleted_at_column: str = \"deleted_at\",\n    updated_at_column: str = \"updated_at\",\n    endpoint_names: Optional[dict[str, str]] = None,\n) -&gt; APIRouter:\n    \"\"\"\n    Creates and configures a FastAPI router with CRUD endpoints for a given model.\n\n    This utility function streamlines the process of setting up a router for CRUD operations,\n    using a custom `EndpointCreator` if provided, and managing dependency injections as well\n    as selective method inclusions or exclusions.\n\n    Args:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        crud: An optional FastCRUD instance. If not provided, uses FastCRUD(model).\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: Optional list of tags for grouping endpoints in the documentation.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        create_deps: Optional list of dependency injection functions for the create endpoint.\n        read_deps: Optional list of dependency injection functions for the read endpoint.\n        read_multi_deps: Optional list of dependency injection functions for the read multiple items endpoint.\n        update_deps: Optional list of dependency injection functions for the update endpoint.\n        delete_deps: Optional list of dependency injection functions for the delete endpoint.\n        db_delete_deps: Optional list of dependency injection functions for the hard delete endpoint.\n        included_methods: Optional list of CRUD methods to include. If None, all methods are included.\n        deleted_methods: Optional list of CRUD methods to exclude.\n        endpoint_creator: Optional custom class derived from EndpointCreator for advanced customization.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and\n                        values are the custom names to use. Unspecified operations will use default names.\n\n    Returns:\n        Configured APIRouter instance with the CRUD endpoints.\n\n    Raises:\n        ValueError: If both 'included_methods' and 'deleted_methods' are provided.\n\n    Examples:\n        Basic Setup:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n        ```\n\n        With Custom Dependencies:\n        ```python\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            # Implement user retrieval logic\n            return ...\n\n        router = crud_router(\n            session=async_session,\n            model=UserModel,\n            create_schema=CreateUserSchema,\n            update_schema=UpdateUserSchema,\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            path=\"/users\",\n            tags=[\"Users\"]\n        )\n        ```\n\n        Adding Delete Endpoints:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=ProductModel,\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            delete_schema=DeleteProductSchema,\n            path=\"/products\",\n            tags=[\"Products\"]\n        )\n        ```\n\n        Customizing Path and Tags:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=OrderModel,\n            crud=CRUDOrderModel(OrderModel),\n            create_schema=CreateOrderSchema,\n            update_schema=UpdateOrderSchema,\n            path=\"/orders\",\n            tags=[\"Orders\", \"Sales\"]\n        )\n        ```\n\n        Integrating Multiple Models:\n        ```python\n        product_router = crud_router(\n            session=async_session,\n            model=ProductModel,\n            crud=CRUDProductModel(ProductModel),\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            path=\"/products\",\n            tags=[\"Inventory\"]\n        )\n\n        customer_router = crud_router(\n            session=async_session,\n            model=CustomerModel,\n            crud=CRUDCustomerModel(CustomerModel),\n            create_schema=CreateCustomerSchema,\n            update_schema=UpdateCustomerSchema,\n            path=\"/customers\",\n            tags=[\"CRM\"]\n        )\n        ```\n\n        With Selective CRUD Methods:\n        ```python\n        # Only include 'create' and 'read' methods\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            included_methods=[\"create\", \"read\"],\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n        ```\n\n        Using a Custom EndpointCreator:\n        ```python\n        class CustomEndpointCreator(EndpointCreator):\n            def _custom_route(self):\n                async def custom_endpoint():\n                    # Custom endpoint logic\n                    return {\"message\": \"Custom route\"}\n\n                return custom_endpoint\n\n                async def add_routes_to_router(self, ...):\n                    # First, add standard CRUD routes\n                    super().add_routes_to_router(...)\n\n                    # Now, add custom routes\n                    self.router.add_api_route(\n                        path=\"/custom\",\n                        endpoint=self._custom_route(),\n                        methods=[\"GET\"],\n                        tags=self.tags,\n                        # Other parameters as needed\n                    )\n\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            endpoint_creator=CustomEndpointCreator,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n\n        app.include_router(my_router)\n        ```\n\n        Customizing Endpoint Names:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=TaskModel,\n            create_schema=CreateTaskSchema,\n            update_schema=UpdateTaskSchema,\n            path=\"/tasks\",\n            tags=[\"Task Management\"],\n            endpoint_names={\n                \"create\": \"add_task\",\n                \"read\": \"get_task\",\n                \"update\": \"modify_task\",\n                \"delete\": \"remove_task\",\n                \"db_delete\": \"permanently_remove_task\",\n                \"read_multi\": \"list_tasks\",\n                \"read_paginated\": \"paginate_tasks\"\n            }\n        )\n        ```\n    \"\"\"\n    crud = crud or FastCRUD(\n        model=model,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n    )\n\n    endpoint_creator_class = endpoint_creator or EndpointCreator\n    endpoint_creator_instance = endpoint_creator_class(\n        session=session,\n        model=model,\n        crud=crud,\n        create_schema=create_schema,\n        update_schema=update_schema,\n        include_in_schema=include_in_schema,\n        delete_schema=delete_schema,\n        path=path,\n        tags=tags,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n        endpoint_names=endpoint_names,\n    )\n\n    endpoint_creator_instance.add_routes_to_router(\n        create_deps=create_deps,\n        read_deps=read_deps,\n        read_multi_deps=read_multi_deps,\n        read_paginated_deps=read_paginated_deps,\n        update_deps=update_deps,\n        delete_deps=delete_deps,\n        db_delete_deps=db_delete_deps,\n        included_methods=included_methods,\n        deleted_methods=deleted_methods,\n    )\n\n    return endpoint_creator_instance.router\n</code></pre>"},{"location":"api/endpoint_creator/","title":"EndpointCreator API Reference","text":"<p><code>EndpointCreator</code> is a class designed to create and register CRUD endpoints for a FastAPI application. It simplifies the process of adding CRUD (Create, Read, Update, Delete) endpoints to a FastAPI router.</p>"},{"location":"api/endpoint_creator/#class-definition","title":"Class Definition","text":"<p>A class to create and register CRUD endpoints for a FastAPI application.</p> <p>This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations, and Pydantic schemas, and allows for custom dependency injection for each endpoint. The method assumes 'id' is the primary key for path parameters.</p> <p>Attributes:</p> Name Type Description <code>session</code> <p>The SQLAlchemy async session.</p> <code>model</code> <p>The SQLAlchemy model.</p> <code>crud</code> <p>An optional FastCRUD instance. If not provided, uses FastCRUD(model).</p> <code>create_schema</code> <p>Pydantic schema for creating an item.</p> <code>update_schema</code> <p>Pydantic schema for updating an item.</p> <code>delete_schema</code> <p>Optional Pydantic schema for deleting an item.</p> <code>include_in_schema</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>path</code> <p>Base path for the CRUD endpoints.</p> <code>tags</code> <p>List of tags for grouping endpoints in the documentation.</p> <code>is_deleted_column</code> <p>Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".</p> <code>deleted_at_column</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".</p> <code>updated_at_column</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".</p> <code>endpoint_names</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and             values are the custom names to use. Unspecified operations will use default names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Basic Setup: <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator\n\nfrom myapp.models import MyModel\nfrom myapp.schemas import CreateMyModel, UpdateMyModel\nfrom myapp.database import async_session\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel\n)\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n</code></pre></p> <p>With Custom Dependencies: <pre><code>from fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    return ...\n\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user]\n)\n</code></pre></p> <p>Selective Endpoint Creation (inclusion): <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"]\n)\n</code></pre></p> <p>Selective Endpoint Creation (deletion): <pre><code># Create all but 'update' and 'delete' endpoints\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"update\", \"delete\"]\n)\n</code></pre></p> <p>Integrating with Multiple Models: <pre><code># Assuming definitions for OtherModel, CRUDOtherModel, etc.\n\nother_model_crud = CRUDOtherModel(OtherModel)\nother_endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=OtherModel,\n    crud=other_model_crud,\n    create_schema=CreateOtherModel,\n    update_schema=UpdateOtherModel\n)\nother_endpoint_creator.add_routes_to_router()\napp.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n</code></pre></p> <p>Customizing Endpoint Names: <pre><code>endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names={\n        \"create\": \"add\",  # Custom endpoint name for creating items\n        \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n        \"update\": \"change\",  # Custom endpoint name for updating items\n        # The delete operation will use the default name \"delete\"\n    }\n)\nendpoint_creator.add_routes_to_router()\n</code></pre></p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>class EndpointCreator:\n    \"\"\"\n    A class to create and register CRUD endpoints for a FastAPI application.\n\n    This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints\n    to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations,\n    and Pydantic schemas, and allows for custom dependency injection for each endpoint.\n    The method assumes 'id' is the primary key for path parameters.\n\n    Attributes:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        crud: An optional FastCRUD instance. If not provided, uses FastCRUD(model).\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        path: Base path for the CRUD endpoints.\n        tags: List of tags for grouping endpoints in the documentation.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (\"create\", \"read\", \"update\", \"delete\", \"db_delete\", \"read_multi\", \"read_paginated\"), and\n                        values are the custom names to use. Unspecified operations will use default names.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Basic Setup:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator\n\n        from myapp.models import MyModel\n        from myapp.schemas import CreateMyModel, UpdateMyModel\n        from myapp.database import async_session\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel\n        )\n        endpoint_creator.add_routes_to_router()\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n        ```\n\n        With Custom Dependencies:\n        ```python\n        from fastapi.security import OAuth2PasswordBearer\n\n        oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            return ...\n\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user]\n        )\n        ```\n\n        Selective Endpoint Creation (inclusion):\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"]\n        )\n        ```\n\n        Selective Endpoint Creation (deletion):\n        ```python\n        # Create all but 'update' and 'delete' endpoints\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"update\", \"delete\"]\n        )\n        ```\n\n        Integrating with Multiple Models:\n        ```python\n        # Assuming definitions for OtherModel, CRUDOtherModel, etc.\n\n        other_model_crud = CRUDOtherModel(OtherModel)\n        other_endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=OtherModel,\n            crud=other_model_crud,\n            create_schema=CreateOtherModel,\n            update_schema=UpdateOtherModel\n        )\n        other_endpoint_creator.add_routes_to_router()\n        app.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n        ```\n\n        Customizing Endpoint Names:\n        ```python\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            endpoint_names={\n                \"create\": \"add\",  # Custom endpoint name for creating items\n                \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n                \"update\": \"change\",  # Custom endpoint name for updating items\n                # The delete operation will use the default name \"delete\"\n            }\n        )\n        endpoint_creator.add_routes_to_router()\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: AsyncSession,\n        model: DeclarativeBase,\n        create_schema: Type[CreateSchemaType],\n        update_schema: Type[UpdateSchemaType],\n        crud: Optional[FastCRUD] = None,\n        include_in_schema: bool = True,\n        delete_schema: Optional[Type[DeleteSchemaType]] = None,\n        path: str = \"\",\n        tags: Optional[list[str]] = None,\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n        endpoint_names: Optional[dict[str, str]] = None,\n    ) -&gt; None:\n        self.primary_key_name = _get_primary_key(model)\n        self.session = session\n        self.crud = crud or FastCRUD(\n            model=model,\n            is_deleted_column=is_deleted_column,\n            deleted_at_column=deleted_at_column,\n            updated_at_column=updated_at_column,\n        )\n        self.model = model\n        self.create_schema = create_schema\n        self.update_schema = update_schema\n        self.delete_schema = delete_schema\n        self.include_in_schema = include_in_schema\n        self.path = path\n        self.tags = tags or []\n        self.router = APIRouter()\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self.default_endpoint_names = {\n            \"create\": \"create\",\n            \"read\": \"get\",\n            \"update\": \"update\",\n            \"delete\": \"delete\",\n            \"db_delete\": \"db_delete\",\n            \"read_multi\": \"get_multi\",\n            \"read_paginated\": \"get_paginated\",\n        }\n        self.endpoint_names = {**self.default_endpoint_names, **(endpoint_names or {})}\n\n    def _create_item(self):\n        \"\"\"Creates an endpoint for creating items in the database.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            item: self.create_schema = Body(...),  # type: ignore\n        ):\n            unique_columns = _extract_unique_columns(self.model)\n\n            for column in unique_columns:\n                col_name = column.name\n                if hasattr(item, col_name):\n                    value = getattr(item, col_name)\n                    exists = await self.crud.exists(db, **{col_name: value})\n                    if exists:\n                        raise DuplicateValueException(\n                            f\"Value {value} is already registered\"\n                        )\n\n            return await self.crud.create(db, item)\n\n        return endpoint\n\n    def _read_item(self):\n        \"\"\"Creates an endpoint for reading a single item from the database.\"\"\"\n\n        async def endpoint(id: int, db: AsyncSession = Depends(self.session)):\n            item = await self.crud.get(db, id=id)\n            if not item:\n                raise NotFoundException(detail=\"Item not found\")\n            return item\n\n        return endpoint\n\n    def _read_items(self):\n        \"\"\"Creates an endpoint for reading multiple items from the database.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            offset: int = Query(0),\n            limit: int = Query(100),\n        ):\n            return await self.crud.get_multi(db, offset=offset, limit=limit)\n\n        return endpoint\n\n    def _read_paginated(self):\n        \"\"\"Creates an endpoint for reading multiple items from the database with pagination.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            page: int = Query(\n                1, alias=\"page\", description=\"Page number, starting from 1\"\n            ),\n            items_per_page: int = Query(\n                10, alias=\"itemsPerPage\", description=\"Number of items per page\"\n            ),\n        ):\n            offset = compute_offset(page=page, items_per_page=items_per_page)\n            crud_data = await self.crud.get_multi(\n                db, offset=offset, limit=items_per_page\n            )\n\n            return paginated_response(\n                crud_data=crud_data, page=page, items_per_page=items_per_page\n            )\n\n        return endpoint\n\n    def _update_item(self):\n        \"\"\"Creates an endpoint for updating an existing item in the database.\"\"\"\n\n        async def endpoint(\n            id: int,\n            item: self.update_schema = Body(...),  # type: ignore\n            db: AsyncSession = Depends(self.session),\n        ):\n            return await self.crud.update(db, item, id=id)\n\n        return endpoint\n\n    def _delete_item(self):\n        \"\"\"Creates an endpoint for deleting an item from the database.\"\"\"\n\n        async def endpoint(id: int, db: AsyncSession = Depends(self.session)):\n            await self.crud.delete(db, id=id)\n            return {\"message\": \"Item deleted successfully\"}\n\n        return endpoint\n\n    def _db_delete(self):\n        \"\"\"\n        Creates an endpoint for hard deleting an item from the database.\n\n        This endpoint is only added if the delete_schema is provided during initialization.\n        The endpoint expects an item ID as a path parameter and uses the provided SQLAlchemy\n        async session to permanently delete the item from the database.\n        \"\"\"\n\n        async def endpoint(id: int, db: AsyncSession = Depends(self.session)):\n            await self.crud.db_delete(db, id=id)\n            return {\"message\": \"Item permanently deleted from the database\"}\n\n        return endpoint\n\n    def _get_endpoint_name(self, operation: str) -&gt; str:\n        \"\"\"Get the endpoint name for a given CRUD operation, using defaults if not overridden by the user.\"\"\"\n        return self.endpoint_names.get(\n            operation, self.default_endpoint_names.get(operation, operation)\n        )\n\n    def add_routes_to_router(\n        self,\n        create_deps: list[Callable] = [],\n        read_deps: list[Callable] = [],\n        read_multi_deps: list[Callable] = [],\n        read_paginated_deps: list[Callable] = [],\n        update_deps: list[Callable] = [],\n        delete_deps: list[Callable] = [],\n        db_delete_deps: list[Callable] = [],\n        included_methods: Optional[list[str]] = None,\n        deleted_methods: Optional[list[str]] = None,\n    ):\n        \"\"\"\n        Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n        This method registers routes for create, read, update, and delete operations with the FastAPI router,\n        allowing for custom dependency injection for each type of operation.\n\n        Args:\n            create_deps: List of dependency injection functions for the create endpoint.\n            read_deps: List of dependency injection functions for the read endpoint.\n            read_multi_deps: List of dependency injection functions for the read multiple items endpoint.\n            update_deps: List of dependency injection functions for the update endpoint.\n            delete_deps: List of dependency injection functions for the delete endpoint.\n            db_delete_deps: List of dependency injection functions for the hard delete endpoint.\n            included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n            deleted_methods: Optional list of methods to exclude. Defaults to None.\n\n        Raises:\n            ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n        Examples:\n            Selective Endpoint Creation:\n            ```python\n            # Only create 'create' and 'read' endpoints\n            endpoint_creator.add_routes_to_router(\n                included_methods=[\"create\", \"read\"]\n            )\n            ```\n\n            Excluding Specific Endpoints:\n            ```python\n            # Create all endpoints except 'delete' and 'db_delete'\n            endpoint_creator.add_routes_to_router(\n                deleted_methods=[\"delete\", \"db_delete\"]\n            )\n            ```\n\n            With Custom Dependencies and Selective Endpoints:\n            ```python\n            def get_current_user(...):\n                ...\n\n            # Create only 'read' and 'update' endpoints with custom dependencies\n            endpoint_creator.add_routes_to_router(\n                read_deps=[get_current_user],\n                update_deps=[get_current_user],\n                included_methods=[\"read\", \"update\"]\n            )\n            ```\n\n        Note:\n            This method should be called to register the endpoints with the FastAPI application.\n            If 'delete_schema' is provided, a hard delete endpoint is also registered.\n            This method assumes 'id' is the primary key for path parameters.\n        \"\"\"\n        if (included_methods is not None) and (deleted_methods is not None):\n            raise ValueError(\n                \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n            )\n\n        if included_methods is None:\n            included_methods = [\n                \"create\",\n                \"read\",\n                \"read_multi\",\n                \"read_paginated\",\n                \"update\",\n                \"delete\",\n                \"db_delete\",\n            ]\n        else:\n            try:\n                included_methods = CRUDMethods(\n                    valid_methods=included_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n        if deleted_methods is None:\n            deleted_methods = []\n        else:\n            try:\n                deleted_methods = CRUDMethods(\n                    valid_methods=deleted_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n        delete_description = \"Delete a\"\n        if self.delete_schema:\n            delete_description = \"Soft delete a\"\n\n        if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"create\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}\",\n                self._create_item(),\n                methods=[\"POST\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=create_deps,\n                description=f\"Create a new {self.model.__name__} row in the database.\",\n            )\n\n        if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"read\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n                self._read_item(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=read_deps,\n                description=f\"Read a single {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n            )\n\n        if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"read_multi\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}\",\n                self._read_items(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=read_multi_deps,\n                description=f\"Read multiple {self.model.__name__} rows from the database with a limit and an offset.\",\n            )\n\n        if (\"read_paginated\" in included_methods) and (\n            \"read_paginated\" not in deleted_methods\n        ):\n            endpoint_name = self._get_endpoint_name(\"read_paginated\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}\",\n                self._read_paginated(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=read_paginated_deps,\n                description=f\"Read multiple {self.model.__name__} rows from the database with pagination.\",\n            )\n\n        if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"update\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n                self._update_item(),\n                methods=[\"PATCH\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=update_deps,\n                description=f\"Update an existing {self.model.__name__} row in the database by its primary key: {self.primary_key_name}.\",\n            )\n\n        if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n            endpoint_name = self._get_endpoint_name(\"delete\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n                self._delete_item(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=delete_deps,\n                description=f\"{delete_description} {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n            )\n\n        if (\n            (\"db_delete\" in included_methods)\n            and (\"db_delete\" not in deleted_methods)\n            and self.delete_schema\n        ):\n            endpoint_name = self._get_endpoint_name(\"db_delete\")\n            self.router.add_api_route(\n                f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n                self._db_delete(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=db_delete_deps,\n                description=f\"Permanently delete a {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n            )\n\n    def add_custom_route(\n        self,\n        endpoint: Callable,\n        methods: list[str],\n        path: Optional[str] = None,\n        dependencies: Optional[list[Callable]] = None,\n        include_in_schema: bool = True,\n        tags: Optional[list[str]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Adds a custom route to the FastAPI router.\n\n        Args:\n            path: URL path for the custom route.\n            endpoint: The endpoint function to execute when the route is called.\n            methods: A list of HTTP methods for the route (e.g., ['GET', 'POST']).\n            dependencies: A list of dependency injection functions for the route.\n            include_in_schema: Whether to include this route in the OpenAPI schema.\n            tags: Tags for grouping and categorizing the route in documentation.\n            summary: A short summary of the route, for documentation.\n            description: A detailed description of the route, for documentation.\n            response_description: A description of the response, for documentation.\n\n        Example:\n            ```python\n            async def custom_endpoint(foo: int, bar: str):\n                # custom logic here\n                return {\"foo\": foo, \"bar\": bar}\n\n            endpoint_creator.add_custom_route(\n                endpoint=custom_endpoint,\n                path=\"/custom\",\n                methods=[\"GET\"],\n                tags=[\"custom\"],\n                summary=\"Custom Endpoint\",\n                description=\"This is a custom endpoint.\"\n            )\n            ```\n        \"\"\"\n        path = path or self.path\n        full_path = f\"{self.path}{path}\"\n        self.router.add_api_route(\n            path=full_path,\n            endpoint=endpoint,\n            methods=methods,\n            dependencies=dependencies or [],\n            include_in_schema=include_in_schema,\n            tags=tags or self.tags,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n        )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_custom_route","title":"<code>add_custom_route(endpoint, methods, path=None, dependencies=None, include_in_schema=True, tags=None, summary=None, description=None, response_description=None)</code>","text":"<p>Adds a custom route to the FastAPI router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[str]</code> <p>URL path for the custom route.</p> <code>None</code> <code>endpoint</code> <code>Callable</code> <p>The endpoint function to execute when the route is called.</p> required <code>methods</code> <code>list[str]</code> <p>A list of HTTP methods for the route (e.g., ['GET', 'POST']).</p> required <code>dependencies</code> <code>Optional[list[Callable]]</code> <p>A list of dependency injection functions for the route.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include this route in the OpenAPI schema.</p> <code>True</code> <code>tags</code> <code>Optional[list[str]]</code> <p>Tags for grouping and categorizing the route in documentation.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A short summary of the route, for documentation.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A detailed description of the route, for documentation.</p> <code>None</code> <code>response_description</code> <code>Optional[str]</code> <p>A description of the response, for documentation.</p> <code>None</code> Example <pre><code>async def custom_endpoint(foo: int, bar: str):\n    # custom logic here\n    return {\"foo\": foo, \"bar\": bar}\n\nendpoint_creator.add_custom_route(\n    endpoint=custom_endpoint,\n    path=\"/custom\",\n    methods=[\"GET\"],\n    tags=[\"custom\"],\n    summary=\"Custom Endpoint\",\n    description=\"This is a custom endpoint.\"\n)\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_custom_route(\n    self,\n    endpoint: Callable,\n    methods: list[str],\n    path: Optional[str] = None,\n    dependencies: Optional[list[Callable]] = None,\n    include_in_schema: bool = True,\n    tags: Optional[list[str]] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    response_description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Adds a custom route to the FastAPI router.\n\n    Args:\n        path: URL path for the custom route.\n        endpoint: The endpoint function to execute when the route is called.\n        methods: A list of HTTP methods for the route (e.g., ['GET', 'POST']).\n        dependencies: A list of dependency injection functions for the route.\n        include_in_schema: Whether to include this route in the OpenAPI schema.\n        tags: Tags for grouping and categorizing the route in documentation.\n        summary: A short summary of the route, for documentation.\n        description: A detailed description of the route, for documentation.\n        response_description: A description of the response, for documentation.\n\n    Example:\n        ```python\n        async def custom_endpoint(foo: int, bar: str):\n            # custom logic here\n            return {\"foo\": foo, \"bar\": bar}\n\n        endpoint_creator.add_custom_route(\n            endpoint=custom_endpoint,\n            path=\"/custom\",\n            methods=[\"GET\"],\n            tags=[\"custom\"],\n            summary=\"Custom Endpoint\",\n            description=\"This is a custom endpoint.\"\n        )\n        ```\n    \"\"\"\n    path = path or self.path\n    full_path = f\"{self.path}{path}\"\n    self.router.add_api_route(\n        path=full_path,\n        endpoint=endpoint,\n        methods=methods,\n        dependencies=dependencies or [],\n        include_in_schema=include_in_schema,\n        tags=tags or self.tags,\n        summary=summary,\n        description=description,\n        response_description=response_description,\n    )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_routes_to_router","title":"<code>add_routes_to_router(create_deps=[], read_deps=[], read_multi_deps=[], read_paginated_deps=[], update_deps=[], delete_deps=[], db_delete_deps=[], included_methods=None, deleted_methods=None)</code>","text":"<p>Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.</p> <p>This method registers routes for create, read, update, and delete operations with the FastAPI router, allowing for custom dependency injection for each type of operation.</p> <p>Parameters:</p> Name Type Description Default <code>create_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of methods to include. Defaults to all CRUD methods.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of methods to exclude. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Selective Endpoint Creation: <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"]\n)\n</code></pre></p> <p>Excluding Specific Endpoints: <pre><code># Create all endpoints except 'delete' and 'db_delete'\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"delete\", \"db_delete\"]\n)\n</code></pre></p> <p>With Custom Dependencies and Selective Endpoints: <pre><code>def get_current_user(...):\n    ...\n\n# Create only 'read' and 'update' endpoints with custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    included_methods=[\"read\", \"update\"]\n)\n</code></pre></p> Note <p>This method should be called to register the endpoints with the FastAPI application. If 'delete_schema' is provided, a hard delete endpoint is also registered. This method assumes 'id' is the primary key for path parameters.</p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_routes_to_router(\n    self,\n    create_deps: list[Callable] = [],\n    read_deps: list[Callable] = [],\n    read_multi_deps: list[Callable] = [],\n    read_paginated_deps: list[Callable] = [],\n    update_deps: list[Callable] = [],\n    delete_deps: list[Callable] = [],\n    db_delete_deps: list[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n):\n    \"\"\"\n    Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n    This method registers routes for create, read, update, and delete operations with the FastAPI router,\n    allowing for custom dependency injection for each type of operation.\n\n    Args:\n        create_deps: List of dependency injection functions for the create endpoint.\n        read_deps: List of dependency injection functions for the read endpoint.\n        read_multi_deps: List of dependency injection functions for the read multiple items endpoint.\n        update_deps: List of dependency injection functions for the update endpoint.\n        delete_deps: List of dependency injection functions for the delete endpoint.\n        db_delete_deps: List of dependency injection functions for the hard delete endpoint.\n        included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n        deleted_methods: Optional list of methods to exclude. Defaults to None.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Selective Endpoint Creation:\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"]\n        )\n        ```\n\n        Excluding Specific Endpoints:\n        ```python\n        # Create all endpoints except 'delete' and 'db_delete'\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"delete\", \"db_delete\"]\n        )\n        ```\n\n        With Custom Dependencies and Selective Endpoints:\n        ```python\n        def get_current_user(...):\n            ...\n\n        # Create only 'read' and 'update' endpoints with custom dependencies\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            included_methods=[\"read\", \"update\"]\n        )\n        ```\n\n    Note:\n        This method should be called to register the endpoints with the FastAPI application.\n        If 'delete_schema' is provided, a hard delete endpoint is also registered.\n        This method assumes 'id' is the primary key for path parameters.\n    \"\"\"\n    if (included_methods is not None) and (deleted_methods is not None):\n        raise ValueError(\n            \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n        )\n\n    if included_methods is None:\n        included_methods = [\n            \"create\",\n            \"read\",\n            \"read_multi\",\n            \"read_paginated\",\n            \"update\",\n            \"delete\",\n            \"db_delete\",\n        ]\n    else:\n        try:\n            included_methods = CRUDMethods(\n                valid_methods=included_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n    if deleted_methods is None:\n        deleted_methods = []\n    else:\n        try:\n            deleted_methods = CRUDMethods(\n                valid_methods=deleted_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n    delete_description = \"Delete a\"\n    if self.delete_schema:\n        delete_description = \"Soft delete a\"\n\n    if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"create\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}\",\n            self._create_item(),\n            methods=[\"POST\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=create_deps,\n            description=f\"Create a new {self.model.__name__} row in the database.\",\n        )\n\n    if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"read\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n            self._read_item(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=read_deps,\n            description=f\"Read a single {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n        )\n\n    if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"read_multi\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}\",\n            self._read_items(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=read_multi_deps,\n            description=f\"Read multiple {self.model.__name__} rows from the database with a limit and an offset.\",\n        )\n\n    if (\"read_paginated\" in included_methods) and (\n        \"read_paginated\" not in deleted_methods\n    ):\n        endpoint_name = self._get_endpoint_name(\"read_paginated\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}\",\n            self._read_paginated(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=read_paginated_deps,\n            description=f\"Read multiple {self.model.__name__} rows from the database with pagination.\",\n        )\n\n    if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"update\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n            self._update_item(),\n            methods=[\"PATCH\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=update_deps,\n            description=f\"Update an existing {self.model.__name__} row in the database by its primary key: {self.primary_key_name}.\",\n        )\n\n    if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n        endpoint_name = self._get_endpoint_name(\"delete\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n            self._delete_item(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=delete_deps,\n            description=f\"{delete_description} {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n        )\n\n    if (\n        (\"db_delete\" in included_methods)\n        and (\"db_delete\" not in deleted_methods)\n        and self.delete_schema\n    ):\n        endpoint_name = self._get_endpoint_name(\"db_delete\")\n        self.router.add_api_route(\n            f\"{self.path}/{endpoint_name}/{{{self.primary_key_name}}}\",\n            self._db_delete(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=db_delete_deps,\n            description=f\"Permanently delete a {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n        )\n</code></pre>"},{"location":"api/fastcrud/","title":"FastCRUD API Reference","text":"<p><code>FastCRUD</code> is a base class for CRUD operations on a model, utilizing Pydantic schemas for data validation and serialization.</p>"},{"location":"api/fastcrud/#class-definition","title":"Class Definition","text":"<p>             Bases: <code>Generic[ModelType, CreateSchemaType, UpdateSchemaType, UpdateSchemaInternalType, DeleteSchemaType]</code></p> <p>Base class for CRUD operations on a model.</p> <p>This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model, utilizing Pydantic schemas for data validation and serialization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[ModelType]</code> <p>The SQLAlchemy model type.</p> required <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".</p> <code>'updated_at'</code> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new record in the database from the provided Pydantic schema.</p> <code>get</code> <p>Retrieves a single record based on filters. Supports advanced filtering through comparison operators like '__gt', '__lt', etc.</p> <code>exists</code> <p>Checks if a record exists based on the provided filters.</p> <code>count</code> <p>Counts the number of records matching the provided filters.</p> <code>get_multi</code> <p>Fetches multiple records with optional sorting, pagination, and model conversion.</p> <code>get_joined</code> <p>Performs a join operation with another model, supporting custom join conditions and selection of specific columns.</p> <code>get_multi_joined</code> <p>Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.</p> <code>get_multi_by_cursor</code> <p>Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.</p> <code>update</code> <p>Updates an existing record or multiple records based on specified filters.</p> <code>db_delete</code> <p>Hard deletes a record or multiple records from the database based on provided filters.</p> <code>delete</code> <p>Soft deletes a record if it has an \"is_deleted\" attribute; otherwise, performs a hard delete.</p> <p>Examples:</p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-1-basic-usage","title":"Example 1: Basic Usage","text":"<p>Create a FastCRUD instance for a User model and perform basic CRUD operations. <pre><code>user_crud = FastCRUD(User, UserCreateSchema, UserUpdateSchema)\nasync with db_session() as db:\n    # Create a new user\n    new_user = await user_crud.create(db, UserCreateSchema(name=\"Alice\"))\n    # Read a user\n    user = await user_crud.get(db, id=new_user.id)\n    # Update a user\n    await user_crud.update(db, UserUpdateSchema(email=\"alice@example.com\"), id=new_user.id)\n    # Delete a user\n    await user_crud.delete(db, id=new_user.id)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-2-advanced-filtering-and-pagination","title":"Example 2: Advanced Filtering and Pagination","text":"<p>Use advanced filtering, sorting, and pagination for fetching records. <pre><code>product_crud = FastCRUD(Product, ProductCreateSchema)\nasync with db_session() as db:\n    products = await product_crud.get_multi(\n        db, offset=0, limit=10, sort_columns=['price'], sort_orders=['asc']\n    )\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-3-join-operations-with-custom-schemas","title":"Example 3: Join Operations with Custom Schemas","text":"<p>Perform join operations between two models using custom schemas for selection. <pre><code>order_crud = FastCRUD(Order, OrderCreateSchema, join_model=Product)\nasync with db_session() as db:\n    orders = await order_crud.get_multi_joined(\n        db, offset=0, limit=5, schema_to_select=OrderReadSchema, join_schema_to_select=ProductReadSchema\n    )\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-4-cursor-pagination","title":"Example 4: Cursor Pagination","text":"<p>Implement cursor-based pagination for efficient data retrieval in large datasets. <pre><code>comment_crud = FastCRUD(Comment, CommentCreateSchema)\nasync with db_session() as db:\n    first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n    next_cursor = first_page['next_cursor']\n    second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-5-dynamic-filtering-and-counting","title":"Example 5: Dynamic Filtering and Counting","text":"<p>Dynamically filter records based on various criteria and count the results. <pre><code>task_crud = FastCRUD(Task, TaskCreateSchema)\nasync with db_session() as db:\n    completed_tasks = await task_crud.get_multi(db, status='completed')\n    high_priority_task_count = await task_crud.count(db, priority='high')\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-6-using-custom-column-names-for-soft-delete","title":"Example 6: Using Custom Column Names for Soft Delete","text":"<p>If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the FastCRUD instance. <pre><code>custom_user_crud = FastCRUD(User, UserCreateSchema, UserUpdateSchema, is_deleted_column=\"archived\", deleted_at_column=\"archived_at\")\n# Now 'archived' and 'archived_at' will be used for soft delete operations.\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>class FastCRUD(\n    Generic[\n        ModelType,\n        CreateSchemaType,\n        UpdateSchemaType,\n        UpdateSchemaInternalType,\n        DeleteSchemaType,\n    ]\n):\n    \"\"\"\n    Base class for CRUD operations on a model.\n\n    This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model,\n    utilizing Pydantic schemas for data validation and serialization.\n\n    Args:\n        model: The SQLAlchemy model type.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to \"is_deleted\".\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to \"deleted_at\".\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to \"updated_at\".\n\n    Methods:\n        create:\n            Creates a new record in the database from the provided Pydantic schema.\n\n        get:\n            Retrieves a single record based on filters. Supports advanced filtering through comparison operators like '__gt', '__lt', etc.\n\n        exists:\n            Checks if a record exists based on the provided filters.\n\n        count:\n            Counts the number of records matching the provided filters.\n\n        get_multi:\n            Fetches multiple records with optional sorting, pagination, and model conversion.\n\n        get_joined:\n            Performs a join operation with another model, supporting custom join conditions and selection of specific columns.\n\n        get_multi_joined:\n            Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.\n\n        get_multi_by_cursor:\n            Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.\n\n        update:\n            Updates an existing record or multiple records based on specified filters.\n\n        db_delete:\n            Hard deletes a record or multiple records from the database based on provided filters.\n\n        delete:\n            Soft deletes a record if it has an \"is_deleted\" attribute; otherwise, performs a hard delete.\n\n    Examples:\n        Example 1: Basic Usage\n        ----------------------\n        Create a FastCRUD instance for a User model and perform basic CRUD operations.\n        ```python\n        user_crud = FastCRUD(User, UserCreateSchema, UserUpdateSchema)\n        async with db_session() as db:\n            # Create a new user\n            new_user = await user_crud.create(db, UserCreateSchema(name=\"Alice\"))\n            # Read a user\n            user = await user_crud.get(db, id=new_user.id)\n            # Update a user\n            await user_crud.update(db, UserUpdateSchema(email=\"alice@example.com\"), id=new_user.id)\n            # Delete a user\n            await user_crud.delete(db, id=new_user.id)\n        ```\n\n        Example 2: Advanced Filtering and Pagination\n        --------------------------------------------\n        Use advanced filtering, sorting, and pagination for fetching records.\n        ```python\n        product_crud = FastCRUD(Product, ProductCreateSchema)\n        async with db_session() as db:\n            products = await product_crud.get_multi(\n                db, offset=0, limit=10, sort_columns=['price'], sort_orders=['asc']\n            )\n        ```\n\n        Example 3: Join Operations with Custom Schemas\n        ----------------------------------------------\n        Perform join operations between two models using custom schemas for selection.\n        ```python\n        order_crud = FastCRUD(Order, OrderCreateSchema, join_model=Product)\n        async with db_session() as db:\n            orders = await order_crud.get_multi_joined(\n                db, offset=0, limit=5, schema_to_select=OrderReadSchema, join_schema_to_select=ProductReadSchema\n            )\n        ```\n\n        Example 4: Cursor Pagination\n        ----------------------------\n        Implement cursor-based pagination for efficient data retrieval in large datasets.\n        ```python\n        comment_crud = FastCRUD(Comment, CommentCreateSchema)\n        async with db_session() as db:\n            first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n            next_cursor = first_page['next_cursor']\n            second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n        ```\n\n        Example 5: Dynamic Filtering and Counting\n        -----------------------------------------\n        Dynamically filter records based on various criteria and count the results.\n        ```python\n        task_crud = FastCRUD(Task, TaskCreateSchema)\n        async with db_session() as db:\n            completed_tasks = await task_crud.get_multi(db, status='completed')\n            high_priority_task_count = await task_crud.count(db, priority='high')\n        ```\n\n        Example 6: Using Custom Column Names for Soft Delete\n        ----------------------------------------------------\n        If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the FastCRUD instance.\n        ```python\n        custom_user_crud = FastCRUD(User, UserCreateSchema, UserUpdateSchema, is_deleted_column=\"archived\", deleted_at_column=\"archived_at\")\n        # Now 'archived' and 'archived_at' will be used for soft delete operations.\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model: type[ModelType],\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n    ) -&gt; None:\n        self.model = model\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n\n    def _parse_filters(self, **kwargs) -&gt; list[BinaryExpression]:\n        filters = []\n        for key, value in kwargs.items():\n            if \"__\" in key:\n                field_name, op = key.rsplit(\"__\", 1)\n                column = getattr(self.model, field_name, None)\n                if column is None:\n                    raise ValueError(f\"Invalid filter column: {field_name}\")\n\n                if op == \"gt\":\n                    filters.append(column &gt; value)\n                elif op == \"lt\":\n                    filters.append(column &lt; value)\n                elif op == \"gte\":\n                    filters.append(column &gt;= value)\n                elif op == \"lte\":\n                    filters.append(column &lt;= value)\n                elif op == \"ne\":\n                    filters.append(column != value)\n            else:\n                column = getattr(self.model, key, None)\n                if column is not None:\n                    filters.append(column == value)\n\n        return filters\n\n    def _apply_sorting(\n        self,\n        stmt: Select,\n        sort_columns: Union[str, list[str]],\n        sort_orders: Optional[Union[str, list[str]]] = None,\n    ) -&gt; Select:\n        \"\"\"\n        Apply sorting to a SQLAlchemy query based on specified column names and sort orders.\n\n        Args:\n            stmt: The SQLAlchemy Select statement to which sorting will be applied.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding\n                to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n\n        Raises:\n            ValueError: Raised if sort orders are provided without corresponding sort columns,\n                or if an invalid sort order is provided (not 'asc' or 'desc').\n            ArgumentError: Raised if an invalid column name is provided that does not exist in the model.\n\n        Returns:\n            The modified Select statement with sorting applied.\n\n        Examples:\n            Applying ascending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'name')\n\n            Applying descending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'age', 'desc')\n\n            Applying mixed sort orders on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'], ['asc', 'desc'])\n\n            Applying ascending sort on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'])\n\n        Note:\n            This method modifies the passed Select statement in-place by applying the order_by clause\n            based on the provided column names and sort orders.\n        \"\"\"\n        if sort_orders and not sort_columns:\n            raise ValueError(\"Sort orders provided without corresponding sort columns.\")\n\n        if sort_columns:\n            if not isinstance(sort_columns, list):\n                sort_columns = [sort_columns]\n\n            if sort_orders:\n                if not isinstance(sort_orders, list):\n                    sort_orders = [sort_orders] * len(sort_columns)\n                if len(sort_columns) != len(sort_orders):\n                    raise ValueError(\n                        \"The length of sort_columns and sort_orders must match.\"\n                    )\n\n                for idx, order in enumerate(sort_orders):\n                    if order not in [\"asc\", \"desc\"]:\n                        raise ValueError(\n                            f\"Invalid sort order: {order}. Only 'asc' or 'desc' are allowed.\"\n                        )\n\n            validated_sort_orders = (\n                [\"asc\"] * len(sort_columns) if not sort_orders else sort_orders\n            )\n\n            for idx, column_name in enumerate(sort_columns):\n                column = getattr(self.model, column_name, None)\n                if not column:\n                    raise ArgumentError(f\"Invalid column name: {column_name}\")\n\n                order = validated_sort_orders[idx]\n                stmt = stmt.order_by(asc(column) if order == \"asc\" else desc(column))\n\n        return stmt\n\n    async def create(self, db: AsyncSession, object: CreateSchemaType) -&gt; ModelType:\n        \"\"\"\n        Create a new record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            object: The Pydantic schema containing the data to be saved.\n\n        Returns:\n            The created database object.\n        \"\"\"\n        object_dict = object.model_dump()\n        db_object: ModelType = self.model(**object_dict)\n        db.add(db_object)\n        await db.commit()\n        return db_object\n\n    async def get(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict, BaseModel]]:\n        \"\"\"\n        Fetches a single record based on specified filters.\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n        Supported operators include:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            schema_to_select: Optional Pydantic schema for selecting specific columns.\n            **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n        Raises:\n            ValueError: If return_as_model is True but schema_to_select is not provided.\n\n        Returns:\n            A dictionary or a Pydantic model instance of the fetched database row, or None if no match is found.\n\n        Examples:\n            Fetch a user by ID:\n            ```python\n            user = await crud.get(db, id=1)\n            ```\n\n            Fetch a user with an age greater than 30:\n            ```python\n            user = await crud.get(db, age__gt=30)\n            ```\n\n            Fetch a user with a registration date before Jan 1, 2020:\n            ```python\n            user = await crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Fetch a user not equal to a specific username:\n            ```python\n            user = await crud.get(db, username__ne='admin')\n            ```\n        \"\"\"\n        to_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        filters = self._parse_filters(**kwargs)\n        stmt = select(*to_select).filter(*filters)\n\n        db_row = await db.execute(stmt)\n        result: Row = db_row.first()\n        if result is not None:\n            out: dict = dict(result._mapping)\n            if return_as_model:\n                if not schema_to_select:\n                    raise ValueError(\n                        \"schema_to_select must be provided when return_as_model is True.\"\n                    )\n                return schema_to_select(**out)\n            return out\n\n        return None\n\n    async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n        \"\"\"\n        Checks if any records exist that match the given filter conditions.\n        This method supports advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n        Returns:\n            True if at least one record matches the filter conditions, False otherwise.\n\n        Examples:\n            Fetch a user by ID exists:\n            ```python\n            exists = await crud.exists(db, id=1)\n            ```\n\n            Check if any user is older than 30:\n            ```python\n            exists = await crud.exists(db, age__gt=30)\n            ```\n\n            Check if any user registered before Jan 1, 2020:\n            ```python\n            exists = await crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Check if a username other than 'admin' exists:\n            ```python\n            exists = await crud.exists(db, username__ne='admin')\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        stmt = select(self.model).filter(*filters).limit(1)\n\n        result = await db.execute(stmt)\n        return result.first() is not None\n\n    async def count(self, db: AsyncSession, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Counts records that match specified filters, supporting advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n        Returns:\n            The total number of records matching the filter conditions.\n\n        Examples:\n            Count users by ID:\n            ```python\n            exists = await crud.count(db, id=1)\n            ```\n\n            Count users older than 30:\n            ```python\n            exists = await crud.count(db, age__gt=30)\n            ```\n\n            Count users who registered before Jan 1, 2020:\n            ```python\n            exists = await crud.count(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Count users with a username other than 'admin':\n            ```python\n            exists = await crud.count(db, username__ne='admin')\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        if filters:\n            count_query = select(func.count()).select_from(self.model).filter(*filters)\n        else:\n            count_query = select(func.count()).select_from(self.model)\n\n        total_count: int = await db.scalar(count_query)\n        return total_count\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        offset: int = 0,\n        limit: int = 100,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetches multiple records based on filters, supporting sorting, pagination, and advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            offset: Starting index for records to fetch, useful for pagination.\n            limit: Maximum number of records to fetch in one call.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n            sort_columns: Column names to sort the results by.\n            sort_orders: Corresponding sort orders ('asc', 'desc') for each column in sort_columns.\n            return_as_model: If True, returns data as instances of the specified Pydantic model.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n        Returns:\n            A dictionary containing 'data' with fetched records and 'total_count' indicating the total number of records matching the filters.\n\n        Raises:\n            ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n        Examples:\n            Fetch the first 10 users:\n            ```python\n            users = await crud.get_multi(db, 0, 10)\n            ```\n\n            Fetch next 10 users with sorted by username:\n            ```python\n            users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n            ```\n\n            Fetch 10 users older than 30, sorted by age in descending order:\n            ```python\n            get_multi(db, offset=0, limit=10, age__gt=30, sort_columns='age', sort_orders='desc')\n            ```\n\n            Fetch 10 users with a registration date before Jan 1, 2020:\n            ```python\n            get_multi(db, offset=0, limit=10, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Fetch 10 users with a username other than 'admin', returning as model instances (ensure appropriate schema is passed):\n            ```python\n            get_multi(db, offset=0, limit=10, username__ne='admin', schema_to_select=UserSchema, return_as_model=True)\n            ```\n\n            Fetch users with filtering and multiple column sorting:\n            ```python\n            users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n            ```\n        \"\"\"\n        if limit &lt; 0 or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n        filters = self._parse_filters(**kwargs)\n        stmt = select(*to_select).filter(*filters)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n        stmt = stmt.offset(offset).limit(limit)\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        if return_as_model:\n            if not schema_to_select:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                data = [schema_to_select.model_construct(**row) for row in data]\n            except ValidationError as e:\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n\n        total_count = await self.count(db=db, **kwargs)\n        return {\"data\": data, \"total_count\": total_count}\n\n    async def get_joined(\n        self,\n        db: AsyncSession,\n        join_model: type[ModelType],\n        join_prefix: Optional[str] = None,\n        join_on: Optional[Union[Join, None]] = None,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        join_schema_to_select: Optional[type[BaseModel]] = None,\n        join_type: str = \"left\",\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"\n        Fetches a single record with a join on another model. If 'join_on' is not provided, the method attempts\n        to automatically detect the join condition using foreign key relationships. Advanced filters supported:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The SQLAlchemy async session.\n            join_model: The model to join with.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n            join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is\n                auto-detected based on foreign keys.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n            **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary representing the joined record, or None if no record matches the criteria.\n\n        Examples:\n            Simple example: Joining User and Tier models without explicitly providing join_on\n            ```python\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema\n            )\n            ```\n\n            Fetch a user and their associated tier, filtering by user ID:\n            ```python\n            get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, id=1)\n            ```\n\n            Fetch a user and their associated tier, where the user's age is greater than 30:\n            ```python\n            get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, age__gt=30)\n            ```\n\n            Fetch a user and their associated tier, excluding users with the 'admin' username:\n            ```python\n            get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, username__ne='admin')\n            ```\n\n            Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n            ```python\n            from sqlalchemy import and_\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                username=\"john_doe\"\n            )\n            ```\n\n            Return example: prefix added, no schema_to_select or join_schema_to_select\n            ```python\n            {\n                \"id\": 1,\n                \"name\": \"John Doe\",\n                \"username\": \"john_doe\",\n                \"email\": \"johndoe@example.com\",\n                \"hashed_password\": \"hashed_password_example\",\n                \"profile_image_url\": \"https://profileimageurl.com/default.jpg\",\n                \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n                \"created_at\": \"2023-01-01T12:00:00\",\n                \"updated_at\": \"2023-01-02T12:00:00\",\n                \"deleted_at\": null,\n                \"is_deleted\": false,\n                \"is_superuser\": false,\n                \"tier_id\": 2,\n                \"tier_name\": \"Premium\",\n                \"tier_created_at\": \"2022-12-01T10:00:00\",\n                \"tier_updated_at\": \"2023-01-01T11:00:00\"\n            }\n            ```\n        \"\"\"\n        if join_on is None:\n            join_on = _auto_detect_join_condition(self.model, join_model)\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        join_select = []\n\n        if join_schema_to_select:\n            columns = _extract_matching_columns_from_schema(\n                model=join_model, schema=join_schema_to_select\n            )\n        else:\n            columns = inspect(join_model).c\n\n        for column in columns:\n            labeled_column = _add_column_with_prefix(column, join_prefix)\n            if f\"{join_prefix}{column.name}\" not in [\n                col.name for col in primary_select\n            ]:\n                join_select.append(labeled_column)\n\n        if join_type == \"left\":\n            stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n        elif join_type == \"inner\":\n            stmt = select(*primary_select, *join_select).join(join_model, join_on)\n        else:\n            raise ValueError(\n                f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n            )\n\n        filters = self._parse_filters(**kwargs)\n        if filters:\n            stmt = stmt.filter(*filters)\n\n        db_row = await db.execute(stmt)\n        result: Row = db_row.first()\n        if result:\n            out: dict = dict(result._mapping)\n            return out\n\n        return None\n\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        join_model: type[ModelType],\n        join_prefix: Optional[str] = None,\n        join_on: Optional[Join] = None,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        join_schema_to_select: Optional[type[BaseModel]] = None,\n        join_type: str = \"left\",\n        offset: int = 0,\n        limit: int = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion,\n        supporting advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The SQLAlchemy async session.\n            join_model: The model to join with.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n            join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n            offset: The offset (number of records to skip) for pagination.\n            limit: The limit (maximum number of records to return) for pagination.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n            return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n            **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n        Raises:\n            ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n        Examples:\n            Fetching multiple User records joined with Tier records, using left join, returning raw data:\n            ```python\n            users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10\n            )\n            ```\n\n            Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n            ```python\n            users = get_multi_joined(\n                db,\n                User,\n                Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                age__gt=30,\n                sort_columns='username',\n                sort_orders='asc'\n            )\n            ```\n\n            Fetch users joined with their tiers, excluding users with 'admin' username, returning as model instances:\n            ```python\n            users = get_multi_joined(\n                db,\n                User,\n                Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                username__ne='admin',\n                return_as_model=True\n            )\n            ```\n\n            Fetching and sorting by username in descending order, returning as Pydantic model:\n            ```python\n            users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10,\n                sort_columns=['username'],\n                sort_orders=['desc'],\n                return_as_model=True\n            )\n            ```\n\n            Fetching with complex conditions and custom join, returning as Pydantic model:\n            ```python\n            users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_on=User.tier_id == Tier.id,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10,\n                is_active=True,\n                return_as_model=True\n            )\n            ```\n        \"\"\"\n        if limit &lt; 0 or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        if join_on is None:\n            join_on = _auto_detect_join_condition(self.model, join_model)\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        join_select = []\n\n        if join_schema_to_select:\n            columns = _extract_matching_columns_from_schema(\n                model=join_model, schema=join_schema_to_select\n            )\n        else:\n            columns = inspect(join_model).c\n\n        for column in columns:\n            labeled_column = _add_column_with_prefix(column, join_prefix)\n            if f\"{join_prefix}{column.name}\" not in [\n                col.name for col in primary_select\n            ]:\n                join_select.append(labeled_column)\n\n        if join_type == \"left\":\n            stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n        elif join_type == \"inner\":\n            stmt = select(*primary_select, *join_select).join(join_model, join_on)\n        else:\n            raise ValueError(\n                f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n            )\n\n        filters = self._parse_filters(**kwargs)\n        if filters:\n            stmt = stmt.filter(*filters)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n        stmt = stmt.offset(offset).limit(limit)\n\n        result = await db.execute(stmt)\n        data = result.mappings().all()\n\n        if return_as_model and schema_to_select:\n            data = [schema_to_select.model_construct(**row) for row in data]\n\n        total_count = await self.count(db=db, **kwargs)\n        return {\"data\": data, \"total_count\": total_count}\n\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n        It supports advanced filtering with comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The SQLAlchemy async session.\n            cursor: The cursor value to start fetching records from. Defaults to None.\n            limit: Maximum number of rows to fetch.\n            schema_to_select: Pydantic schema for selecting specific columns.\n            sort_column: Column name to use for sorting and cursor pagination.\n            sort_order: Sorting direction, either 'asc' or 'desc'.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.\n\n        Examples:\n            Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)\n            ```python\n            first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\n            Fetch the next set of records using the cursor from the first page\n            next_cursor = first_page['next_cursor']\n            second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n            ```\n\n            Fetch records with age greater than 30 using cursor-based pagination:\n            ```python\n            get_multi_by_cursor(db, limit=10, sort_column='age', sort_order='asc', age__gt=30)\n            ```\n\n            Fetch records excluding a specific username using cursor-based pagination:\n            ```python\n            get_multi_by_cursor(db, limit=10, sort_column='username', sort_order='asc', username__ne='admin')\n            ```\n\n        Note:\n            This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n            Make sure the column used for cursor pagination is indexed for performance.\n            This method assumes that your records can be ordered by a unique, sequential field (like `id` or `created_at`).\n        \"\"\"\n        if limit == 0:\n            return {\"data\": [], \"next_cursor\": None}\n\n        to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n        filters = self._parse_filters(**kwargs)\n\n        stmt = select(*to_select)\n        if filters:\n            stmt = stmt.filter(*filters)\n\n        if cursor:\n            if sort_order == \"asc\":\n                stmt = stmt.filter(getattr(self.model, sort_column) &gt; cursor)\n            else:\n                stmt = stmt.filter(getattr(self.model, sort_column) &lt; cursor)\n\n        stmt = stmt.order_by(\n            asc(getattr(self.model, sort_column))\n            if sort_order == \"asc\"\n            else desc(getattr(self.model, sort_column))\n        )\n        stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        next_cursor = None\n        if len(data) == limit:\n            if sort_order == \"asc\":\n                next_cursor = data[-1][sort_column]\n            else:\n                data[0][sort_column]\n\n        return {\"data\": data, \"next_cursor\": next_cursor}\n\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        allow_multiple: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n        It supports advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            object: A Pydantic schema or dictionary containing the update data.\n            allow_multiple: If True, allows updating multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n            **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n        Returns:\n            None\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n            ValueError: If extra fields not present in the model are provided in the update data.\n\n        Examples:\n            Update a user's email based on their ID:\n            ```python\n            update(db, {'email': 'new_email@example.com'}, id=1)\n            ```\n\n            Update users' statuses to 'inactive' where age is greater than 30 and allow updates to multiple records:\n            ```python\n            update(db, {'status': 'inactive'}, allow_multiple=True, age__gt=30)\n            ```\n\n            Update a user's username excluding specific user ID and prevent multiple updates:\n            ```python\n            update(db, {'username': 'new_username'}, id__ne=1, allow_multiple=False)\n            ```\n        \"\"\"\n        total_count = await self.count(db, **kwargs)\n        if not allow_multiple and total_count &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to update, found {total_count}.\"\n            )\n\n        if isinstance(object, dict):\n            update_data = object\n        else:\n            update_data = object.model_dump(exclude_unset=True)\n\n        updated_at_col = getattr(self.model, self.updated_at_column, None)\n        if updated_at_col and updated_at_col in update_data.keys():\n            update_data[updated_at_col] = datetime.now(timezone.utc)\n\n        model_columns = {column.name for column in inspect(self.model).c}\n        extra_fields = set(update_data) - model_columns\n        if extra_fields:\n            raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n        filters = self._parse_filters(**kwargs)\n        stmt = update(self.model).filter(*filters).values(update_data)\n\n        await db.execute(stmt)\n        await db.commit()\n\n    async def db_delete(\n        self, db: AsyncSession, allow_multiple: bool = False, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Deletes a record or multiple records from the database based on specified filters, with support for advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n            **kwargs: Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n        Returns:\n            None\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n\n        Examples:\n            Delete a user based on their ID:\n            ```python\n            db_delete(db, id=1)\n            ```\n\n            Delete users older than 30 years and allow deletion of multiple records:\n            ```python\n            db_delete(db, allow_multiple=True, age__gt=30)\n            ```\n\n            Delete a user with a specific username, ensuring only one record is deleted:\n            ```python\n            db_delete(db, username='unique_username', allow_multiple=False)\n            ```\n        \"\"\"\n        total_count = await self.count(db, **kwargs)\n        if not allow_multiple and total_count &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        filters = self._parse_filters(**kwargs)\n        stmt = delete(self.model).filter(*filters)\n        await db.execute(stmt)\n        await db.commit()\n\n    async def delete(\n        self,\n        db: AsyncSession,\n        db_row: Optional[Row] = None,\n        allow_multiple: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Soft deletes a record or optionally multiple records if it has an \"is_deleted\" attribute, otherwise performs a hard delete, based on specified filters.\n        Supports advanced filtering through comparison operators:\n            '__gt' (greater than),\n            '__lt' (less than),\n            '__gte' (greater than or equal to),\n            '__lte' (less than or equal to), and\n            '__ne' (not equal).\n\n        Args:\n            db: The database session to use for the operation.\n            db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n            allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n            **kwargs: Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n            NoResultFound: If no record matches the filters.\n\n        Returns:\n            None\n\n        Examples:\n            Soft delete a specific user by ID:\n            ```python\n            delete(db, id=1)\n            ```\n\n            Hard delete users with account creation dates before 2020, allowing deletion of multiple records:\n            ```python\n            delete(db, allow_multiple=True, creation_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Soft delete a user with a specific email, ensuring only one record is deleted:\n            ```python\n            delete(db, email='unique@example.com', allow_multiple=False)\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        if db_row:\n            if hasattr(db_row, self.is_deleted_column):\n                is_deleted_col = getattr(self.model, self.is_deleted_column)\n                deleted_at_col = getattr(self.model, self.deleted_at_column, None)\n\n                update_values = {\n                    is_deleted_col: True,\n                    deleted_at_col: datetime.now(timezone.utc),\n                }\n                update_stmt = (\n                    update(self.model).filter(*filters).values(**update_values)\n                )\n                await db.execute(update_stmt)\n            else:\n                await db.delete(db_row)\n                await db.commit()\n\n        total_count = await self.count(db, **kwargs)\n        if total_count == 0:\n            raise NoResultFound(\"No record found to delete.\")\n        if not allow_multiple and total_count &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        if self.is_deleted_column in self.model.__table__.columns:\n            update_stmt = (\n                update(self.model)\n                .filter(*filters)\n                .values(is_deleted=True, deleted_at=datetime.now(timezone.utc))\n            )\n            await db.execute(update_stmt)\n        else:\n            delete_stmt = delete(self.model).filter(*filters)\n            await db.execute(delete_stmt)\n\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.count","title":"<code>count(db, **kwargs)</code>  <code>async</code>","text":"<p>Counts records that match specified filters, supporting advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The total number of records matching the filter conditions.</p> <p>Examples:</p> <p>Count users by ID: <pre><code>exists = await crud.count(db, id=1)\n</code></pre></p> <p>Count users older than 30: <pre><code>exists = await crud.count(db, age__gt=30)\n</code></pre></p> <p>Count users who registered before Jan 1, 2020: <pre><code>exists = await crud.count(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Count users with a username other than 'admin': <pre><code>exists = await crud.count(db, username__ne='admin')\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def count(self, db: AsyncSession, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Counts records that match specified filters, supporting advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n    Returns:\n        The total number of records matching the filter conditions.\n\n    Examples:\n        Count users by ID:\n        ```python\n        exists = await crud.count(db, id=1)\n        ```\n\n        Count users older than 30:\n        ```python\n        exists = await crud.count(db, age__gt=30)\n        ```\n\n        Count users who registered before Jan 1, 2020:\n        ```python\n        exists = await crud.count(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Count users with a username other than 'admin':\n        ```python\n        exists = await crud.count(db, username__ne='admin')\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    if filters:\n        count_query = select(func.count()).select_from(self.model).filter(*filters)\n    else:\n        count_query = select(func.count()).select_from(self.model)\n\n    total_count: int = await db.scalar(count_query)\n    return total_count\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.create","title":"<code>create(db, object)</code>  <code>async</code>","text":"<p>Create a new record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>object</code> <code>CreateSchemaType</code> <p>The Pydantic schema containing the data to be saved.</p> required <p>Returns:</p> Type Description <code>ModelType</code> <p>The created database object.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def create(self, db: AsyncSession, object: CreateSchemaType) -&gt; ModelType:\n    \"\"\"\n    Create a new record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        object: The Pydantic schema containing the data to be saved.\n\n    Returns:\n        The created database object.\n    \"\"\"\n    object_dict = object.model_dump()\n    db_object: ModelType = self.model(**object_dict)\n    db.add(db_object)\n    await db.commit()\n    return db_object\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.db_delete","title":"<code>db_delete(db, allow_multiple=False, **kwargs)</code>  <code>async</code>","text":"<p>Deletes a record or multiple records from the database based on specified filters, with support for advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>allow_multiple</code> <code>bool</code> <p>If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is False and more than one record matches the filters.</p> <p>Examples:</p> <p>Delete a user based on their ID: <pre><code>db_delete(db, id=1)\n</code></pre></p> <p>Delete users older than 30 years and allow deletion of multiple records: <pre><code>db_delete(db, allow_multiple=True, age__gt=30)\n</code></pre></p> <p>Delete a user with a specific username, ensuring only one record is deleted: <pre><code>db_delete(db, username='unique_username', allow_multiple=False)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def db_delete(\n    self, db: AsyncSession, allow_multiple: bool = False, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Deletes a record or multiple records from the database based on specified filters, with support for advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n        **kwargs: Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n    Returns:\n        None\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n\n    Examples:\n        Delete a user based on their ID:\n        ```python\n        db_delete(db, id=1)\n        ```\n\n        Delete users older than 30 years and allow deletion of multiple records:\n        ```python\n        db_delete(db, allow_multiple=True, age__gt=30)\n        ```\n\n        Delete a user with a specific username, ensuring only one record is deleted:\n        ```python\n        db_delete(db, username='unique_username', allow_multiple=False)\n        ```\n    \"\"\"\n    total_count = await self.count(db, **kwargs)\n    if not allow_multiple and total_count &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    filters = self._parse_filters(**kwargs)\n    stmt = delete(self.model).filter(*filters)\n    await db.execute(stmt)\n    await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.delete","title":"<code>delete(db, db_row=None, allow_multiple=False, **kwargs)</code>  <code>async</code>","text":"<p>Soft deletes a record or optionally multiple records if it has an \"is_deleted\" attribute, otherwise performs a hard delete, based on specified filters. Supports advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>db_row</code> <code>Optional[Row]</code> <p>Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.</p> <code>None</code> <code>allow_multiple</code> <code>bool</code> <p>If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is False and more than one record matches the filters.</p> <code>NoResultFound</code> <p>If no record matches the filters.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <p>Soft delete a specific user by ID: <pre><code>delete(db, id=1)\n</code></pre></p> <p>Hard delete users with account creation dates before 2020, allowing deletion of multiple records: <pre><code>delete(db, allow_multiple=True, creation_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Soft delete a user with a specific email, ensuring only one record is deleted: <pre><code>delete(db, email='unique@example.com', allow_multiple=False)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def delete(\n    self,\n    db: AsyncSession,\n    db_row: Optional[Row] = None,\n    allow_multiple: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Soft deletes a record or optionally multiple records if it has an \"is_deleted\" attribute, otherwise performs a hard delete, based on specified filters.\n    Supports advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n        allow_multiple: If True, allows deleting multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n        **kwargs: Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n        NoResultFound: If no record matches the filters.\n\n    Returns:\n        None\n\n    Examples:\n        Soft delete a specific user by ID:\n        ```python\n        delete(db, id=1)\n        ```\n\n        Hard delete users with account creation dates before 2020, allowing deletion of multiple records:\n        ```python\n        delete(db, allow_multiple=True, creation_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Soft delete a user with a specific email, ensuring only one record is deleted:\n        ```python\n        delete(db, email='unique@example.com', allow_multiple=False)\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    if db_row:\n        if hasattr(db_row, self.is_deleted_column):\n            is_deleted_col = getattr(self.model, self.is_deleted_column)\n            deleted_at_col = getattr(self.model, self.deleted_at_column, None)\n\n            update_values = {\n                is_deleted_col: True,\n                deleted_at_col: datetime.now(timezone.utc),\n            }\n            update_stmt = (\n                update(self.model).filter(*filters).values(**update_values)\n            )\n            await db.execute(update_stmt)\n        else:\n            await db.delete(db_row)\n            await db.commit()\n\n    total_count = await self.count(db, **kwargs)\n    if total_count == 0:\n        raise NoResultFound(\"No record found to delete.\")\n    if not allow_multiple and total_count &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    if self.is_deleted_column in self.model.__table__.columns:\n        update_stmt = (\n            update(self.model)\n            .filter(*filters)\n            .values(is_deleted=True, deleted_at=datetime.now(timezone.utc))\n        )\n        await db.execute(update_stmt)\n    else:\n        delete_stmt = delete(self.model).filter(*filters)\n        await db.execute(delete_stmt)\n\n    await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.exists","title":"<code>exists(db, **kwargs)</code>  <code>async</code>","text":"<p>Checks if any records exist that match the given filter conditions. This method supports advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one record matches the filter conditions, False otherwise.</p> <p>Examples:</p> <p>Fetch a user by ID exists: <pre><code>exists = await crud.exists(db, id=1)\n</code></pre></p> <p>Check if any user is older than 30: <pre><code>exists = await crud.exists(db, age__gt=30)\n</code></pre></p> <p>Check if any user registered before Jan 1, 2020: <pre><code>exists = await crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Check if a username other than 'admin' exists: <pre><code>exists = await crud.exists(db, username__ne='admin')\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n    \"\"\"\n    Checks if any records exist that match the given filter conditions.\n    This method supports advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n    Returns:\n        True if at least one record matches the filter conditions, False otherwise.\n\n    Examples:\n        Fetch a user by ID exists:\n        ```python\n        exists = await crud.exists(db, id=1)\n        ```\n\n        Check if any user is older than 30:\n        ```python\n        exists = await crud.exists(db, age__gt=30)\n        ```\n\n        Check if any user registered before Jan 1, 2020:\n        ```python\n        exists = await crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Check if a username other than 'admin' exists:\n        ```python\n        exists = await crud.exists(db, username__ne='admin')\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    stmt = select(self.model).filter(*filters).limit(1)\n\n    result = await db.execute(stmt)\n    return result.first() is not None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get","title":"<code>get(db, schema_to_select=None, return_as_model=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record based on specified filters. This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks. Supported operators include:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Optional Pydantic schema for selecting specific columns.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If return_as_model is True but schema_to_select is not provided.</p> <p>Returns:</p> Type Description <code>Optional[Union[dict, BaseModel]]</code> <p>A dictionary or a Pydantic model instance of the fetched database row, or None if no match is found.</p> <p>Examples:</p> <p>Fetch a user by ID: <pre><code>user = await crud.get(db, id=1)\n</code></pre></p> <p>Fetch a user with an age greater than 30: <pre><code>user = await crud.get(db, age__gt=30)\n</code></pre></p> <p>Fetch a user with a registration date before Jan 1, 2020: <pre><code>user = await crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Fetch a user not equal to a specific username: <pre><code>user = await crud.get(db, username__ne='admin')\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, BaseModel]]:\n    \"\"\"\n    Fetches a single record based on specified filters.\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n    Supported operators include:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        schema_to_select: Optional Pydantic schema for selecting specific columns.\n        **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n    Raises:\n        ValueError: If return_as_model is True but schema_to_select is not provided.\n\n    Returns:\n        A dictionary or a Pydantic model instance of the fetched database row, or None if no match is found.\n\n    Examples:\n        Fetch a user by ID:\n        ```python\n        user = await crud.get(db, id=1)\n        ```\n\n        Fetch a user with an age greater than 30:\n        ```python\n        user = await crud.get(db, age__gt=30)\n        ```\n\n        Fetch a user with a registration date before Jan 1, 2020:\n        ```python\n        user = await crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Fetch a user not equal to a specific username:\n        ```python\n        user = await crud.get(db, username__ne='admin')\n        ```\n    \"\"\"\n    to_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    filters = self._parse_filters(**kwargs)\n    stmt = select(*to_select).filter(*filters)\n\n    db_row = await db.execute(stmt)\n    result: Row = db_row.first()\n    if result is not None:\n        out: dict = dict(result._mapping)\n        if return_as_model:\n            if not schema_to_select:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            return schema_to_select(**out)\n        return out\n\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_joined","title":"<code>get_joined(db, join_model, join_prefix=None, join_on=None, schema_to_select=None, join_schema_to_select=None, join_type='left', **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record with a join on another model. If 'join_on' is not provided, the method attempts to automatically detect the join condition using foreign key relationships. Advanced filters supported:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>join_model</code> <code>type[ModelType]</code> <p>The model to join with.</p> required <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If None, no prefix is added.</p> <code>None</code> <code>join_on</code> <code>Optional[Union[Join, None]]</code> <p>SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.</p> <code>'left'</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>A dictionary representing the joined record, or None if no record matches the criteria.</p> <p>Examples:</p> <p>Simple example: Joining User and Tier models without explicitly providing join_on <pre><code>result = await crud_user.get_joined(\n    db=session,\n    join_model=Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema\n)\n</code></pre></p> <p>Fetch a user and their associated tier, filtering by user ID: <pre><code>get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, id=1)\n</code></pre></p> <p>Fetch a user and their associated tier, where the user's age is greater than 30: <pre><code>get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, age__gt=30)\n</code></pre></p> <p>Fetch a user and their associated tier, excluding users with the 'admin' username: <pre><code>get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, username__ne='admin')\n</code></pre></p> <p>Complex example: Joining with a custom join condition, additional filter parameters, and a prefix <pre><code>from sqlalchemy import and_\nresult = await crud_user.get_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    username=\"john_doe\"\n)\n</code></pre></p> <p>Return example: prefix added, no schema_to_select or join_schema_to_select <pre><code>{\n    \"id\": 1,\n    \"name\": \"John Doe\",\n    \"username\": \"john_doe\",\n    \"email\": \"johndoe@example.com\",\n    \"hashed_password\": \"hashed_password_example\",\n    \"profile_image_url\": \"https://profileimageurl.com/default.jpg\",\n    \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"created_at\": \"2023-01-01T12:00:00\",\n    \"updated_at\": \"2023-01-02T12:00:00\",\n    \"deleted_at\": null,\n    \"is_deleted\": false,\n    \"is_superuser\": false,\n    \"tier_id\": 2,\n    \"tier_name\": \"Premium\",\n    \"tier_created_at\": \"2022-12-01T10:00:00\",\n    \"tier_updated_at\": \"2023-01-01T11:00:00\"\n}\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_joined(\n    self,\n    db: AsyncSession,\n    join_model: type[ModelType],\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Union[Join, None]] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"\n    Fetches a single record with a join on another model. If 'join_on' is not provided, the method attempts\n    to automatically detect the join condition using foreign key relationships. Advanced filters supported:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The SQLAlchemy async session.\n        join_model: The model to join with.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n        join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is\n            auto-detected based on foreign keys.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n        **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary representing the joined record, or None if no record matches the criteria.\n\n    Examples:\n        Simple example: Joining User and Tier models without explicitly providing join_on\n        ```python\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema\n        )\n        ```\n\n        Fetch a user and their associated tier, filtering by user ID:\n        ```python\n        get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, id=1)\n        ```\n\n        Fetch a user and their associated tier, where the user's age is greater than 30:\n        ```python\n        get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, age__gt=30)\n        ```\n\n        Fetch a user and their associated tier, excluding users with the 'admin' username:\n        ```python\n        get_joined(db, User, Tier, schema_to_select=UserSchema, join_schema_to_select=TierSchema, username__ne='admin')\n        ```\n\n        Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n        ```python\n        from sqlalchemy import and_\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            username=\"john_doe\"\n        )\n        ```\n\n        Return example: prefix added, no schema_to_select or join_schema_to_select\n        ```python\n        {\n            \"id\": 1,\n            \"name\": \"John Doe\",\n            \"username\": \"john_doe\",\n            \"email\": \"johndoe@example.com\",\n            \"hashed_password\": \"hashed_password_example\",\n            \"profile_image_url\": \"https://profileimageurl.com/default.jpg\",\n            \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n            \"created_at\": \"2023-01-01T12:00:00\",\n            \"updated_at\": \"2023-01-02T12:00:00\",\n            \"deleted_at\": null,\n            \"is_deleted\": false,\n            \"is_superuser\": false,\n            \"tier_id\": 2,\n            \"tier_name\": \"Premium\",\n            \"tier_created_at\": \"2022-12-01T10:00:00\",\n            \"tier_updated_at\": \"2023-01-01T11:00:00\"\n        }\n        ```\n    \"\"\"\n    if join_on is None:\n        join_on = _auto_detect_join_condition(self.model, join_model)\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    join_select = []\n\n    if join_schema_to_select:\n        columns = _extract_matching_columns_from_schema(\n            model=join_model, schema=join_schema_to_select\n        )\n    else:\n        columns = inspect(join_model).c\n\n    for column in columns:\n        labeled_column = _add_column_with_prefix(column, join_prefix)\n        if f\"{join_prefix}{column.name}\" not in [\n            col.name for col in primary_select\n        ]:\n            join_select.append(labeled_column)\n\n    if join_type == \"left\":\n        stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n    elif join_type == \"inner\":\n        stmt = select(*primary_select, *join_select).join(join_model, join_on)\n    else:\n        raise ValueError(\n            f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n        )\n\n    filters = self._parse_filters(**kwargs)\n    if filters:\n        stmt = stmt.filter(*filters)\n\n    db_row = await db.execute(stmt)\n    result: Row = db_row.first()\n    if result:\n        out: dict = dict(result._mapping)\n        return out\n\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi","title":"<code>get_multi(db, offset=0, limit=100, schema_to_select=None, sort_columns=None, sort_orders=None, return_as_model=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetches multiple records based on filters, supporting sorting, pagination, and advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>offset</code> <code>int</code> <p>Starting index for records to fetch, useful for pagination.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of records to fetch in one call.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Optional Pydantic schema for selecting specific columns. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>Column names to sort the results by.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>Corresponding sort orders ('asc', 'desc') for each column in sort_columns.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, returns data as instances of the specified Pydantic model.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for more detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing 'data' with fetched records and 'total_count' indicating the total number of records matching the filters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit or offset is negative, or if schema_to_select is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetch the first 10 users: <pre><code>users = await crud.get_multi(db, 0, 10)\n</code></pre></p> <p>Fetch next 10 users with sorted by username: <pre><code>users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n</code></pre></p> <p>Fetch 10 users older than 30, sorted by age in descending order: <pre><code>get_multi(db, offset=0, limit=10, age__gt=30, sort_columns='age', sort_orders='desc')\n</code></pre></p> <p>Fetch 10 users with a registration date before Jan 1, 2020: <pre><code>get_multi(db, offset=0, limit=10, registration_date__lt=datetime(2020, 1, 1))\n</code></pre></p> <p>Fetch 10 users with a username other than 'admin', returning as model instances (ensure appropriate schema is passed): <pre><code>get_multi(db, offset=0, limit=10, username__ne='admin', schema_to_select=UserSchema, return_as_model=True)\n</code></pre></p> <p>Fetch users with filtering and multiple column sorting: <pre><code>users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi(\n    self,\n    db: AsyncSession,\n    offset: int = 0,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetches multiple records based on filters, supporting sorting, pagination, and advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        offset: Starting index for records to fetch, useful for pagination.\n        limit: Maximum number of records to fetch in one call.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n        sort_columns: Column names to sort the results by.\n        sort_orders: Corresponding sort orders ('asc', 'desc') for each column in sort_columns.\n        return_as_model: If True, returns data as instances of the specified Pydantic model.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n    Returns:\n        A dictionary containing 'data' with fetched records and 'total_count' indicating the total number of records matching the filters.\n\n    Raises:\n        ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n    Examples:\n        Fetch the first 10 users:\n        ```python\n        users = await crud.get_multi(db, 0, 10)\n        ```\n\n        Fetch next 10 users with sorted by username:\n        ```python\n        users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n        ```\n\n        Fetch 10 users older than 30, sorted by age in descending order:\n        ```python\n        get_multi(db, offset=0, limit=10, age__gt=30, sort_columns='age', sort_orders='desc')\n        ```\n\n        Fetch 10 users with a registration date before Jan 1, 2020:\n        ```python\n        get_multi(db, offset=0, limit=10, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Fetch 10 users with a username other than 'admin', returning as model instances (ensure appropriate schema is passed):\n        ```python\n        get_multi(db, offset=0, limit=10, username__ne='admin', schema_to_select=UserSchema, return_as_model=True)\n        ```\n\n        Fetch users with filtering and multiple column sorting:\n        ```python\n        users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n        ```\n    \"\"\"\n    if limit &lt; 0 or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n    filters = self._parse_filters(**kwargs)\n    stmt = select(*to_select).filter(*filters)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n    stmt = stmt.offset(offset).limit(limit)\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    if return_as_model:\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        try:\n            data = [schema_to_select.model_construct(**row) for row in data]\n        except ValidationError as e:\n            raise ValueError(\n                f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n            )\n\n    total_count = await self.count(db=db, **kwargs)\n    return {\"data\": data, \"total_count\": total_count}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor","title":"<code>get_multi_by_cursor(db, cursor=None, limit=100, schema_to_select=None, sort_column='id', sort_order='asc', **kwargs)</code>  <code>async</code>","text":"<p>Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling. It supports advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>cursor</code> <code>Any</code> <p>The cursor value to start fetching records from. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of rows to fetch.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns.</p> <code>None</code> <code>sort_column</code> <code>str</code> <p>Column name to use for sorting and cursor pagination.</p> <code>'id'</code> <code>sort_order</code> <code>str</code> <p>Sorting direction, either 'asc' or 'desc'.</p> <code>'asc'</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.</p> <p>Examples:</p> <p>Fetch the first set of records (e.g., the first page in an infinite scrolling scenario) <pre><code>first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\nFetch the next set of records using the cursor from the first page\nnext_cursor = first_page['next_cursor']\nsecond_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n</code></pre></p> <p>Fetch records with age greater than 30 using cursor-based pagination: <pre><code>get_multi_by_cursor(db, limit=10, sort_column='age', sort_order='asc', age__gt=30)\n</code></pre></p> <p>Fetch records excluding a specific username using cursor-based pagination: <pre><code>get_multi_by_cursor(db, limit=10, sort_column='username', sort_order='asc', username__ne='admin')\n</code></pre></p> Note <p>This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features. Make sure the column used for cursor pagination is indexed for performance. This method assumes that your records can be ordered by a unique, sequential field (like <code>id</code> or <code>created_at</code>).</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_by_cursor(\n    self,\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n    It supports advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The SQLAlchemy async session.\n        cursor: The cursor value to start fetching records from. Defaults to None.\n        limit: Maximum number of rows to fetch.\n        schema_to_select: Pydantic schema for selecting specific columns.\n        sort_column: Column name to use for sorting and cursor pagination.\n        sort_order: Sorting direction, either 'asc' or 'desc'.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.\n\n    Examples:\n        Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)\n        ```python\n        first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\n        Fetch the next set of records using the cursor from the first page\n        next_cursor = first_page['next_cursor']\n        second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n        ```\n\n        Fetch records with age greater than 30 using cursor-based pagination:\n        ```python\n        get_multi_by_cursor(db, limit=10, sort_column='age', sort_order='asc', age__gt=30)\n        ```\n\n        Fetch records excluding a specific username using cursor-based pagination:\n        ```python\n        get_multi_by_cursor(db, limit=10, sort_column='username', sort_order='asc', username__ne='admin')\n        ```\n\n    Note:\n        This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n        Make sure the column used for cursor pagination is indexed for performance.\n        This method assumes that your records can be ordered by a unique, sequential field (like `id` or `created_at`).\n    \"\"\"\n    if limit == 0:\n        return {\"data\": [], \"next_cursor\": None}\n\n    to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n    filters = self._parse_filters(**kwargs)\n\n    stmt = select(*to_select)\n    if filters:\n        stmt = stmt.filter(*filters)\n\n    if cursor:\n        if sort_order == \"asc\":\n            stmt = stmt.filter(getattr(self.model, sort_column) &gt; cursor)\n        else:\n            stmt = stmt.filter(getattr(self.model, sort_column) &lt; cursor)\n\n    stmt = stmt.order_by(\n        asc(getattr(self.model, sort_column))\n        if sort_order == \"asc\"\n        else desc(getattr(self.model, sort_column))\n    )\n    stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    next_cursor = None\n    if len(data) == limit:\n        if sort_order == \"asc\":\n            next_cursor = data[-1][sort_column]\n        else:\n            data[0][sort_column]\n\n    return {\"data\": data, \"next_cursor\": next_cursor}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_joined","title":"<code>get_multi_joined(db, join_model, join_prefix=None, join_on=None, schema_to_select=None, join_schema_to_select=None, join_type='left', offset=0, limit=100, sort_columns=None, sort_orders=None, return_as_model=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion, supporting advanced filtering with comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>join_model</code> <code>type[ModelType]</code> <p>The model to join with.</p> required <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If None, no prefix is added.</p> <code>None</code> <code>join_on</code> <code>Optional[Join]</code> <p>SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.</p> <code>'left'</code> <code>offset</code> <code>int</code> <p>The offset (number of records to skip) for pagination.</p> <code>0</code> <code>limit</code> <code>int</code> <p>The limit (maximum number of records to return) for pagination.</p> <code>100</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or a list of column names on which to apply sorting.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary query, including advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit or offset is negative, or if schema_to_select is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetching multiple User records joined with Tier records, using left join, returning raw data: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    offset=0,\n    limit=10\n)\n</code></pre></p> <p>Fetch users joined with their tiers, sorted by username, where user's age is greater than 30: <pre><code>users = get_multi_joined(\n    db,\n    User,\n    Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    age__gt=30,\n    sort_columns='username',\n    sort_orders='asc'\n)\n</code></pre></p> <p>Fetch users joined with their tiers, excluding users with 'admin' username, returning as model instances: <pre><code>users = get_multi_joined(\n    db,\n    User,\n    Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    username__ne='admin',\n    return_as_model=True\n)\n</code></pre></p> <p>Fetching and sorting by username in descending order, returning as Pydantic model: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    offset=0,\n    limit=10,\n    sort_columns=['username'],\n    sort_orders=['desc'],\n    return_as_model=True\n)\n</code></pre></p> <p>Fetching with complex conditions and custom join, returning as Pydantic model: <pre><code>users = await crud_user.get_multi_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_on=User.tier_id == Tier.id,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    offset=0,\n    limit=10,\n    is_active=True,\n    return_as_model=True\n)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_joined(\n    self,\n    db: AsyncSession,\n    join_model: type[ModelType],\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Join] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    offset: int = 0,\n    limit: int = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion,\n    supporting advanced filtering with comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The SQLAlchemy async session.\n        join_model: The model to join with.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n        join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n        offset: The offset (number of records to skip) for pagination.\n        limit: The limit (maximum number of records to return) for pagination.\n        sort_columns: A single column name or a list of column names on which to apply sorting.\n        sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n        return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n        **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n    Raises:\n        ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n    Examples:\n        Fetching multiple User records joined with Tier records, using left join, returning raw data:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            offset=0,\n            limit=10\n        )\n        ```\n\n        Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n        ```python\n        users = get_multi_joined(\n            db,\n            User,\n            Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            age__gt=30,\n            sort_columns='username',\n            sort_orders='asc'\n        )\n        ```\n\n        Fetch users joined with their tiers, excluding users with 'admin' username, returning as model instances:\n        ```python\n        users = get_multi_joined(\n            db,\n            User,\n            Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            username__ne='admin',\n            return_as_model=True\n        )\n        ```\n\n        Fetching and sorting by username in descending order, returning as Pydantic model:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            offset=0,\n            limit=10,\n            sort_columns=['username'],\n            sort_orders=['desc'],\n            return_as_model=True\n        )\n        ```\n\n        Fetching with complex conditions and custom join, returning as Pydantic model:\n        ```python\n        users = await crud_user.get_multi_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_on=User.tier_id == Tier.id,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            offset=0,\n            limit=10,\n            is_active=True,\n            return_as_model=True\n        )\n        ```\n    \"\"\"\n    if limit &lt; 0 or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    if join_on is None:\n        join_on = _auto_detect_join_condition(self.model, join_model)\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    join_select = []\n\n    if join_schema_to_select:\n        columns = _extract_matching_columns_from_schema(\n            model=join_model, schema=join_schema_to_select\n        )\n    else:\n        columns = inspect(join_model).c\n\n    for column in columns:\n        labeled_column = _add_column_with_prefix(column, join_prefix)\n        if f\"{join_prefix}{column.name}\" not in [\n            col.name for col in primary_select\n        ]:\n            join_select.append(labeled_column)\n\n    if join_type == \"left\":\n        stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n    elif join_type == \"inner\":\n        stmt = select(*primary_select, *join_select).join(join_model, join_on)\n    else:\n        raise ValueError(\n            f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n        )\n\n    filters = self._parse_filters(**kwargs)\n    if filters:\n        stmt = stmt.filter(*filters)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n    stmt = stmt.offset(offset).limit(limit)\n\n    result = await db.execute(stmt)\n    data = result.mappings().all()\n\n    if return_as_model and schema_to_select:\n        data = [schema_to_select.model_construct(**row) for row in data]\n\n    total_count = await self.count(db=db, **kwargs)\n    return {\"data\": data, \"total_count\": total_count}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.update","title":"<code>update(db, object, allow_multiple=False, **kwargs)</code>  <code>async</code>","text":"<p>Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update. It supports advanced filtering through comparison operators:     '__gt' (greater than),     '__lt' (less than),     '__gte' (greater than or equal to),     '__lte' (less than or equal to), and     '__ne' (not equal).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>object</code> <code>Union[UpdateSchemaType, dict[str, Any]]</code> <p>A Pydantic schema or dictionary containing the update data.</p> required <code>allow_multiple</code> <code>bool</code> <p>If True, allows updating multiple records that match the filters. If False, raises an error if more than one record matches the filters.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is False and more than one record matches the filters.</p> <code>ValueError</code> <p>If extra fields not present in the model are provided in the update data.</p> <p>Examples:</p> <p>Update a user's email based on their ID: <pre><code>update(db, {'email': 'new_email@example.com'}, id=1)\n</code></pre></p> <p>Update users' statuses to 'inactive' where age is greater than 30 and allow updates to multiple records: <pre><code>update(db, {'status': 'inactive'}, allow_multiple=True, age__gt=30)\n</code></pre></p> <p>Update a user's username excluding specific user ID and prevent multiple updates: <pre><code>update(db, {'username': 'new_username'}, id__ne=1, allow_multiple=False)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def update(\n    self,\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    allow_multiple: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n    It supports advanced filtering through comparison operators:\n        '__gt' (greater than),\n        '__lt' (less than),\n        '__gte' (greater than or equal to),\n        '__lte' (less than or equal to), and\n        '__ne' (not equal).\n\n    Args:\n        db: The database session to use for the operation.\n        object: A Pydantic schema or dictionary containing the update data.\n        allow_multiple: If True, allows updating multiple records that match the filters. If False, raises an error if more than one record matches the filters.\n        **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n    Returns:\n        None\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is False and more than one record matches the filters.\n        ValueError: If extra fields not present in the model are provided in the update data.\n\n    Examples:\n        Update a user's email based on their ID:\n        ```python\n        update(db, {'email': 'new_email@example.com'}, id=1)\n        ```\n\n        Update users' statuses to 'inactive' where age is greater than 30 and allow updates to multiple records:\n        ```python\n        update(db, {'status': 'inactive'}, allow_multiple=True, age__gt=30)\n        ```\n\n        Update a user's username excluding specific user ID and prevent multiple updates:\n        ```python\n        update(db, {'username': 'new_username'}, id__ne=1, allow_multiple=False)\n        ```\n    \"\"\"\n    total_count = await self.count(db, **kwargs)\n    if not allow_multiple and total_count &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to update, found {total_count}.\"\n        )\n\n    if isinstance(object, dict):\n        update_data = object\n    else:\n        update_data = object.model_dump(exclude_unset=True)\n\n    updated_at_col = getattr(self.model, self.updated_at_column, None)\n    if updated_at_col and updated_at_col in update_data.keys():\n        update_data[updated_at_col] = datetime.now(timezone.utc)\n\n    model_columns = {column.name for column in inspect(self.model).c}\n    extra_fields = set(update_data) - model_columns\n    if extra_fields:\n        raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n    filters = self._parse_filters(**kwargs)\n    stmt = update(self.model).filter(*filters).values(update_data)\n\n    await db.execute(stmt)\n    await db.commit()\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API Reference section of our documentation. This section provides detailed information about the various classes, functions, and modules that make up our application. Whether you are looking to extend the application, integrate with it, or simply explore its capabilities, this section will guide you through the intricacies of our codebase.</p>"},{"location":"api/overview/#key-components","title":"Key Components","text":"<p>Our application's API is comprised of several key components, each serving a specific purpose:</p> <ol> <li> <p>FastCRUD Class: This class is at the heart of our CRUD (Create, Read, Update, Delete) operations. It provides a convenient and efficient way to interact with our database models.</p> <ul> <li>FastCRUD Class Reference</li> </ul> </li> <li> <p>EndpointCreator Class: A utility class for creating and registering CRUD endpoints in a FastAPI application. It simplifies the addition of standard CRUD endpoints to your FastAPI router.</p> <ul> <li>EndpointCreator Class Reference</li> </ul> </li> <li> <p>crud_router Function: A function that creates and configures a FastAPI router with CRUD endpoints for a specific model. It's a quick way to add standard CRUD operations to your models.</p> <ul> <li>CRUD Router Function Reference</li> </ul> </li> <li> <p>paginated Module: A a utility module for offset pagination related functions.</p> <ul> <li>Pagination Module Reference</li> </ul> </li> </ol>"},{"location":"api/overview/#usage","title":"Usage","text":"<p>Each component is documented with its own dedicated page, where you can find detailed information about its methods, parameters, return types, and usage examples. These pages are designed to provide you with all the information you need to understand and work with our API effectively.</p>"},{"location":"api/overview/#contribution","title":"Contribution","text":"<p>If you wish to contribute to the development of our API, please refer to our Contributing Guidelines. We welcome contributions of all forms, from bug fixes to feature development.</p>"},{"location":"api/overview/#feedback","title":"Feedback","text":"<p>Your feedback is crucial in helping us improve this documentation. If you have any suggestions, corrections, or queries, please reach out to us.</p> <p>Navigate through each section for detailed documentation of our API components.</p>"},{"location":"api/paginated/","title":"Paginated Module Reference","text":"<p><code>paginated</code> is a utility module for offset pagination related functions.</p>"},{"location":"api/paginated/#function-definition","title":"Function Definition","text":""},{"location":"api/paginated/#fastcrud.paginated.compute_offset","title":"<code>compute_offset(page, items_per_page)</code>","text":"<p>Calculate the offset for pagination based on the given page number and items per page.</p> <p>The offset represents the starting point in a dataset for the items on a given page. For example, if each page displays 10 items and you want to display page 3, the offset will be 20, meaning the display should start with the 21st item.</p>"},{"location":"api/paginated/#fastcrud.paginated.compute_offset--parameters","title":"Parameters","text":"<p>page : int     The current page number. Page numbers should start from 1. items_per_page : int     The number of items to be displayed on each page.</p>"},{"location":"api/paginated/#fastcrud.paginated.compute_offset--returns","title":"Returns","text":"<p>int     The calculated offset.</p>"},{"location":"api/paginated/#fastcrud.paginated.compute_offset--examples","title":"Examples","text":"<p>offset(1, 10) 0 offset(3, 10) 20</p> Source code in <code>fastcrud/paginated/helper.py</code> <pre><code>def compute_offset(page: int, items_per_page: int) -&gt; int:\n    \"\"\"Calculate the offset for pagination based on the given page number and items per page.\n\n    The offset represents the starting point in a dataset for the items on a given page.\n    For example, if each page displays 10 items and you want to display page 3, the offset will be 20,\n    meaning the display should start with the 21st item.\n\n    Parameters\n    ----------\n    page : int\n        The current page number. Page numbers should start from 1.\n    items_per_page : int\n        The number of items to be displayed on each page.\n\n    Returns\n    -------\n    int\n        The calculated offset.\n\n    Examples\n    --------\n    &gt;&gt;&gt; offset(1, 10)\n    0\n    &gt;&gt;&gt; offset(3, 10)\n    20\n    \"\"\"\n    return (page - 1) * items_per_page\n</code></pre>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response","title":"<code>paginated_response(crud_data, page, items_per_page)</code>","text":"<p>Create a paginated response based on the provided data and pagination parameters.</p>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response--parameters","title":"Parameters","text":"<p>crud_data : ListResponse[SchemaType]     Data to be paginated, including the list of items and total count. page : int     Current page number. items_per_page : int     Number of items per page.</p>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response--returns","title":"Returns","text":"<p>dict[str, Any]     A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.</p>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response--note","title":"Note","text":"<p>The function does not actually paginate the data but formats the response to indicate pagination metadata.</p> Source code in <code>fastcrud/paginated/response.py</code> <pre><code>def paginated_response(\n    crud_data: dict, page: int, items_per_page: int\n) -&gt; dict[str, Any]:\n    \"\"\"Create a paginated response based on the provided data and pagination parameters.\n\n    Parameters\n    ----------\n    crud_data : ListResponse[SchemaType]\n        Data to be paginated, including the list of items and total count.\n    page : int\n        Current page number.\n    items_per_page : int\n        Number of items per page.\n\n    Returns\n    -------\n    dict[str, Any]\n        A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.\n\n    Note\n    ----\n    The function does not actually paginate the data but formats the response to indicate pagination metadata.\n    \"\"\"\n    return {\n        \"data\": crud_data[\"data\"],\n        \"total_count\": crud_data[\"total_count\"],\n        \"has_more\": (page * items_per_page) &lt; crud_data[\"total_count\"],\n        \"page\": page,\n        \"items_per_page\": items_per_page,\n    }\n</code></pre>"},{"location":"community/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at igor.magalhaes.r@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/CONTRIBUTING/","title":"Contributing to FastAPI-boilerplate","text":"<p>Thank you for your interest in contributing to FastAPI-boilerplate! This guide is meant to make it easy for you to get started. Contributions are appreciated, even if just reporting bugs, documenting stuff or answering questions. To contribute with a feature:</p>"},{"location":"community/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":""},{"location":"community/CONTRIBUTING/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Start by forking and cloning the FastAPI-boilerplate repository:</p> <ol> <li>Fork the Repository: Begin by forking the project repository. You can do this by visiting https://github.com/igormagalhaesr/FastAPI-boilerplate and clicking the \"Fork\" button.</li> <li>Create a Feature Branch: Once you've forked the repo, create a branch for your feature by running <code>git checkout -b feature/fooBar</code>.</li> <li>Testing Changes: Ensure that your changes do not break existing functionality by running tests. In the root folder, execute poetry run <code>python -m pytest</code> to run the tests.</li> </ol>"},{"location":"community/CONTRIBUTING/#using-poetry-for-dependency-management","title":"Using Poetry for Dependency Management","text":"<p>FastAPI-boilerplate uses Poetry for managing dependencies. If you don't have Poetry installed, follow the instructions on the official Poetry website.</p> <p>Once Poetry is installed, navigate to the cloned repository and install the dependencies: <pre><code>cd FastAPI-boilerplate\npoetry install\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#activating-the-virtual-environment","title":"Activating the Virtual Environment","text":"<p>Poetry creates a virtual environment for your project. Activate it using:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"community/CONTRIBUTING/#making-contributions","title":"Making Contributions","text":""},{"location":"community/CONTRIBUTING/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 guidelines.</li> <li>Write meaningful tests for new features or bug fixes.</li> </ul>"},{"location":"community/CONTRIBUTING/#testing-with-pytest","title":"Testing with Pytest","text":"<p>FastAPI-boilerplate uses pytest for testing. Run tests using: <pre><code>poetry run pytest\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#linting","title":"Linting","text":"<p>Use mypy for type checking: <pre><code>mypy src\n</code></pre></p> <p>Use ruff for style: <pre><code>ruff check --fix\nruff format\n</code></pre></p> <p>Ensure your code passes linting before submitting.</p>"},{"location":"community/CONTRIBUTING/#using-pre-commit-for-better-code-quality","title":"Using pre-commit for Better Code Quality","text":"<p>It helps in identifying simple issues before submission to code review. By running automated checks, pre-commit can ensure code quality and consistency.</p> <ol> <li>Install Pre-commit:</li> <li>Installation: Install pre-commit in your development environment. Use the command <code>pip install pre-commit</code>.</li> <li>Setting Up Hooks: After installing pre-commit, set up the hooks with <code>pre-commit install</code>. This command will install hooks into your .git/ directory which will automatically check your commits for issues.</li> <li>Committing Your Changes:    After making your changes, use <code>git commit -am 'Add some fooBar'</code> to commit them. Pre-commit will run automatically on your files when you commit, ensuring that they meet the required standards.    Note: If pre-commit identifies issues, it may block your commit. Fix these issues and commit again. This ensures that all contributions are of high quality.</li> <li>Pushing Changes and Creating Pull Request:    Push your changes to the branch using <code>git push origin feature/fooBar</code>.    Visit your fork on GitHub and create a new Pull Request to the main repository.</li> </ol>"},{"location":"community/CONTRIBUTING/#additional-notes","title":"Additional Notes","text":"<p>Stay Updated: Keep your fork updated with the main repository to avoid merge conflicts. Regularly fetch and merge changes from the upstream repository. Adhere to Project Conventions: Follow the coding style, conventions, and commit message guidelines of the project. Open Communication: Feel free to ask questions or discuss your ideas by opening an issue or in discussions.</p>"},{"location":"community/CONTRIBUTING/#submitting-your-contributions","title":"Submitting Your Contributions","text":""},{"location":"community/CONTRIBUTING/#creating-a-pull-request","title":"Creating a Pull Request","text":"<p>After making your changes:</p> <ul> <li>Push your changes to your fork.</li> <li>Open a pull request with a clear description of your changes.</li> <li>Update the README.md if necessary.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-reviews","title":"Code Reviews","text":"<ul> <li>Address any feedback from code reviews.</li> <li>Once approved, your contributions will be merged into the main branch.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to our Code of Conduct to maintain a welcoming and inclusive environment.</p> <p>Thank you for contributing to FastAPI-boilerplate\ud83d\ude80</p>"},{"location":"community/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Igor Magalh\u00e3es</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"community/overview/","title":"Community Overview","text":"<p>Welcome to the project's community hub. Here, you'll find essential resources and guidelines that are crucial for contributing to and participating in the project. Please take the time to familiarize yourself with the following documents:</p>"},{"location":"community/overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"community/overview/#contributing","title":"Contributing","text":"<p>View the Contributing Guidelines</p> <p>Interested in contributing to the project? Great! The contributing guidelines will provide you with all the information you need to get started. This includes how to submit issues, propose changes, and the process for submitting pull requests.</p>"},{"location":"community/overview/#code-of-conduct","title":"Code of Conduct","text":"<p>View the Code of Conduct</p> <p>The Code of Conduct outlines the standards and behaviors expected of our community members. It's crucial to ensure a welcoming and inclusive environment for everyone. Please take the time to read and adhere to these guidelines.</p>"},{"location":"community/overview/#license","title":"License","text":"<p>View the License</p> <p>The license document outlines the terms under which our project can be used, modified, and distributed. Understanding the licensing is important for both users and contributors of the project.</p> <p>Thank you for being a part of our community and for contributing to our project's success!</p>"},{"location":"usage/crud/","title":"Using FastCRUD for Enhanced CRUD Operations","text":"<p>FastCRUD is a versatile tool for handling CRUD (Create, Read, Update, Delete) operations in FastAPI applications with SQLAlchemy models. It leverages Pydantic schemas for data validation and serialization, offering a streamlined approach to database interactions.</p>"},{"location":"usage/crud/#key-features","title":"Key Features","text":"<ul> <li>Simplified CRUD operations with SQLAlchemy models.</li> <li>Data validation and serialization using Pydantic.</li> <li>Support for complex queries including joins and pagination.</li> </ul>"},{"location":"usage/crud/#getting-started","title":"Getting Started","text":""},{"location":"usage/crud/#step-1-define-models-and-schemas","title":"Step 1: Define Models and Schemas","text":"<p>Define your SQLAlchemy models and Pydantic schemas for data representation.</p> <pre><code># SQLAlchemy models and Pydantic schema definitions\n</code></pre>"},{"location":"usage/crud/#step-2-initialize-fastcrud","title":"Step 2: Initialize FastCRUD","text":"<p>Create a FastCRUD instance for your model to handle CRUD operations.</p> <pre><code>from fastcrud import FastCRUD\n\n# Creating a FastCRUD instance\nmy_model_crud = FastCRUD(MyModel)\n</code></pre>"},{"location":"usage/crud/#step-3-pick-your-method","title":"Step 3: Pick your Method","text":"<p>Then you just pick the method you need and use it like this:</p> <pre><code># Creating a new record\nnew_record = await my_model_crud.create(db_session, create_schema_instance)\n</code></pre> <p>More on available methods below.</p>"},{"location":"usage/crud/#understanding-fastcrud-methods","title":"Understanding FastCRUD Methods","text":"<p>FastCRUD offers a comprehensive suite of methods for CRUD operations, each designed to handle different aspects of database interactions efficiently.</p>"},{"location":"usage/crud/#1-create","title":"1. Create","text":"<pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType\n) -&gt; ModelType\n</code></pre> <p>Purpose: To create a new record in the database. Usage Example: Creates an item with name 'New Item'.</p> <pre><code>new_item = await item_crud.create(db, ItemCreateSchema(name=\"New Item\"))\n</code></pre>"},{"location":"usage/crud/#2-get","title":"2. Get","text":"<pre><code>get(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any\n) -&gt; Optional[Union[dict, BaseModel]]\n</code></pre> <p>Purpose: To fetch a single record based on filters, with an option to select specific columns using a Pydantic schema. Usage Example: Fetches the item with item_id as its id.</p> <pre><code>item = await item_crud.get(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#3-exists","title":"3. Exists","text":"<pre><code>exists(\n    db: AsyncSession,\n    **kwargs: Any\n) -&gt; bool\n</code></pre> <p>Purpose: To check if a record exists based on provided filters. Usage Example: Checks whether an item with name 'Existing Item' exists.</p> <pre><code>exists = await item_crud.exists(db, name=\"Existing Item\")\n</code></pre>"},{"location":"usage/crud/#4-count","title":"4. Count","text":"<pre><code>count(\n    db: AsyncSession,\n    **kwargs: Any\n) -&gt; int\n</code></pre> <p>Purpose: To count the number of records matching provided filters. Usage Example: Counts the number of items with the 'Books' category.</p> <pre><code>count = await item_crud.count(db, category=\"Books\")\n</code></pre>"},{"location":"usage/crud/#5-get-multi","title":"5. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records with optional sorting, pagination, and model conversion. Usage Example: Fetches a subset of 5 items, starting from the 11th item in the database.</p> <pre><code>items = await item_crud.get_multi(db, offset=10, limit=5)\n</code></pre>"},{"location":"usage/crud/#6-update","title":"6. Update","text":"<pre><code>update(\n    db: AsyncSession, \n    object: Union[UpdateSchemaType, dict[str, Any]], \n    allow_multiple: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To update an existing record in the database. Usage Example: Updates the description of the item with item_id as its id.</p> <pre><code>await item_crud.update(db, ItemUpdateSchema(description=\"Updated\"), id=item_id)\n</code></pre>"},{"location":"usage/crud/#7-delete","title":"7. Delete","text":"<pre><code>delete(\n    db: AsyncSession, \n    db_row: Optional[Row] = None, \n    allow_multiple: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To delete a record from the database, with support for soft delete. Usage Example: Deletes the item with item_id as its id, performs a soft delete if the model has the 'is_deleted' column.</p> <pre><code>await item_crud.delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#8-hard-delete","title":"8. Hard Delete","text":"<pre><code>db_delete(\n    db: AsyncSession, \n    allow_multiple: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To hard delete a record from the database. Usage Example: Hard deletes the item with item_id as its id.</p> <pre><code>await item_crud.db_delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#advanced-methods-for-complex-queries-and-joins","title":"Advanced Methods for Complex Queries and Joins","text":"<p>FastCRUD extends its functionality with advanced methods tailored for complex query operations and handling joins. These methods cater to specific use cases where more sophisticated data retrieval and manipulation are required.</p>"},{"location":"usage/crud/#1-get-multi","title":"1. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records based on specified filters, with options for sorting and pagination. Usage Example: Gets the first 10 items sorted by 'name' in ascending order.</p> <pre><code>items = await item_crud.get_multi(db, offset=0, limit=10, sort_columns=['name'], sort_orders=['asc'])\n</code></pre>"},{"location":"usage/crud/#2-get-joined","title":"2. Get Joined","text":"<pre><code>get_joined(\n    db: AsyncSession, \n    join_model: type[ModelType], \n    join_prefix: Optional[str] = None, \n    join_on: Optional[Union[Join, None]] = None, \n    schema_to_select: Optional[type[BaseModel]] = None, \n    join_schema_to_select: Optional[type[BaseModel]] = None, \n    join_type: str = \"left\", \n    **kwargs: Any\n) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Purpose: To fetch a single record while performing a join operation with another model. Usage Example: Fetches order details for a specific order by joining with the Customer table, selecting specific columns as defined in OrderSchema and CustomerSchema.</p> <pre><code>order_details = await order_crud.get_joined(\n    db,\n    join_model=Customer,\n    schema_to_select=OrderSchema,\n    join_schema_to_select=CustomerSchema,\n    id=order_id\n)\n</code></pre>"},{"location":"usage/crud/#3-get-multi-joined","title":"3. Get Multi Joined","text":"<pre><code>get_multi_joined(\n    db: AsyncSession,\n    join_model: type[ModelType],\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Join] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    offset: int = 0,\n    limit: int = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Similar to <code>get_joined</code>, but for fetching multiple records. Usage Example: Retrieves a paginated list of orders (up to 5), joined with the Customer table, using specified schemas for selective column retrieval from both tables.</p> <pre><code>orders = await order_crud.get_multi_joined(\n    db,\n    join_model=Customer,\n    offset=0,\n    limit=5,\n    schema_to_select=OrderSchema,\n    join_schema_to_select=CustomerSchema\n)\n</code></pre>"},{"location":"usage/crud/#4-get-multi-by-cursor","title":"4. Get Multi By Cursor","text":"<pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Implements cursor-based pagination for efficient data retrieval in large datasets. Usage Example: Fetches the next 10 items after the last cursor for efficient pagination, sorted by creation date in descending order.</p> <pre><code>paginated_items = await item_crud.get_multi_by_cursor(\n    db,\n    cursor=last_cursor,\n    limit=10,\n    sort_column='created_at',\n    sort_order='desc'\n)\n</code></pre>"},{"location":"usage/crud/#error-handling","title":"Error Handling","text":"<p>FastCRUD provides mechanisms to handle common database errors, ensuring robust API behavior.</p>"},{"location":"usage/endpoint/","title":"Automatic Endpoint Creation with crud_router","text":"<p>This section of the documentation explains how to use the <code>crud_router</code> utility function from the FastCRUD package for automatic endpoint creation in a FastAPI application. The <code>crud_router</code> simplifies the process of creating standard CRUD (Create, Read, Update, Delete) endpoints for your models.</p>"},{"location":"usage/endpoint/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have FastAPI and FastCRUD installed in your environment. FastCRUD streamlines interactions with the database using SQLAlchemy models and Pydantic schemas.</p> <p>Warning</p> <pre><code>For now, your primary column in the database model must be named `id`.\n</code></pre>"},{"location":"usage/endpoint/#using-crud_router","title":"Using <code>crud_router</code>","text":""},{"location":"usage/endpoint/#step-1-define-your-model-and-schema","title":"Step 1: Define Your Model and Schema","text":"<p>First, define your SQLAlchemy model and corresponding Pydantic schemas for creating and updating data.</p> models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application, you can optionally set up a custom FastCRUD instance as well. This involves configuring the database connection.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n</code></pre>"},{"location":"usage/endpoint/#step-3-use-crud_router-to-create-endpoints","title":"Step 3: Use <code>crud_router</code> to Create Endpoints","text":"<pre><code># CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemCreateSchema,\n    update_schema=ItemUpdateSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"usage/endpoint/#available-endpoints","title":"Available Endpoints","text":"<p>For a comprehensive list of all available endpoints, read the advanced section.</p>"},{"location":"usage/endpoint/#usage-and-testing","title":"Usage and Testing","text":"<p>Once the application is running, you can test the automatically created endpoints using tools like Swagger UI, which FastAPI provides by default. The endpoints for creating, reading, updating, and deleting Item instances are now accessible at /items.</p>"},{"location":"usage/endpoint/#using-endpointcreator-directly","title":"Using <code>EndpointCreator</code> Directly","text":"<p>Using the <code>EndpointCreator</code> class in FastCRUD is a more flexible way to add CRUD endpoints to a FastAPI application.</p>"},{"location":"usage/endpoint/#step-1-define-your-model-and-schema_1","title":"Step 1: Define Your Model and Schema","text":"<p>Define your SQLAlchemy models and corresponding Pydantic schemas for data validation.</p> models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud_1","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application and FastCRUD instances. This involves configuring the database connection and creating a CRUD instance for your model.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n</code></pre>"},{"location":"usage/endpoint/#step-3-initialize-endpointcreator","title":"Step 3: Initialize <code>EndpointCreator</code>","text":"<p>Create an instance of EndpointCreator by passing the necessary parameters, including your model, session, CRUD instance, and schemas.</p> <pre><code>from fastcrud import EndpointCreator\n\n# Initialize EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=get_session,\n    model=YourModel,\n    create_schema=YourCreateSchema,\n    update_schema=YourUpdateSchema,\n    delete_schema=YourDeleteSchema,\n    path=\"/yourmodelpath\",\n    tags=[\"YourModelTag\"]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-4-add-custom-endpoints","title":"Step 4: Add Custom Endpoints","text":"<p>Add custom endpoints using EndpointCreator. You can inject dependencies as needed.</p> <pre><code># Example of adding custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[custom_dependency],\n    update_deps=[another_custom_dependency]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-5-include-the-router-in-your-application","title":"Step 5: Include the Router in Your Application","text":"<p>Finally, include the router from the EndpointCreator in your FastAPI application.</p> <pre><code>app.include_router(endpoint_creator.router)\n</code></pre>"},{"location":"usage/endpoint/#advanced-customization","title":"Advanced Customization","text":"<p>You can override the default methods in EndpointCreator for more control over the CRUD operations. You can also specify the operations you want to include. Read more in the advanced section.</p>"},{"location":"usage/endpoint/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can quickly set up CRUD endpoints for your models in a FastAPI application using crud_router or EndpointCreator. This utility function reduces boilerplate code and increases development efficiency by automating the creation of standard API endpoints.</p>"},{"location":"usage/overview/","title":"Usage Overview","text":"<p>The Usage section of our documentation provides comprehensive guides on how to effectively use key features of our application. This section is divided into various topics, each focusing on a specific aspect of usage, ensuring that you have all the information you need to leverage the full potential of our tools and functionalities.</p>"},{"location":"usage/overview/#key-topics","title":"Key Topics","text":""},{"location":"usage/overview/#1-automatic-endpoint-creation-with-crud_router","title":"1. Automatic Endpoint Creation with crud_router","text":"<p>This guide covers the use of <code>crud_router</code> for automatic endpoint creation in FastAPI applications. It provides a step-by-step approach to streamline the creation of standard CRUD endpoints.</p> <ul> <li>Automatic Endpoint Creation Guide</li> </ul>"},{"location":"usage/overview/#2-enhanced-crud-operations-with-fastcrud","title":"2. Enhanced CRUD Operations with FastCRUD","text":"<p>Learn how to use the <code>FastCRUD</code> class for enhanced CRUD operations. This guide delves into the functionalities offered by <code>FastCRUD</code>, including advanced query capabilities, pagination, and error handling.</p> <ul> <li>FastCRUD Usage Guide</li> </ul>"},{"location":"usage/overview/#getting-started","title":"Getting Started","text":"<p>To make the most out of these guides, we recommend familiarizing yourself with FastAPI and SQLAlchemy basics, as our application leverages these frameworks extensively.</p>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>If you have suggestions or contributions to these guides, please refer to our Contributing Guidelines. We appreciate your input in improving our documentation.</p>"}]}