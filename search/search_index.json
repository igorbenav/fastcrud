{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastCRUD","text":"<p> Powerful CRUD methods and automatic endpoint creation for FastAPI. </p> <p> </p> <p> FastCRUD is a Python package for FastAPI, offering robust async CRUD operations and flexible endpoint creation utilities, streamlined through advanced features like auto-detected join conditions, dynamic sorting, and offset and cursor pagination. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async: Leverages Python's async capabilities for non-blocking database operations.</li> <li>SQLAlchemy 2.0: Works with the latest SQLAlchemy version for robust database interactions.</li> <li>SQLModel Support: You can optionally use SQLModel 0.14 or newer instead of SQLAlchemy.</li> <li>Powerful CRUD Functionality: Full suite of efficient CRUD operations with support for joins.</li> <li>Dynamic Query Building: Supports building complex queries dynamically, including filtering, sorting, and pagination.</li> <li>Advanced Join Operations: Facilitates performing SQL joins with other models with automatic join condition detection.</li> <li>Built-in Offset Pagination: Comes with ready-to-use offset pagination.</li> <li>Cursor-based Pagination: Implements efficient pagination for large datasets, ideal for infinite scrolling interfaces.</li> <li>Modular and Extensible: Designed for easy extension and customization to fit your requirements.</li> <li>Auto-generated Endpoints: Streamlines the process of adding CRUD endpoints with custom dependencies and configurations.</li> </ul>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your model, schemas and database connection:</p> <pre><code># imports here\n\n# define your model\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n\n\n\n# your schemas\nclass ItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\n\n# database connection\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> <pre><code>from fastcrud import crud_router\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install fastcrud\n</code></pre> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>FastCRUD offers two primary ways to use its functionalities:</p> <ol> <li>By using <code>crud_router</code> for automatic endpoint creation.</li> <li>By integrating <code>FastCRUD</code> directly into your FastAPI endpoints for more control.</li> </ol> <p>Below are examples demonstrating both approaches:</p>"},{"location":"#using-crud_router-for-automatic-endpoint-creation","title":"Using <code>crud_router</code> for Automatic Endpoint Creation","text":"<p>Here's a quick example to get you started:</p>"},{"location":"#define-your-model-and-schemas","title":"Define Your Model and Schemas","text":"item/model.py<pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> item/schemas.py<pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n</code></pre>"},{"location":"#set-up-fastapi-and-fastcrud","title":"Set Up FastAPI and FastCRUD","text":"main.py<pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import crud_router\nfrom fastcrud import FastCRUD\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom .item.model import Base, Item\nfrom .item.schemas import CreateItemSchema, UpdateItemSchema\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\nitem_crud = FastCRUD(Item)\n\n# CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    crud=item_crud,\n    path=\"/items\",\n    tags=[\"Items\"],\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"#using-fastcrud-in-user-defined-fastapi-endpoints","title":"Using FastCRUD in User-Defined FastAPI Endpoints","text":"<p>For more control over your endpoints, you can use FastCRUD directly within your custom FastAPI route functions. Here's an example:</p> api/v1/items.py<pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastcrud import FastCRUD\n\nfrom .item.model import Item\nfrom .item.schemas import CreateItemSchema, UpdateItemSchema\n\n# Assume async_session is already set up as per the previous example\n\n# Instantiate FastCRUD with your model\nitem_crud = FastCRUD(Item)\n\n@app.post(\"/custom/items/\")\nasync def create_item(item_data: CreateItemSchema, db: AsyncSession = Depends(get_session)):\n    return await item_crud.create(db, item_data)\n\n@app.get(\"/custom/items/{item_id}\")\nasync def read_item(item_id: int, db: AsyncSession = Depends(get_session)):\n    item = await item_crud.get(db, id=item_id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n\n# You can add more routes for update and delete operations in a similar fashion\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>"},{"location":"changelog/","title":"FastCRUD Changelog","text":""},{"location":"changelog/#introduction","title":"Introduction","text":"<p>The Changelog documents all notable changes made to FastCRUD. This includes new features, bug fixes, and improvements. It's organized by version and date, providing a clear history of the library's development.</p>"},{"location":"changelog/#0157-mar-25-2025","title":"[0.15.7] - Mar 25, 2025","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Advanced filter configs by @doubledare704</li> <li>OR and NOT for filtering by @doubledare704</li> </ul>"},{"location":"changelog/#improved","title":"Improved","text":"<ul> <li>Remove redundant code by @suhanwu in #211</li> <li>Added pragma: no cover to relevant lines by @igorbenav in #212</li> </ul>"},{"location":"changelog/#whats-changed","title":"What's Changed","text":"<ul> <li>Implement advanced filter configs by @doubledare704 in #204</li> <li>Implement OR and NOT for filtering by @doubledare704 in #210</li> <li>Fix: Remove redundant code by @suhanwu in #211</li> <li>Added # pragma: no cover to relevant lines by @igorbenav in #212</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@suhanwu made their first contribution in #211</li> <li>@doubledare704 made their first contribution in #204</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.6...v0.15.7</p>"},{"location":"changelog/#0156-feb-19-2025","title":"[0.15.6] - Feb 19, 2025","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Models and Schemas, Batch 5: Projects and Participants by @slaarti in #195</li> <li>Security.md by @igorbenav in #200</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Cryptography Package Vulnerability updated to address OpenSSL vulnerability by @igorbenav in #202</li> </ul>"},{"location":"changelog/#documentation-updates","title":"Documentation Updates","text":"<ul> <li>Showcase by @igorbenav in #193</li> </ul>"},{"location":"changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Showcase by @igorbenav in #193</li> <li>Models and Schemas, Batch 5: Projects and Participants by @slaarti in #195</li> <li>Create SECURITY.md by @igorbenav in #200</li> <li>Bump cryptography to fix vulnerability by @igorbenav in #202</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.5...v0.15.6</p>"},{"location":"changelog/#0155-dec-25-2024","title":"[0.15.5] - Dec 25, 2024","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Get multi with return_as_model is now properly typed</li> <li>Filter with a UUID that is not a primary key now working</li> <li>Update with not found record now raises error as previously defined by warning</li> <li>Response model working properly in swagger</li> </ul>"},{"location":"changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Some fixes by @igorbenav in #190</li> <li>Response model in swagger by @igorbenav in #191</li> <li>Change version in pyproject to 0.15.5 by @igorbenav in #192</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.4...v0.15.5</p>"},{"location":"changelog/#0154-dec-23-2024","title":"[0.15.4] - Dec 23, 2024","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Implement select_schema on EndpointCreator and crud_router by @ljmc-github in #169</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Custom name bug fix by @igorbenav in #187</li> <li>UUID support fix by @igorbenav in #188</li> </ul>"},{"location":"changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Implement select_schema on EndpointCreator and crud_router by @ljmc-github in #169</li> <li>Custom name bug fix by @igorbenav in #187</li> <li>UUID support fix by @igorbenav in #188</li> <li>Bump version to 0.15.4 by @igorbenav in #189</li> </ul>"},{"location":"changelog/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@ljmc-github made their first contribution in #169</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.3...v0.15.4</p>"},{"location":"changelog/#0153-dec-23-2024","title":"[0.15.3] - Dec 23, 2024","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Get multi joined issue with repetition and wrong count</li> </ul>"},{"location":"changelog/#whats-changed_4","title":"What's Changed","text":"<ul> <li>Bug fixes by @igorbenav in #186</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.2...v0.15.3</p>"},{"location":"changelog/#0152-dec-15-2024","title":"[0.15.2] - Dec 15, 2024","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Add commit option to upsert_multi by @feluelle in #174</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Add missing commit to update by @feluelle in #173</li> <li>Default page or items_per_page for when paginating using the get on list by @phguyss in #177</li> <li>Improve update method when item is not found by @julianaklulo in #176</li> </ul>"},{"location":"changelog/#improved_1","title":"Improved","text":"<ul> <li>Fix quick-start documentation by @EduardoTT in #178</li> <li>Bump actions to avoid node16 EOL issue by @Zatura in #180</li> <li>Changelog updated by @igorbenav in #167</li> </ul>"},{"location":"changelog/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Changelog updated by @igorbenav in #167</li> <li>Add missing commit to update by @feluelle in #173</li> <li>Add commit option to upsert_multi by @feluelle in #174</li> <li>Fix: quick-start documentation by @EduardoTT in #178</li> <li>Improve update method when item is not found by @julianaklulo in #176</li> <li>Bump actions to avoid node16 EOL issue by @Zatura in #180</li> <li>Fix: default page or items_per_page for when paginating using the get on list by @phguyss in #177</li> </ul>"},{"location":"changelog/#new-contributors_2","title":"New Contributors","text":"<ul> <li>@EduardoTT made their first contribution in #178</li> <li>@julianaklulo made their first contribution in #176</li> <li>@Zatura made their first contribution in #180</li> <li>@phguyss made their first contribution in #177</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.1...v0.15.2</p>"},{"location":"changelog/#0151-sep-18-2024","title":"[0.15.1] - Sep 18, 2024","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Support for fastapi &gt;=0.100</li> </ul>"},{"location":"changelog/#whats-changed_6","title":"What's Changed","text":"<ul> <li>now supporting fastapi &gt;= 0.100.0 by @igorbenav in https://github.com/igorbenav/fastcrud/pull/166</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.0...v0.15.1</p>"},{"location":"changelog/#0150-sep-18-2024","title":"[0.15.0] - Sep 18, 2024","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Models and Schemas for Task Management (Batch 3) by @slaarti</li> <li>Models and Schemas for Articles, Authors, and Profiles (Batch 4) by @slaarti</li> <li><code>update_override</code> Argument to <code>upsert_multi</code> Method by @feluelle</li> <li>Configurable <code>is_deleted</code> Field in Soft Delete Logic by @gal-dahan</li> </ul>"},{"location":"changelog/#improved_2","title":"Improved","text":"<ul> <li>Fixed Complex Parameter Filter with <code>between</code> Operator by @wu-clan</li> <li>Fixed Cryptography Package Vulnerability</li> <li>Resolved Update Column Name Collision in Update Method</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Vulnerability in <code>cryptography</code> Package updated to <code>cryptography = \"^43.0.1\"</code></li> <li>Update Column Name Collision in the <code>update</code> method</li> </ul>"},{"location":"changelog/#documentation-updates_1","title":"Documentation Updates","text":"<ul> <li>Added Documentation for New Models and Schemas by @slaarti</li> <li>Updated <code>upsert_multi</code> Method Documentation with <code>update_override</code> Usage by @feluelle</li> <li>Clarified Endpoint Simplification and Deprecation Notices</li> </ul>"},{"location":"changelog/#warnings","title":"Warnings","text":"<ul> <li>Deprecation Notice: The <code>_read_paginated</code> endpoint has been removed. Please transition to using <code>_read_items</code> with pagination parameters. Docs here.</li> <li>Deprecation Notice: Handling of <code>Depends</code> is now only callable within <code>_inject_depend</code>. Update your code accordingly.</li> <li>Configuration Change Alert: Endpoints are simplified by default. Adjust your configurations to align with the new defaults. Docs here.</li> </ul>"},{"location":"changelog/#detailed-changes","title":"Detailed Changes","text":""},{"location":"changelog/#endpoint-simplification-and-deprecation-of-_read_paginated","title":"Endpoint Simplification and Deprecation of <code>_read_paginated</code>","text":""},{"location":"changelog/#description","title":"Description","text":"<p>To streamline API endpoint configurations, endpoints with empty strings as names are now the standard. Additionally, the <code>_read_paginated</code> endpoint has been removed, with its functionality merged into <code>_read_items</code>.</p>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Simplified Endpoint Configuration: Endpoints can now be defined with empty strings to create cleaner paths.</li> <li>Removed <code>_read_paginated</code> Endpoint: Pagination is now handled via optional parameters in <code>_read_items</code>.</li> </ul>"},{"location":"changelog/#usage-examples","title":"Usage Examples","text":"<p>Paginated Read Example:</p> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/items?page=2&amp;itemsPerPage=10' \\\n  -H 'accept: application/json'\n</code></pre> <p>Non-Paginated Read Example:</p> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/items?offset=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre>"},{"location":"changelog/#warnings_1","title":"Warnings","text":"<p>Warning</p> <p>The <code>_read_paginated</code> endpoint is deprecated. Use <code>_read_items</code> with pagination parameters instead.</p> <p>Warning</p> <p>Default endpoint names are now empty strings. Adjust your configurations to match the new defaults.</p>"},{"location":"changelog/#update_override-argument-in-upsert_multi-method","title":"<code>update_override</code> Argument in <code>upsert_multi</code> Method","text":""},{"location":"changelog/#description_1","title":"Description","text":"<p>The <code>upsert_multi</code> method now includes an <code>update_override</code> argument, giving developers the ability to override the default update logic during upsert operations. This enhancement provides greater flexibility for custom update scenarios, such as utilizing SQL <code>CASE</code> statements or other complex expressions.</p>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li><code>update_override</code> Argument: Allows custom update logic in <code>upsert_multi</code>.</li> <li>Dialect Support: Implemented for PostgreSQL, SQLite, and MySQL.</li> <li>Tests: Added comprehensive tests to ensure functionality across different SQL dialects.</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code>from fastcrud import FastCRUD\nfrom sqlalchemy import case\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\n\nawait crud_items.upsert_multi(\n    db=db,\n    instances=[\n        ItemCreateSchema(id=1, name=\"Item A\", price=10),\n        ItemCreateSchema(id=2, name=\"Item B\", price=20),\n    ],\n    update_override={\n        \"price\": case(\n            (Item.price.is_(None), db.excluded.price),\n            else_=Item.price,\n        )\n    }\n)\n</code></pre>"},{"location":"changelog/#configurable-is_deleted-field-in-soft-delete-logic","title":"Configurable <code>is_deleted</code> Field in Soft Delete Logic","text":""},{"location":"changelog/#description_2","title":"Description","text":"<p>The <code>is_deleted</code> field in the soft delete logic is now optional and configurable. This change allows developers to customize the soft delete behavior per model, providing flexibility in how deletion states are handled.</p>"},{"location":"changelog/#new-contributors_3","title":"New Contributors","text":"<ul> <li>@wu-clan made their first contribution \ud83c\udf1f</li> <li>@gal-dahan made their first contribution \ud83c\udf1f</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0140-jul-29-2024","title":"[0.14.0] - Jul 29, 2024","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Type-checking support for SQLModel types by @kdcokenny \ud83d\ude80</li> <li>Returning clause to update operations by @feluelle</li> <li>Upsert_multi functionality by @feluelle</li> <li>Simplified endpoint configurations by @JakNowy, streamlining path generation and merging pagination functionalities into a unified <code>_read_items</code> endpoint, promoting more efficient API structure and usage. Details in https://github.com/igorbenav/fastcrud/pull/105</li> </ul>"},{"location":"changelog/#improved_3","title":"Improved","text":"<ul> <li>Comprehensive tests for paginated retrieval of items, maintaining 100% coverage</li> <li>Docker client check before running tests that require Docker by @feluelle</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Vulnerability associated with an outdated cryptography package</li> <li>Return type inconsistency in async session fixtures by @slaarti</li> </ul>"},{"location":"changelog/#documentation-updates_2","title":"Documentation Updates","text":"<ul> <li>Cleanup of documentation formatting by @slaarti</li> <li>Replacement of the Contributing section in docs with an include to file in repo root by @slaarti</li> <li>Correction of links to advanced filters in docstrings by @slaarti</li> <li>Backfill of docstring fixes across various modules by @slaarti</li> <li>Enhanced filter documentation with new AND and OR clause examples, making complex queries more accessible and understandable.</li> </ul>"},{"location":"changelog/#models-and-schemas-enhancements","title":"Models and Schemas Enhancements","text":"<ul> <li>Introduction of simple and one-off models (Batch 1) by @slaarti</li> <li>Expansion to include models and schemas for Customers, Products, and Orders (Batch 2) by @slaarti</li> </ul>"},{"location":"changelog/#code-refinements","title":"Code Refinements","text":"<ul> <li>Resolution of missing type specifications in kwargs by @slaarti</li> <li>Collapsed space adjustments for models/schemas in <code>fast_crud.py</code> by @slaarti</li> </ul>"},{"location":"changelog/#warnings_2","title":"Warnings","text":"<ul> <li>Deprecation Notice: <code>_read_paginated</code> endpoint is set to be deprecated and merged into <code>_read_items</code>. Users are encouraged to transition to the latter, utilizing optional pagination parameters. Full details and usage instructions provided to ensure a smooth transition.</li> <li>Future Changes Alert: Default endpoint names in <code>EndpointCreator</code> are anticipated to be set to empty strings in a forthcoming major release, aligning with simplification efforts. Refer to https://github.com/igorbenav/fastcrud/issues/67 for more information.</li> </ul>"},{"location":"changelog/#detailed-changes_1","title":"Detailed Changes","text":""},{"location":"changelog/#simplified-endpoint-configurations","title":"Simplified Endpoint Configurations","text":"<p>In an effort to streamline FastCRUD\u2019s API, we have reconfigured endpoint paths to avoid redundancy (great work by @JakNowy). This change allows developers to specify empty strings for endpoint names in the <code>crud_router</code> setup, which prevents the generation of unnecessary <code>//</code> in the paths. The following configurations illustrate how endpoints can now be defined more succinctly:</p> <pre><code>endpoint_names = {\n    \"create\": \"\",\n    \"read\": \"\",\n    \"update\": \"\",\n    \"delete\": \"\",\n    \"db_delete\": \"\",\n    \"read_multi\": \"\",\n    \"read_paginated\": \"get_paginated\",\n}\n</code></pre> <p>Moreover, the <code>_read_paginated</code> logic has been integrated into the <code>_read_items</code> endpoint. This integration means that pagination can now be controlled via <code>page</code> and <code>items_per_page</code> query parameters, offering a unified method for both paginated and non-paginated reads:</p> <ul> <li>Paginated read example:</li> </ul> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/users/get_multi?page=2&amp;itemsPerPage=10' \\\n  -H 'accept: application/json'\n</code></pre> <ul> <li>Non-paginated read example:</li> </ul> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/users/get_multi?offset=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre>"},{"location":"changelog/#warnings_3","title":"Warnings","text":"<ul> <li>Deprecation Warning: The <code>_read_paginated</code> endpoint is slated for deprecation. Developers should transition to using <code>_read_items</code> with the relevant pagination parameters.</li> <li>Configuration Change Alert: In a future major release, default endpoint names in <code>EndpointCreator</code> will be empty strings by default, as discussed in Issue #67.</li> </ul>"},{"location":"changelog/#advanced-filters-documentation-update","title":"Advanced Filters Documentation Update","text":"<p>Documentation for advanced filters has been expanded to include comprehensive examples of AND and OR clauses, enhancing the utility and accessibility of complex query constructions.</p> <ul> <li>OR clause example:</li> </ul> <pre><code># Fetch items priced under $5 or above $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__or={'lt': 5, 'gt': 20},\n)\n</code></pre> <ul> <li>AND clause example:</li> </ul> <pre><code># Fetch items priced under $20 and over 2 years of warranty\nitems = await item_crud.get_multi(\n    db=db,\n    price__lt=20,\n    warranty_years__gt=2,\n)\n</code></pre>"},{"location":"changelog/#returning-clauses-in-update-operations","title":"Returning Clauses in Update Operations","text":""},{"location":"changelog/#description_3","title":"Description","text":"<p>Users can now retrieve updated records immediately following an update operation. This feature streamlines the process, reducing the need for subsequent retrieval calls and increasing efficiency.</p>"},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>Return Columns: Specify the columns to be returned after the update via the <code>return_columns</code> argument.</li> <li>Schema Selection: Optionally select a Pydantic schema to format the returned data using the <code>schema_to_select</code> argument.</li> <li>Return as Model: Decide if the returned data should be converted into a model using the <code>return_as_model</code> argument.</li> <li>Single or None: Utilize the <code>one_or_none</code> argument to ensure that either a single record is returned or none, in case the conditions do not match any records.</li> </ul> <p>These additions are aligned with existing CRUD API functions, enhancing consistency across the library and making the new features intuitive for users.</p>"},{"location":"changelog/#usage-example_1","title":"Usage Example","text":""},{"location":"changelog/#returning-updated-fields","title":"Returning Updated Fields","text":"<pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nupdated_item = await crud_items.update(\n    db=db,\n    object={\"price\": 9.99},\n    price__lt=10,\n    return_columns=[\"price\"]\n)\n# This returns the updated price of the item directly.\n</code></pre>"},{"location":"changelog/#returning-data-as-a-model","title":"Returning Data as a Model","text":"<pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .schemas.item import ItemSchema\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nupdated_item_schema = await crud_items.update(\n    db=db,\n    object={\"price\": 9.99},\n    price__lt=10,\n    schema_to_select=ItemSchema,\n    return_as_model=True\n)\n# This returns the updated item data formatted as an ItemSchema model.\n</code></pre>"},{"location":"changelog/#bulk-upsert-operations-with-upsert_multi","title":"Bulk Upsert Operations with <code>upsert_multi</code>","text":"<p>The <code>upsert_multi</code> method provides the ability to perform bulk upsert operations, which are optimized for different SQL dialects.</p>"},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li>Dialect-Optimized SQL: Uses the most efficient SQL commands based on the database's SQL dialect.</li> <li>Support for Multiple Dialects: Includes custom implementations for PostgreSQL, SQLite, and MySQL, with appropriate handling for each's capabilities and limitations.</li> </ul>"},{"location":"changelog/#usage-example_2","title":"Usage Example","text":""},{"location":"changelog/#upserting-multiple-records","title":"Upserting Multiple Records","text":"<pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .schemas.item import ItemCreateSchema, ItemSchema\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nitems = await crud_items.upsert_multi(\n    db=db,\n    instances=[\n        ItemCreateSchema(price=9.99),\n    ],\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n)\n# This will return the upserted data in the form of ItemSchema.\n</code></pre>"},{"location":"changelog/#implementation-details","title":"Implementation Details","text":"<p><code>upsert_multi</code> handles different database dialects: - PostgreSQL: Uses <code>ON CONFLICT DO UPDATE</code>. - SQLite: Utilizes <code>ON CONFLICT DO UPDATE</code>. - MySQL: Implements <code>ON DUPLICATE KEY UPDATE</code>.</p>"},{"location":"changelog/#notes","title":"Notes","text":"<ul> <li>MySQL and MariaDB do not support certain advanced features used in other dialects, such as returning values directly after an insert or update operation. This limitation is clearly documented to prevent misuse.</li> </ul>"},{"location":"changelog/#new-contributors_4","title":"New Contributors","text":"<ul> <li>@kdcokenny made their first contribution \ud83c\udf1f</li> <li>@feluelle made their first contribution \ud83c\udf1f</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0131-jun-22-2024","title":"[0.13.1] - Jun 22, 2024","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>More Advanced Filters by @JakNowy \ud83c\udf89</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Bug where objects with null primary key are returned with all fields set to None in nested joins #102 </li> </ul>"},{"location":"changelog/#detailed-changes_2","title":"Detailed Changes","text":""},{"location":"changelog/#advanced-filters","title":"Advanced Filters","text":"<p>FastCRUD supports advanced filtering options, allowing you to query records using operators such as greater than (<code>__gt</code>), less than (<code>__lt</code>), and their inclusive counterparts (<code>__gte</code>, <code>__lte</code>). These filters can be used in any method that retrieves or operates on records, including <code>get</code>, <code>get_multi</code>, <code>exists</code>, <code>count</code>, <code>update</code>, and <code>delete</code>.</p>"},{"location":"changelog/#single-parameter-filters","title":"Single parameter filters","text":"<p>Most filter operators require a single string or integer value.</p> <pre><code># Fetch items priced above $5\nitems = await item_crud.get_multi(\n    db=db,\n    price__gte=5,\n)\n</code></pre> <p>Currently supported single parameter filters are: - __gt - greater than - __lt - less than - __gte - greater than or equal to - __lte - less than or equal to - __ne - not equal - __is - used to test True, False, and None identity - __is_not - negation of \"is\" - __like - SQL \"like\" search for specific text pattern - __notlike - negation of \"like\" - __ilike - case insensitive \"like\" - __notilike - case insensitive \"notlike\" - __startswith - text starts with given string - __endswith - text ends with given string - __contains - text contains given string - __match - database-specific match expression</p>"},{"location":"changelog/#complex-parameter-filters","title":"Complex parameter filters","text":"<p>Some operators require multiple values. They must be passed as a python tuple, list, or set.</p> <p><pre><code># Fetch items priced between $5 and $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__between=(5, 20),\n)\n</code></pre> - __between - between 2 numeric values - __in - included in - __not_in - not included in</p>"},{"location":"changelog/#or-parameter-filters","title":"OR parameter filters","text":"<p>More complex OR filters are supported. They must be passed as a dictionary, where each key is a library-supported operator to be used in OR expression and values are what get's passed as the parameter.</p> <pre><code># Fetch items priced under $5 or above $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__or={'lt': 5, 'gt': 20},\n)\n</code></pre>"},{"location":"changelog/#whats-changed_7","title":"What's Changed","text":"<ul> <li>Missing sqlalchemy operators by @JakNowy in https://github.com/igorbenav/fastcrud/pull/85</li> <li>Null primary key bug fixed in https://github.com/igorbenav/fastcrud/pull/107</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.13.0...v0.13.1</p>"},{"location":"changelog/#0130-may-28-2024","title":"[0.13.0] - May 28, 2024","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Filters in Automatic Endpoints \ud83c\udf89</li> <li>One-to-many support in joins</li> <li>Upsert method in FastCRUD class by @dubusster </li> </ul>"},{"location":"changelog/#detailed-changes_3","title":"Detailed Changes","text":""},{"location":"changelog/#using-filters-in-fastcrud","title":"Using Filters in FastCRUD","text":"<p>FastCRUD provides filtering capabilities, allowing you to filter query results based on various conditions. Filters can be applied to <code>read_multi</code> and <code>read_paginated</code> endpoints. This section explains how to configure and use filters in FastCRUD.</p>"},{"location":"changelog/#defining-filters","title":"Defining Filters","text":"<p>Filters are either defined using the <code>FilterConfig</code> class or just passed as a dictionary. This class allows you to specify default filter values and validate filter types. Here's an example of how to define filters for a model:</p> <pre><code>from fastcrud import FilterConfig\n\n# Define filter configuration for a model\nfilter_config = FilterConfig(\n    tier_id=None,  # Default filter value for tier_id\n    name=None  # Default filter value for name\n)\n</code></pre> <p>And the same thing using a <code>dict</code>: <pre><code>filter_config = {\n    \"tier_id\": None,  # Default filter value for tier_id\n    \"name\": None,  # Default filter value for name\n}\n</code></pre></p> <p>By using <code>FilterConfig</code> you get better error messages.</p>"},{"location":"changelog/#applying-filters-to-endpoints","title":"Applying Filters to Endpoints","text":"<p>You can apply filters to your endpoints by passing the <code>filter_config</code> to the <code>crud_router</code> or <code>EndpointCreator</code>. Here's an example:</p> <pre><code>from fastcrud import crud_router\nfrom yourapp.models import YourModel\nfrom yourapp.schemas import CreateYourModelSchema, UpdateYourModelSchema\nfrom yourapp.database import async_session\n\n# Apply filters using crud_router\napp.include_router(\n    crud_router(\n        session=async_session,\n        model=YourModel,\n        create_schema=CreateYourModelSchema,\n        update_schema=UpdateYourModelSchema,\n        filter_config=filter_config,  # Apply the filter configuration\n        path=\"/yourmodel\",\n        tags=[\"YourModel\"]\n    )\n)\n</code></pre>"},{"location":"changelog/#using-filters-in-requests","title":"Using Filters in Requests","text":"<p>Once filters are configured, you can use them in your API requests. Filters are passed as query parameters. Here's an example of how to use filters in a request to a paginated endpoint:</p> <pre><code>GET /yourmodel/get_paginated?page=1&amp;itemsPerPage=3&amp;tier_id=1&amp;name=Alice\n</code></pre>"},{"location":"changelog/#custom-filter-validation","title":"Custom Filter Validation","text":"<p>The <code>FilterConfig</code> class includes a validator to check filter types. If an invalid filter type is provided, a <code>ValueError</code> is raised. You can customize the validation logic by extending the <code>FilterConfig</code> class:</p> <pre><code>from fastcrud import FilterConfig\nfrom pydantic import ValidationError\n\nclass CustomFilterConfig(FilterConfig):\n    @field_validator(\"filters\")\n    def check_filter_types(cls, filters: dict[str, Any]) -&gt; dict[str, Any]:\n        for key, value in filters.items():\n            if not isinstance(value, (type(None), str, int, float, bool)):\n                raise ValueError(f\"Invalid default value for '{key}': {value}\")\n        return filters\n\ntry:\n    # Example of invalid filter configuration\n    invalid_filter_config = CustomFilterConfig(invalid_field=[])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"changelog/#handling-invalid-filter-columns","title":"Handling Invalid Filter Columns","text":"<p>FastCRUD ensures that filters are applied only to valid columns in your model. If an invalid filter column is specified, a <code>ValueError</code> is raised:</p> <pre><code>try:\n    # Example of invalid filter column\n    invalid_filter_config = FilterConfig(non_existent_column=None)\nexcept ValueError as e:\n    print(e)  # Output: Invalid filter column 'non_existent_column': not found in model\n</code></pre>"},{"location":"changelog/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"changelog/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul> <p>Example</p> <p>Let's define two tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <p>Fetch a user and their tier:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre> <p>One-to-One Relationship with Nested Joins</p> <p>To get the joined data in a nested dictionary:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre>"},{"location":"changelog/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>Warning</p> <p>When using <code>nest_joins=True</code>, the performance will always be a bit worse than when using <code>nest_joins=False</code>. For cases where more performance is necessary, consider using <code>nest_joins=False</code> and remodeling your database.</p> <p>Example</p> <p>To demonstrate a one-to-many relationship, let's assume <code>User</code> and <code>Post</code> tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary key=True)\n    name = Column(String)\n\nclass Post(Base):\n    __tablename__ = \"post\"\n    id = Column(Integer, primary key=True)\n    user_id = Column(Integer, ForeignKey(\"user.id\"))\n    content = Column(String)\n</code></pre> <p>Fetch a user and all their posts:</p> <pre><code>user_posts = await user_crud.get_joined(\n    db=db,\n    join_model=Post,\n    join_on=User.id == Post.user_id,\n    join_type=\"left\",\n    join_prefix=\"post_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example User\",\n    \"posts\": [\n        {\n            \"id\": 101,\n            \"user_id\": 1,\n            \"content\": \"First post content\"\n        },\n        {\n            \"id\": 102,\n            \"user_id\": 1,\n            \"content\": \"Second post content\"\n        }\n    ]\n}\n</code></pre>"},{"location":"changelog/#whats-changed_8","title":"What's Changed","text":"<ul> <li>feat: \u2728 add upsert method in FastCRUD class by @dubusster</li> <li>Filters in Automatic Endpoints</li> <li>One-to-many support in joins</li> <li>tests fixed by @igorbenav</li> <li>Using the same session for all tests</li> <li>warning added to docs</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.12.1...v0.13.0</p>"},{"location":"changelog/#0121-may-10-2024","title":"[0.12.1] - May 10, 2024","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Deprecation Warning for dependency handling.</li> </ul>"},{"location":"changelog/#detailed-changes_4","title":"Detailed Changes","text":"<p>If you pass a sequence of <code>params.Depends</code> type variables to any <code>*_deps</code> parameter in <code>EndpointCreator</code> and <code>crud_router</code>, you'll get a warning. Support will be completely removed in 0.15.0.</p> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.12.0...v0.12.1</p>"},{"location":"changelog/#0120-may-8-2024","title":"[0.12.0] - May 8, 2024","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Unpaginated versions of multi-row get methods by @slaarti in #62  \ud83c\udf89</li> <li>Nested Join bug fixes</li> <li>Dependency handling now working as docs say</li> <li>Option to Skip commit in some fastcrud methods</li> <li>Docstring example fixes</li> <li><code>__in</code> and <code>__not_in</code> filters by @JakNowy \ud83c\udf89</li> <li>Fastapi 0.111.0 support</li> </ul>"},{"location":"changelog/#detailed-changes_5","title":"Detailed Changes","text":""},{"location":"changelog/#unpaginated-versions-of-multi-row-get-methods","title":"Unpaginated versions of multi-row get methods","text":"<p>Now, if you pass <code>None</code> to <code>limit</code> in <code>get_multi</code> and <code>get_multi_joined</code>, you get the whole unpaginated set of data that matches the filters. Use this with caution.</p> <pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nitems = await crud_items.get_multi(db=db, limit=None)\n# this will return all items in the db\n</code></pre>"},{"location":"changelog/#dependency-handling-now-working-as-docs-say","title":"Dependency handling now working as docs say","text":"<p>Now, you may pass dependencies to <code>crud_router</code> or <code>EndpointCreator</code> as simple functions instead of needing to wrap them in <code>fastapi.Depends</code>.</p> <pre><code>from .dependencies import get_superuser\napp.include_router(\n    crud_router(\n        session=db,\n        model=Item,\n        create_schema=ItemCreate,\n        update_schema=ItemUpdate,\n        delete_schema=ItemDelete,\n        create_deps=[get_superuser],\n        update_deps=[get_superuser],\n        delete_deps=[get_superuser],\n        path=\"/item\",\n        tags=[\"item\"],\n    )\n)\n</code></pre>"},{"location":"changelog/#option-to-skip-commit-in-some-fastcrud-methods","title":"Option to Skip commit in some fastcrud methods","text":"<p>For <code>create</code>, <code>update</code>, <code>db_delete</code> and <code>delete</code> methods of <code>FastCRUD</code>, now you have the option of passing <code>commit=False</code> so you don't commit the operations immediately.</p> <pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\n\nawait crud_items.delete(\n    db=db, \n    commit=False, \n    id=1\n)\n# this will not actually delete until you run a db.commit()\n</code></pre>"},{"location":"changelog/#__in-and-__not_in-filters","title":"<code>__in</code> and <code>__not_in</code> filters","text":"<p>You may now pass <code>__in</code> and <code>__not_in</code> to methods that accept advanced queries:</p> <ul> <li><code>__gt</code>: greater than,</li> <li><code>__lt</code>: less than,</li> <li><code>__gte</code>: greater than or equal to,</li> <li><code>__lte</code>: less than or equal to,</li> <li><code>__ne</code>: not equal,</li> <li><code>__in</code>: included in [tuple, list or set],</li> <li><code>__not_in</code>: not included in [tuple, list or set].</li> </ul>"},{"location":"changelog/#whats-changed_9","title":"What's Changed","text":"<ul> <li>Add unpaginated versions of multi-row get methods (w/tests) by @slaarti \ud83c\udf89</li> <li>Join fixes</li> <li>Dependencies</li> <li>Skip commit</li> <li>Docstring fix</li> <li>feat: filter __in by @JakNowy \ud83c\udf89</li> <li>python support for 0.111.0 added</li> <li>version bump in pyproject.toml for 0.12.0</li> </ul>"},{"location":"changelog/#new-contributors_5","title":"New Contributors","text":"<ul> <li>@slaarti made their first contribution in https://github.com/igorbenav/fastcrud/pull/62 \ud83c\udf89</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.11.1...v0.12.0</p>"},{"location":"changelog/#0111-apr-22-2024","title":"[0.11.1] - Apr 22, 2024","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li><code>one_or_none</code> parameter to FastCRUD <code>get</code> method (default <code>False</code>)</li> <li><code>nest_joins</code> parameter to FastCRUD <code>get_joined</code> and <code>get_multi_joined</code> (default <code>False</code>)</li> </ul>"},{"location":"changelog/#detailed-changes_6","title":"Detailed Changes","text":""},{"location":"changelog/#get","title":"<code>get</code>","text":"<p>By default, the <code>get</code> method in <code>FastCRUD</code> returns the <code>first</code> object matching all the filters it finds.</p> <p>If you want to ensure the <code>one_or_none</code> behavior, you may pass the parameter as <code>True</code>:</p> <pre><code>crud.get(\n    async_session, \n    one_or_none=True, \n    category_id=1\n)\n</code></pre>"},{"location":"changelog/#get_joined-and-get_multi_joined","title":"<code>get_joined</code> and <code>get_multi_joined</code>","text":"<p>By default, <code>FastCRUD</code> joins all the data and returns it in a single dictionary. Let's define two tables: <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre></p> <p>And join them with <code>FastCRUD</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",,\n    id=1\n)\n</code></pre> <p>We'll get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\",\n}\n</code></pre> <p>Now, if you want the joined data in a nested dictionary instead, you may just pass <code>nest_joins=True</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>And you will get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\",\n    },\n}\n</code></pre> <p>This works for both <code>get_joined</code> and <code>get_multi_joined</code>.</p> <p>Warning</p> <p>Note that the final <code>\"_\"</code> in the passed <code>\"tier_\"</code> is stripped.</p>"},{"location":"changelog/#whats-changed_10","title":"What's Changed","text":"<ul> <li>Reuse of <code>select</code> method in <code>FastCRUD</code></li> <li>Skip count call when possible</li> <li>Add <code>one_or_none</code> parameter to FastCRUD <code>get</code> method</li> <li>Add <code>nest_joins</code> parameter to FastCRUD <code>get_joined</code> and <code>get_multi_joined</code></li> </ul>"},{"location":"changelog/#new-contributors_6","title":"New Contributors","text":"<ul> <li>@JakNowy made their first contribution in PR #51.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0110-apr-7-2024","title":"[0.11.0] - Apr 7, 2024","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Multiple primary keys support, a significant enhancement by @dubusster in #31 \ud83c\udf89.</li> <li>Option to disable the count in <code>get_multi</code> and <code>get_multi_joined</code> methods for performance optimization.</li> <li>Fixes for a validation bug when <code>return_as_model</code> is set to <code>True</code>.</li> <li>Resolution of a bug concerning incorrect handling of <code>db_row</code> in methods.</li> <li>Correction of the <code>valid_methods</code> bug, which previously raised the wrong error type.</li> <li>Upgrade of <code>FastAPI</code> dependency to version <code>0.111.0</code>, ensuring compatibility with the latest FastAPI features.</li> <li>Achievement of 100% test coverage, with the addition of a workflow and badge to showcase this milestone.</li> <li>Inclusion of the changelog within the project documentation, providing a comprehensive history of changes directly to users.</li> </ul>"},{"location":"changelog/#detailed-changes_7","title":"Detailed Changes","text":""},{"location":"changelog/#multiple-primary-keys-support","title":"Multiple Primary Keys Support","text":"<p>FastCRUD now accommodates models with multiple primary keys, facilitating more complex database designs. For models defined with more than one primary key, the endpoint creator automatically generates paths reflecting the primary keys' order. This feature extends support to primary keys named differently than <code>id</code>, enhancing the flexibility of FastCRUD's routing capabilities.</p>"},{"location":"changelog/#example","title":"Example:","text":"<p>For a model with multiple primary keys, FastCRUD generates specific endpoints such as <code>/multi_pk/get/{id}/{uuid}</code>, accommodating the unique identification needs of complex data models.</p>"},{"location":"changelog/#optional-count","title":"Optional Count","text":"<p>The <code>get_multi</code> and <code>get_multi_joined</code> methods now feature an <code>return_total_count=False</code> parameter, allowing users to opt-out of receiving the total count in responses. This option can enhance performance by skipping potentially expensive count operations.</p>"},{"location":"changelog/#behavior","title":"Behavior:","text":"<ul> <li>By default, <code>return_total_count=True</code> is assumed, returning both data and a total count.</li> <li>When set to <code>False</code>, responses contain only the data array, omitting the total count for efficiency.</li> </ul>"},{"location":"changelog/#whats-changed_11","title":"What's Changed","text":"<ul> <li>Implementation of multiple primary keys support, addressing a significant flexibility requirement for advanced use cases.</li> <li>Introduction of optional count retrieval in multi-get methods, optimizing performance by eliminating unnecessary database queries.</li> <li>Several critical bug fixes, improving the stability and reliability of FastCRUD.</li> <li>Documentation enhancements, including the addition of a changelog section, ensuring users have access to detailed release information.</li> <li>Update to FastAPI <code>0.111.0</code>, ensuring compatibility with the latest enhancements in the FastAPI ecosystem.</li> <li>Achievement of 100% test coverage, marking a significant milestone in the project's commitment to reliability and quality assurance.</li> </ul>"},{"location":"changelog/#relevant-contributors","title":"Relevant Contributors","text":"<ul> <li>@dubusster made a notable contribution with the implementation of multiple primary keys support in PR #31.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0100-mar-30-2024","title":"[0.10.0] - Mar 30, 2024","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li><code>select</code> statement functionality, thanks to @dubusster's contribution in PR #28 \ud83d\ude80.</li> <li>Support for joined models in the <code>count</code> method through the <code>joins_config</code> parameter.</li> <li>Filters for joined models via the <code>filters</code> parameter in <code>JoinConfig</code>.</li> <li>Type checking workflow integrated with <code>mypy</code> alongside fixes for typing issues.</li> <li>Linting workflow established with <code>ruff</code>.</li> </ul>"},{"location":"changelog/#detailed-changes_8","title":"Detailed Changes","text":""},{"location":"changelog/#select","title":"Select","text":"<p>The <code>select</code> method constructs a SQL Alchemy <code>Select</code> statement, offering flexibility in column selection, filtering, and sorting. It is designed to chain additional SQLAlchemy methods for complex queries. Docs here and here.</p>"},{"location":"changelog/#features","title":"Features:","text":"<ul> <li>Column Selection: Choose columns via a Pydantic schema.</li> <li>Sorting: Define columns and their order for sorting.</li> <li>Filtering: Directly apply filters through keyword arguments.</li> <li>Chaining: Allow for chaining with other SQLAlchemy methods for advanced query construction.</li> </ul>"},{"location":"changelog/#improved-joins","title":"Improved Joins","text":"<p><code>JoinConfig</code> enhances FastCRUD queries by detailing join operations between models, offering configurations like model joining, conditions, prefixes, column selection through schemas, join types, aliases, and direct filtering. Docs here.</p>"},{"location":"changelog/#applying-joins-in-fastcrud-methods","title":"Applying Joins in FastCRUD Methods","text":"<p>Detailed explanations and examples are provided for using joins in <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code> methods to achieve complex data retrieval, including handling of many-to-many relationships.</p>"},{"location":"changelog/#whats-changed_12","title":"What's Changed","text":"<ul> <li>New <code>select</code> statement functionality added.</li> <li>Documentation and method improvements for select and joins.</li> <li>Integration of type checking and linting workflows.</li> <li>Version bump in pyproject.toml.</li> </ul>"},{"location":"changelog/#new-contributors_7","title":"New Contributors","text":"<ul> <li>@dubusster made their first contribution in PR #28.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#091-mar-19-2024","title":"[0.9.1] - Mar 19, 2024","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Enhanced <code>get_joined</code> and <code>get_multi_joined</code> methods to support aliases, enabling multiple joins on the same model. This improvement addresses issue #27.</li> </ul>"},{"location":"changelog/#detailed-changes_9","title":"Detailed Changes","text":""},{"location":"changelog/#alias-support-for-complex-joins","title":"Alias Support for Complex Joins","text":"<p>With the introduction of alias support, <code>get_joined</code> and <code>get_multi_joined</code> methods now allow for more complex queries, particularly beneficial in scenarios requiring self-joins or multiple joins on the same table. Aliases help to avoid conflicts and ambiguity by providing unique identifiers for the same model in different join contexts. Docs here.</p>"},{"location":"changelog/#example-multiple-joins-with-aliases","title":"Example: Multiple Joins with Aliases","text":"<p>To demonstrate the use of aliases, consider a task management system where tasks are associated with both an owner and an assigned user from the same <code>UserModel</code>. Aliases enable joining the <code>UserModel</code> twice under different contexts - as an owner and an assigned user. This example showcases how to set up aliases using the <code>aliased</code> function and incorporate them into your <code>JoinConfig</code> for clear and conflict-free query construction. Docs here.</p>"},{"location":"changelog/#whats-changed_13","title":"What's Changed","text":"<ul> <li>Introduction of aliases in joins, improving query flexibility and expressiveness, as detailed by @igorbenav in PR #29.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#090-mar-14-2024","title":"[0.9.0] - Mar 14, 2024","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Enhanced <code>get_joined</code> and <code>get_multi_joined</code> methods now support handling joins with multiple models.</li> </ul>"},{"location":"changelog/#detailed-changes_10","title":"Detailed Changes","text":""},{"location":"changelog/#multi-model-join-capabilities","title":"Multi-Model Join Capabilities","text":"<p>The <code>get_joined</code> and <code>get_multi_joined</code> methods have been upgraded to accommodate joins involving multiple models. This functionality is facilitated through the <code>joins_config</code> parameter, allowing for the specification of multiple <code>JoinConfig</code> instances. Each instance represents a unique join configuration, broadening the scope for complex data relationship management within FastCRUD. Docs here.</p>"},{"location":"changelog/#example-multi-model-join","title":"Example: Multi-Model Join","text":"<p>A practical example involves retrieving users alongside their corresponding tier and department details. By configuring <code>joins_config</code> with appropriate <code>JoinConfig</code> instances for the <code>Tier</code> and <code>Department</code> models, users can efficiently gather comprehensive data across related models, enhancing data retrieval operations' depth and flexibility.</p> <p>Warning</p> <p>An error will occur if both single join parameters and <code>joins_config</code> are used simultaneously. It's crucial to ensure that your join configurations are correctly set to avoid conflicts.</p>"},{"location":"changelog/#whats-changed_14","title":"What's Changed","text":"<ul> <li>Introduction of multi-model join support in <code>get_joined</code> and <code>get_multi_joined</code>, enabling more complex and detailed data retrieval strategies.</li> <li>Several minor updates and fixes, including package import corrections and <code>pyproject.toml</code> updates, to improve the library's usability and stability.</li> </ul>"},{"location":"changelog/#new-contributors_8","title":"New Contributors","text":"<ul> <li>@iridescentGray</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#080-mar-4-2024","title":"[0.8.0] - Mar 4, 2024","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Feature to customize names of auto-generated endpoints using the <code>endpoint_names</code> parameter, applicable in both <code>crud_router</code> function and <code>EndpointCreator</code>.</li> </ul>"},{"location":"changelog/#detailed-changes_11","title":"Detailed Changes","text":""},{"location":"changelog/#custom-endpoint-naming","title":"Custom Endpoint Naming","text":"<p>The introduction of the <code>endpoint_names</code> parameter offers flexibility in defining endpoint names for CRUD operations. This enhancement caters to the need for more descriptive or project-specific naming conventions, enabling developers to align the API's interface with their domain language or organizational standards. </p>"},{"location":"changelog/#example-customizing-endpoint-names-with-crud_router","title":"Example: Customizing Endpoint Names with <code>crud_router</code>","text":"<p>Customizing endpoint names is straightforward with the <code>crud_router</code> function. By providing a dictionary mapping CRUD operation names to desired endpoint names, developers can easily tailor their API's paths to fit their application's unique requirements.</p>"},{"location":"changelog/#example-customizing-endpoint-names-with-endpointcreator","title":"Example: Customizing Endpoint Names with <code>EndpointCreator</code>","text":"<p>Similarly, when using the <code>EndpointCreator</code>, the <code>endpoint_names</code> parameter allows for the same level of customization, ensuring consistency across different parts of the application or service.</p> <p>Tip</p> <p>It's not necessary to specify all endpoint names; only those you wish to change need to be included in the <code>endpoint_names</code> dictionary. This flexibility ensures minimal configuration effort for maximum impact.</p>"},{"location":"changelog/#whats-changed_15","title":"What's Changed","text":"<ul> <li>Enhanced endpoint customization capabilities through <code>endpoint_names</code> parameter, supporting a more tailored and intuitive API design.</li> <li>Documentation updates to guide users through the process of customizing endpoint names.</li> </ul>"},{"location":"changelog/#070-feb-20-2024","title":"[0.7.0] - Feb 20, 2024","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>The <code>get_paginated</code> endpoint for retrieving items with pagination support.</li> <li>The <code>paginated</code> module to offer utility functions for pagination.</li> </ul>"},{"location":"changelog/#detailed-changes_12","title":"Detailed Changes","text":""},{"location":"changelog/#get_paginated-endpoint","title":"<code>get_paginated</code> Endpoint","text":"<p>This new endpoint enhances data retrieval capabilities by introducing pagination, an essential feature for handling large datasets efficiently. It supports customizable query parameters for page number and items per page, facilitating flexible data access patterns. Docs here.</p>"},{"location":"changelog/#features_1","title":"Features:","text":"<ul> <li>Endpoint and Method: A <code>GET</code> request to <code>/get_paginated</code>.</li> <li>Query Parameters: Includes <code>page</code> for the page number and <code>itemsPerPage</code> for controlling the number of items per page.</li> <li>Example Usage: Demonstrated with a request for retrieving items with specified pagination settings.</li> </ul>"},{"location":"changelog/#paginated-module","title":"<code>paginated</code> Module","text":"<p>The introduction of the <code>paginated</code> module brings two key utility functions, <code>paginated_response</code> and <code>compute_offset</code>, which streamline the implementation of paginated responses in the application.</p>"},{"location":"changelog/#functions","title":"Functions:","text":"<ul> <li>paginated_response: Constructs a paginated response based on the input data, page number, and items per page.</li> <li>compute_offset: Calculates the offset for database queries, based on the current page number and the number of items per page.</li> </ul>"},{"location":"changelog/#whats-changed_16","title":"What's Changed","text":"<ul> <li>Deployment of pagination functionality, embodied in the <code>get_paginated</code> endpoint and the <code>paginated</code> module, to facilitate efficient data handling and retrieval.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#060-feb-11-2024","title":"[0.6.0] - Feb 11, 2024","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>The ability to use a custom <code>updated_at</code> column name in models.</li> <li>Making the passing of the <code>crud</code> parameter to <code>crud_router</code> and <code>EndpointCreator</code> optional.</li> <li>Inclusion of exceptions in the <code>http_exceptions</code> module within the broader <code>exceptions</code> module for better organization and accessibility.</li> </ul>"},{"location":"changelog/#detailed-changes_13","title":"Detailed Changes","text":""},{"location":"changelog/#custom-updated_at-column","title":"Custom <code>updated_at</code> Column","text":"<p>FastCRUD now supports the customization of the <code>updated_at</code> column name, providing flexibility for applications with different database schema conventions or naming practices. Docs here.</p>"},{"location":"changelog/#example-configuration","title":"Example Configuration:","text":"<p>The example demonstrates how to specify a custom column name for <code>updated_at</code> when setting up the router for an endpoint, allowing for seamless integration with existing database schemas.</p>"},{"location":"changelog/#whats-changed_17","title":"What's Changed","text":"<ul> <li>Introduction of features enhancing flexibility and usability, such as custom <code>updated_at</code> column names and the optional CRUD parameter in routing configurations.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#050-feb-3-2024","title":"[0.5.0] - Feb 3, 2024","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Advanced filters inspired by Django ORM for enhanced querying capabilities.</li> <li>Optional bulk operations for update and delete methods.</li> <li>Custom soft delete mechanisms integrated into <code>FastCRUD</code>, <code>EndpointCreator</code>, and <code>crud_router</code>.</li> <li>Comprehensive test suite for the newly introduced features.</li> </ul>"},{"location":"changelog/#detailed-changes_14","title":"Detailed Changes","text":""},{"location":"changelog/#advanced-filters_1","title":"Advanced Filters","text":"<p>The advanced filtering system allows for sophisticated querying with support for operators like <code>__gt</code>, <code>__lt</code>, <code>__gte</code>, and <code>__lte</code>, applicable across various CRUD operations. This feature significantly enhances the flexibility and power of data retrieval and manipulation within FastCRUD. Docs here.</p>"},{"location":"changelog/#examples","title":"Examples:","text":"<ul> <li>Utilization of advanced filters for precise data fetching and aggregation.</li> <li>Implementation examples for fetching records within specific criteria and counting records based on date ranges.</li> </ul>"},{"location":"changelog/#custom-soft-delete-mechanisms","title":"Custom Soft Delete Mechanisms","text":"<p>FastCRUD's soft delete functionality now supports customization, allowing developers to specify alternative column names for <code>is_deleted</code> and <code>deleted_at</code> fields. This adaptation enables seamless integration with existing database schemas that employ different naming conventions for soft deletion tracking. Docs here.</p>"},{"location":"changelog/#example-configuration_1","title":"Example Configuration:","text":"<ul> <li>Setting up <code>crud_router</code> with custom soft delete column names, demonstrating the flexibility in adapting FastCRUD to various database schema requirements.</li> </ul>"},{"location":"changelog/#bulk-operations","title":"Bulk Operations","text":"<p>The introduction of optional bulk operations for updating and deleting records provides a more efficient way to handle large datasets, enabling mass modifications or removals with single method calls. This feature is particularly useful for applications that require frequent bulk data management tasks. Docs here.</p>"},{"location":"changelog/#examples_1","title":"Examples:","text":"<ul> <li>Demonstrating bulk update and delete operations, highlighting the capability to apply changes to multiple records based on specific criteria.</li> </ul>"},{"location":"changelog/#whats-changed_18","title":"What's Changed","text":"<ul> <li>Addition of advanced filters, bulk operations, and custom soft delete functionalities.</li> </ul>"},{"location":"changelog/#new-contributors_9","title":"New Contributors","text":"<ul> <li>@YuriiMotov</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#040-jan-31-2024","title":"[0.4.0] - Jan 31, 2024","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Documentation and tests for SQLModel support.</li> <li><code>py.typed</code> file for better typing support.</li> </ul>"},{"location":"changelog/#detailed","title":"Detailed","text":"<p>Check the docs for SQLModel support.</p>"},{"location":"changelog/#whats-changed_19","title":"What's Changed","text":"<ul> <li>SQLModel support.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#030-jan-28-2024","title":"[0.3.0] - Jan 28, 2024","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>The <code>CustomEndpointCreator</code> for advanced route creation and customization.</li> <li>The ability to selectively include or exclude CRUD operations in the <code>crud_router</code> using <code>included_methods</code> and <code>deleted_methods</code>.</li> <li>Comprehensive tests for the new features.</li> <li>Detailed documentation on utilizing the <code>CustomEndpointCreator</code> and selectively including or excluding endpoints.</li> </ul>"},{"location":"changelog/#customendpointcreator","title":"CustomEndpointCreator","text":"<p>This feature introduces the capability to extend the <code>EndpointCreator</code> class, enabling developers to define custom routes and incorporate complex logic into API endpoints. The documentation has been updated to include detailed examples and guidelines on implementing and using <code>CustomEndpointCreator</code> in projects. Docs here.</p>"},{"location":"changelog/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>The <code>crud_router</code> function has been enhanced with <code>included_methods</code> and <code>deleted_methods</code> parameters, offering developers precise control over which CRUD methods are included or excluded when configuring routers. This addition provides flexibility in API design, allowing for the creation of tailored endpoint setups that meet specific project requirements. Docs here.</p>"},{"location":"changelog/#detailed-changes_15","title":"Detailed Changes","text":""},{"location":"changelog/#extending-endpointcreator","title":"Extending EndpointCreator","text":"<p>Developers can now create a subclass of <code>EndpointCreator</code> to define custom routes or override existing methods, adding a layer of flexibility and customization to FastCRUD's routing capabilities.</p>"},{"location":"changelog/#creating-a-custom-endpointcreator","title":"Creating a Custom EndpointCreator","text":"<p>An example demonstrates how to subclass <code>EndpointCreator</code> and add custom routes or override existing methods, further illustrating how to incorporate custom endpoint logic and route configurations into the FastAPI application.</p>"},{"location":"changelog/#adding-custom-routes","title":"Adding Custom Routes","text":"<p>The process involves overriding the <code>add_routes_to_router</code> method to include both standard CRUD routes and custom routes, showcasing how developers can extend FastCRUD's functionality to suit their application's unique needs.</p>"},{"location":"changelog/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<p>An example highlights how to use the custom <code>EndpointCreator</code> with <code>crud_router</code>, specifying selective methods to be included in the router setup, thereby demonstrating the practical application of custom endpoint creation and selective method inclusion.</p>"},{"location":"changelog/#selective-crud-operations_1","title":"Selective CRUD Operations","text":"<p>Examples for using <code>included_methods</code> and <code>deleted_methods</code> illustrate how to specify exactly which CRUD methods should be included or excluded when setting up the router, offering developers precise control over their API's exposed functionality.</p> <p>Warning</p> <p>Providing both <code>included_methods</code> and <code>deleted_methods</code> will result in a ValueError.</p> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#021-jan-27-2024","title":"[0.2.1] - Jan 27, 2024","text":""},{"location":"changelog/#whats-changed_20","title":"What's Changed","text":"<ul> <li>Improved type hints across the codebase, enhancing the clarity and reliability of type checking within FastCRUD.</li> <li>Documentation has been thoroughly updated and refined, including fixes for previous inaccuracies and the addition of more detailed explanations and examples.</li> <li>Descriptions have been added to automatically generated endpoints, making the API documentation more informative and user-friendly.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#020-jan-25-2024","title":"[0.2.0] - Jan 25, 2024","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Docs Published!</li> </ul>"},{"location":"changelog/#015-jan-24-2024","title":"[0.1.5] - Jan 24, 2024","text":"<p>Readme updates, pyproject requirements</p>"},{"location":"changelog/#012-jan-23-2024","title":"[0.1.2] - Jan 23, 2024","text":"<p>First public release.</p>"},{"location":"installing/","title":"Installing","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"installing/#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install fastcrud\n</code></pre> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"quick-start/","title":"Quick-Start","text":"<p>If you are using SQLModel, go to Using SQLModel instead.</p>"},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your SQLAlchemy model, Pydantic schemas and database connection, just skip to Using FastCRUD</p>"},{"location":"quick-start/#basic-setup","title":"Basic Setup","text":"<p>Define your SQLAlchemy model</p> setup.py<pre><code>import datetime\nfrom sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom pydantic import BaseModel\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n\n\nclass ItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your Pydantic schemas</p> setup.py<pre><code>import datetime\nfrom sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom pydantic import BaseModel\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n\n\nclass ItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>import datetime\nfrom sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom pydantic import BaseModel\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n\n\nclass ItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre>"},{"location":"quick-start/#using-fastcrud","title":"Using FastCRUD","text":"<p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom fastcrud import crud_router\nimport setup\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with setup.async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with setup.engine.begin() as conn:\n        await conn.run_sync(setup.Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=setup.Item,\n    create_schema=setup.ItemSchema,\n    update_schema=setup.ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"showcase/","title":"Showcase","text":"<p>Categories</p> <p>Browse by type: Applications \u00b7 Tutorials</p>"},{"location":"showcase/#applications","title":"Applications","text":"<p>Be the First!</p> <p>No applications yet. Have you built something with FastCRUD? We'd love to feature it here!</p> <p>Submit Your Project</p>"},{"location":"showcase/#open-source","title":"Open Source","text":"<p>FastAPI Boilerplate</p> <p>By FastCRUD Team \u00b7 Source</p> <p>FastAPI boilerplate creates an extendable async API using FastAPI, Pydantic V2, SQLAlchemy 2.0 and PostgreSQL.</p> <p><code>Template</code> <code>FastAPI</code> <code>Boilerplate</code></p> <p>Email Assistant API</p> <p>By FastCRUD Team \u00b7 Source</p> <p>A personalized email writing assistant built with FastAPI, OpenAI's API, and FastCRUD.</p> <p><code>OpenAI</code> <code>LLM</code> <code>AI</code></p> <p>SQLModel Boilerplate</p> <p>By FastCRUD Team \u00b7 Source</p> <p>SQLModel boilerplate creates an extendable async API using FastAPI, SQLModel and PostgreSQL.</p> <p><code>Template</code> <code>SQLModel</code> <code>Boilerplate</code></p>"},{"location":"showcase/#tutorials","title":"Tutorials","text":"<p>Creating LLM Powered APIs with FastAPI</p> <p>By FastCRUD Team \u00b7 View Tutorial</p> <p>Learn the basics of creating LLM powered APIs with FastCRUD.</p> <p><code>FastAPI</code> <code>AI</code> <code>Beginner</code> <code>LLM</code></p> <p>Add Your Project</p> <p>Built something with FastCRUD? We'd love to showcase it!</p> <p>Submit Your Project</p>"},{"location":"sqlmodel/","title":"Using FastCRUD with SQLModel","text":"<p>Since SQLModel is just a combination of SQLAlchemy and Pydantic, the process simplifies as SQLModel combines the model and schema definitions.</p> <p>Wherever in the docs you see a SQLAlchemy model or Pydantic schema being used, you may just replace it with SQLModel and it will work. For the quick start:</p> <p>Define your SQLModel model</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass Item(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n    created_at: datetime.datetime = Field(\n        nullable=False, sa_column_kwargs={\"default\": func.now()}\n    )\n\n\nclass ItemSchema(SQLModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your schemas</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass Item(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n    created_at: datetime.datetime = Field(\n        nullable=False, sa_column_kwargs={\"default\": func.now()}\n    )\n\n\nclass ItemSchema(SQLModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>from sqlmodel import SQLModel, Field\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass Item(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n    created_at: datetime.datetime = Field(\n        nullable=False, sa_column_kwargs={\"default\": func.now()}\n    )\n\n\nclass ItemSchema(SQLModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from fastcrud import crud_router\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>By following the above setup, FastCRUD auto-generates CRUD endpoints for your model, accessible through the <code>/docs</code> route of your FastAPI application.</p>"},{"location":"advanced/crud/","title":"Advanced Use of FastCRUD","text":"<p>FastCRUD offers a flexible and powerful approach to handling CRUD operations in FastAPI applications, leveraging the SQLAlchemy ORM. Beyond basic CRUD functionality, FastCRUD provides advanced features like <code>allow_multiple</code> for updates and deletes, and support for advanced filters (e.g., less than, greater than). These features enable more complex and fine-grained data manipulation and querying capabilities.</p>"},{"location":"advanced/crud/#typing-options-for-fastcrud","title":"Typing Options for <code>FastCRUD</code>","text":"<p>Note that when initializing <code>FastCRUD</code>, assuming you have a model like:</p> Simplified <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <p>Warning</p> <p>Note that naive <code>datetime</code> such as <code>datetime.utcnow</code> is not supported by <code>FastCRUD</code> as it was deprecated.</p> <p>Use timezone aware <code>datetime</code>, such as <code>datetime.now(UTC)</code> instead.</p> <p>You could just pass it to <code>FastCRUD</code>:</p> <pre><code>from fastcrud import FastCRUD\n\nuser_crud = FastCRUD(User)\n</code></pre> <p>But you also may want a more robust typing, for that purpose, you may also pass the relevant pydantic schemas in the following way:</p> Simplified <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <pre><code>from .user.model import User\nfrom .user.schemas import CreateUserSchema, ReadUserSchema, UpdateUserSchema, DeleteUserSchema\n\n# Just pass None if you don't have one of the schemas\nUserCRUD = FastCRUD[User, CreateUserSchema, UpdateUserSchema, None, DeleteUserSchema]\n</code></pre> <p>Then you can initialize <code>UserCRUD</code> like you would any <code>FastCRUD</code> instance, but with the relevant types:</p> <pre><code>from .user.model import User\n\nuser_crud = UserCRUD(User)\n</code></pre>"},{"location":"advanced/crud/#allow-multiple-updates-and-deletes","title":"Allow Multiple Updates and Deletes","text":"<p>One of FastCRUD's advanced features is the ability to update or delete multiple records at once based on specified conditions. This is particularly useful for batch operations where you need to modify or remove several records that match certain criteria.</p>"},{"location":"advanced/crud/#updating-multiple-records","title":"Updating Multiple Records","text":"<p>To update multiple records, you can set the <code>allow_multiple=True</code> parameter in the <code>update</code> method. This allows FastCRUD to apply the update to all records matching the given filters.</p> <pre><code># Assuming setup for FastCRUD instance `item_crud` and SQLAlchemy async session `db`\n\n# Update all items priced below $10 to a new price\nawait item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    allow_multiple=True,\n    price__lt=10,\n)\n</code></pre>"},{"location":"advanced/crud/#deleting-multiple-records","title":"Deleting Multiple Records","text":"<p>Similarly, you can delete multiple records by using the <code>allow_multiple=True</code> parameter in the <code>delete</code> or <code>db_delete</code> method, depending on whether you're performing a soft or hard delete.</p> <pre><code># Soft delete all items not sold in the last year\nawait item_crud.delete(\n    db=db,\n    allow_multiple=True,\n    last_sold__lt=datetime.datetime.now() - datetime.timedelta(days=365),\n)\n</code></pre>"},{"location":"advanced/crud/#advanced-filters","title":"Advanced Filters","text":"<p>FastCRUD supports advanced filtering options, allowing you to query records using operators such as greater than (<code>__gt</code>), less than (<code>__lt</code>), and their inclusive counterparts (<code>__gte</code>, <code>__lte</code>). These filters can be used in any method that retrieves or operates on records, including <code>get</code>, <code>get_multi</code>, <code>exists</code>, <code>count</code>, <code>update</code>, and <code>delete</code>.</p>"},{"location":"advanced/crud/#single-parameter-filters","title":"Single parameter filters","text":"<p>Most filter operators require a single string or integer value.</p> <pre><code># Fetch items priced between above $5\nitems = await item_crud.get_multi(\n    db=db,\n    price__gte=5,\n)\n</code></pre> <p>Currently supported single parameter filters are:</p> <ul> <li><code>__gt</code> - greater than</li> <li><code>__lt</code> - less than</li> <li><code>__gte</code> - greater than or equal to</li> <li><code>__lte</code> - less than or equal to</li> <li><code>__ne</code> - not equal</li> <li><code>__is</code> - used to test True, False and None identity</li> <li><code>__is_not</code> - negation of \"is\"</li> <li><code>__like</code> - SQL \"like\" search for specific text pattern</li> <li><code>__notlike</code> - negation of \"like\"</li> <li><code>__ilike</code> - case insensitive \"like\"</li> <li><code>__notilike</code> - case insensitive \"notlike\"</li> <li><code>__startswith</code> - text starts with given string</li> <li><code>__endswith</code> - text ends with given string</li> <li><code>__contains</code> - text contains given string</li> <li><code>__match</code> - database-specific match expression</li> </ul>"},{"location":"advanced/crud/#complex-parameter-filters","title":"Complex parameter filters","text":"<p>Some operators require multiple values. They must be passed as a python tuple, list or set.</p> <pre><code># Fetch items priced between $5 and $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__between=(5, 20),\n)\n</code></pre> <ul> <li><code>__between</code> - between 2 numeric values</li> <li><code>__in</code> - included in</li> <li><code>__not_in</code> - not included in</li> </ul>"},{"location":"advanced/crud/#or-clauses","title":"OR clauses","text":"<p>More complex OR filters are supported. They must be passed as dictionary, where each key is a library-supported operator to be used in OR expression and values is what get's passed as the parameter.</p> <pre><code># Fetch items priced under $5 or above $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__or={'lt': 5, 'gt': 20},\n)\n</code></pre>"},{"location":"advanced/crud/#and-clauses","title":"AND clauses","text":"<p>AND clauses can be achieved by chaining multiple filters together.</p> <pre><code># Fetch items priced under $20 and over 2 years of warranty.\nitems = await item_crud.get_multi(\n    db=db,\n    price__lt=20,\n    warranty_years__gt=2,\n)\n</code></pre>"},{"location":"advanced/crud/#counting-records","title":"Counting Records","text":"<pre><code># Count items created in the last month\nitem_count = await item_crud.count(\n    db=db,\n    created_at__gte=datetime.datetime.now() - datetime.timedelta(days=30),\n)\n</code></pre>"},{"location":"advanced/crud/#skipping-database-commit","title":"Skipping Database Commit","text":"<p>For <code>create</code>, <code>update</code>, <code>db_delete</code> and <code>delete</code> methods of <code>FastCRUD</code>, you have the option of passing <code>commit=False</code> so you don't commit the operations immediately.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\n\nitem_crud = FastCRUD(Item)\n\nawait item_crud.delete(\n    db=db, \n    commit=False, \n    id=1,\n)\n# this will not actually delete until you run a db.commit()\n</code></pre>"},{"location":"advanced/crud/#returning-clause-in-update","title":"Returning clause in <code>update</code>","text":"<p>In <code>update</code> method, you can pass <code>return_columns</code> parameter containing a list of columns you want to return after the update.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\n\nitem_crud = FastCRUD(Item)\n\nitem = await item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    return_columns=[\"price\"],\n    price__lt=10,\n)\n# this will return the updated price\n</code></pre> <p>You can also pass <code>schema_to_select</code> parameter and <code>return_as_model</code> to return the updated data in the form of a Pydantic schema.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Base, Item\nfrom .item.schemas import ItemSchema\n\nitem_crud = FastCRUD(Item)\n\nitem = await item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n    price__lt=10,\n)\n# this will return the updated data in the form of ItemSchema\n</code></pre>"},{"location":"advanced/crud/#unpaginated-get_multi-and-get_multi_joined","title":"Unpaginated <code>get_multi</code> and <code>get_multi_joined</code>","text":"<p>If you pass <code>None</code> to <code>limit</code> in <code>get_multi</code> and <code>get_multi_joined</code>, you get the whole unpaginated set of data that matches the filters. Use this with caution.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\n\nitem_crud = FastCRUD(Item)\n\nitems = await item_crud.get_multi(db=db, limit=None)\n# this will return all items in the db\n</code></pre> <p>Caution</p> <p>Be cautious when returning all the data in your database, and you should almost never allow your user API to do this.</p>"},{"location":"advanced/crud/#using-get_joined-and-get_multi_joined-for-multiple-models","title":"Using <code>get_joined</code> and <code>get_multi_joined</code> for multiple models","text":"<p>To facilitate complex data relationships, <code>get_joined</code> and <code>get_multi_joined</code> can be configured to handle joins with multiple models. This is achieved using the <code>joins_config</code> parameter, where you can specify a list of <code>JoinConfig</code> instances, each representing a distinct join configuration.</p>"},{"location":"advanced/crud/#upserting-multiple-records-using-upsert_multi","title":"Upserting multiple records using <code>upsert_multi</code>","text":"<p>FastCRUD provides an <code>upsert_multi</code> method to efficiently upsert multiple records in a single operation. This method is particularly useful when you need to insert new records or update existing ones based on a unique constraint.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\nfrom .item.schemas import CreateItemSchema, ItemSchema\n\nitem_crud = FastCRUD(Item)\nitems = await item_crud.upsert_multi(\n    db=db,\n    instances=[\n        CreateItemSchema(price=9.99),\n    ],\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n)\n# this will return the upserted data in the form of ItemSchema\n</code></pre>"},{"location":"advanced/crud/#customizing-the-update-logic","title":"Customizing the Update Logic","text":"<p>To allow more granular control over the SQL <code>UPDATE</code> operation during an upsert, <code>upsert_multi</code> can accept an <code>update_override</code> argument. This allows for the specification of custom update logic using SQL expressions, like the <code>case</code> statement, to handle complex conditions.</p> <pre><code>from sqlalchemy.sql import case\n\nupdate_override = {\n    \"name\": case(\n        (Item.name.is_(None), stmt.excluded.name),\n        else_=Item.name\n    )\n}\n\nitems = await item_crud.upsert_multi(\n    db=db,\n    instances=[\n        CreateItemSchema(name=\"Gadget\", price=15.99),\n    ],\n    update_override=update_override,\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n)\n</code></pre> <p>In the example above, the <code>name</code> field of the <code>Item</code> model will be updated to the new value only if the existing <code>name</code> field is <code>None</code>. Otherwise, it retains the existing <code>name</code>.</p>"},{"location":"advanced/crud/#example-joining-user-tier-and-department-models","title":"Example: Joining <code>User</code>, <code>Tier</code>, and <code>Department</code> Models","text":"<p>Consider a scenario where you want to retrieve users along with their associated tier and department information. Here's how you can achieve this using <code>get_multi_joined</code>.</p> <p>Start by creating the models and schemas, followed by a description of how they're to be joined:</p> Models and Schemas <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>tier/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadTierSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>department/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadDepartmentSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>story/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadStorySchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteStorySchema(BaseModel):\n    pass\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre> <code>task/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass ReadTaskSchema(BaseModel):\n    id: int\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass UpdateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass DeleteTaskSchema(BaseModel):\n    pass\n</code></pre> Join Configurations<pre><code>from fastcrud import JoinConfig\n\njoins_config = [\n    JoinConfig(\n        model=Tier,\n        join_on=User.tier_id == Tier.id,\n        join_prefix=\"tier_\",\n        schema_to_select=ReadTierSchema,\n        join_type=\"left\",\n    ),\n\n    JoinConfig(\n        model=Department,\n        join_on=User.department_id == Department.id,\n        join_prefix=\"dept_\",\n        schema_to_select=ReadDepartmentSchema,\n        join_type=\"inner\",\n    ),\n]\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc',\n    joins_config=joins_config,\n)\n</code></pre> <p>Then just pass this list to <code>joins_config</code>:</p> Passing to get_multi_joined<pre><code>from fastcrud import JoinConfig\n\njoins_config = [\n    ...\n]\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc',\n    joins_config=joins_config,\n)\n</code></pre> <p>In this example, users are joined with the <code>Tier</code> and <code>Department</code> models. The <code>join_on</code> parameter specifies the condition for the join, <code>join_prefix</code> assigns a prefix to columns from the joined models (to avoid naming conflicts), and <code>join_type</code> determines whether it's a left or inner join.</p> <p>Warning</p> <p>If both single join parameters and <code>joins_config</code> are used simultaneously, an error will be raised.</p>"},{"location":"advanced/crud/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through its <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"advanced/crud/#one-to-one-joins","title":"One-to-One Joins","text":"<p>One-to-one relationships can be efficiently managed using either <code>get_joined</code> or <code>get_multi_joined</code>. The <code>get_joined</code> method is typically used when you want to fetch a single record from the database along with its associated record from another table, such as a user and their corresponding profile details. If you're retrieving multiple records, <code>get_multi_joined</code> can also be used for one-to-one joins. The parameter that deals with it, <code>relationship_type</code>, defaults to <code>one-on-one</code>.</p>"},{"location":"advanced/crud/#one-to-many-joins","title":"One-to-Many Joins","text":"<p>For one-to-many relationships, where a single record can be associated with multiple records in another table, <code>get_joined</code> can be used with <code>nest_joins</code> set to <code>True</code>. This setup allows the primary record to include a nested list of associated records, making it suitable for scenarios such as retrieving a user and all their blog posts. Alternatively, <code>get_multi_joined</code> is also applicable here for fetching multiple primary records, each with their nested lists of related records.</p> <p>Warning</p> <p>When using <code>nested_joins=True</code>, the performance will always be a bit worse than when using <code>nested_joins=False</code>. For cases where more performance is necessary, consider using <code>nested_joins=False</code> and remodeling your database.</p>"},{"location":"advanced/crud/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul>"},{"location":"advanced/crud/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>For a more detailed explanation, you may check the joins docs.</p>"},{"location":"advanced/crud/#using-aliases","title":"Using aliases","text":"<p>In complex query scenarios, particularly when you need to join a table to itself or perform multiple joins on the same table for different purposes, aliasing becomes crucial. Aliasing allows you to refer to the same table in different contexts with unique identifiers, avoiding conflicts and ambiguity in your queries.</p> <p>For both <code>get_joined</code> and <code>get_multi_joined</code> methods, when you need to join the same model multiple times, you can utilize the <code>alias</code> parameter within your <code>JoinConfig</code> to differentiate between the joins. This parameter expects an instance of <code>AliasedClass</code>, which can be created using the <code>aliased</code> function from SQLAlchemy (also in FastCRUD for convenience).</p>"},{"location":"advanced/crud/#example-joining-the-same-model-multiple-times","title":"Example: Joining the Same Model Multiple Times","text":"<p>Consider a task management application where tasks have both an owner and an assigned user, represented by the same <code>User</code> model. To fetch tasks with details of both users, we use aliases to join the <code>User</code> model twice, distinguishing between owners and assigned users.</p> <p>Let's start by creating the aliases and passing them to the join configuration. Don't forget to use the alias for <code>join_on</code>:</p> Join Configurations with Aliases<pre><code>from fastcrud import FastCRUD, JoinConfig, aliased\n\n# Create aliases for User to distinguish between the owner and the assigned user\nowner_alias = aliased(User, name=\"owner\")\nassigned_user_alias = aliased(User, name=\"assigned_user\")\n\n# Configure joins with aliases\njoins_config = [\n    JoinConfig(\n        model=User,\n        join_on=Task.owner_id == owner_alias.id,\n        join_prefix=\"owner_\",\n        schema_to_select=ReadUserSchema,\n        join_type=\"inner\",\n        alias=owner_alias,  # Pass the aliased class instance\n    ),\n    JoinConfig(\n        model=User,\n        join_on=Task.assigned_user_id == assigned_user_alias.id,\n        join_prefix=\"assigned_\",\n        schema_to_select=ReadUserSchema,\n        join_type=\"inner\",\n        alias=assigned_user_alias,  # Pass the aliased class instance\n    ),\n]\n\n# Initialize your FastCRUD instance for Task\ntask_crud = FastCRUD(Task)\n\n# Fetch tasks with joined user details\ntasks = await task_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadTaskSchema,\n    offset=0,\n    limit=10,\n    joins_config=joins_config,\n)\n</code></pre> <p>Then just pass this <code>joins_config</code> to <code>get_multi_joined</code>:</p> Passing joins_config to get_multi_joined<pre><code>from fastcrud import FastCRUD, JoinConfig, aliased\n\n...\n\n# Configure joins with aliases\njoins_config = [\n    ...\n]\n\n# Initialize your FastCRUD instance for Task\ntask_crud = FastCRUD(Task)\n\n# Fetch tasks with joined user details\ntasks = await task_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadTaskSchema,\n    offset=0,\n    limit=10,\n    joins_config=joins_config,\n)\n</code></pre> <p>In this example, <code>owner_alias</code> and <code>assigned_user_alias</code> are created from <code>User</code> to distinguish between the task's owner and the assigned user within the task management system. By using aliases, you can join the same model multiple times for different purposes in your queries, enhancing expressiveness and eliminating ambiguity.</p>"},{"location":"advanced/crud/#many-to-many-relationships-with-get_multi_joined","title":"Many-to-Many Relationships with <code>get_multi_joined</code>","text":"<p>FastCRUD simplifies dealing with many-to-many relationships by allowing easy fetch operations with joined models. Here, we demonstrate using <code>get_multi_joined</code> to handle a many-to-many relationship between <code>Project</code> and <code>Participant</code> models, linked through an association table.</p> <p>Note on Handling Many-to-Many Relationships:</p> <p>When using <code>get_multi_joined</code> for many-to-many relationships, it's essential to maintain a specific order in your <code>joins_config</code>: </p> <ol> <li>First, specify the main table you're querying from.</li> <li>Next, include the association table that links your main table to the other table involved in the many-to-many relationship.</li> <li>Finally, specify the other table that is connected via the association table.</li> </ol> <p>This order ensures that the SQL joins are structured correctly to reflect the many-to-many relationship and retrieve the desired data accurately.</p> <p>Tip</p> <p>Note that the first one can be the model defined in <code>FastCRUD(Model)</code>.</p> Models <pre><code>class Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre> <pre><code># Fetch projects with their participants via a many-to-many relationship\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_prefix=\"pp_\",\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_prefix=\"participant_\",\n        join_type=\"inner\",\n    ),\n]\n\nproject_crud = FastCRUD(Project)\n\nclass ReadProjectSchema(BaseModel):\n    id: int\n    name: str\n    description: Optional[str] = None\n\nprojects_with_participants = await project_crud.get_multi_joined(\n    db=db,\n    schema_to_select=ReadProjectSchema,\n    joins_config=joins_config,\n)\n</code></pre> <p>For a more detailed explanation, read this part of the docs.</p>"},{"location":"advanced/crud/#enhanced-query-capabilities-with-method-chaining","title":"Enhanced Query Capabilities with Method Chaining","text":"<p>The <code>select</code> method in FastCRUD is designed for flexibility, enabling you to build complex queries through method chaining.</p>"},{"location":"advanced/crud/#the-select-method","title":"The <code>select</code> Method","text":"<pre><code>async def select(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any\n) -&gt; Selectable\n</code></pre> <p>This method constructs a SQL Alchemy <code>Select</code> statement, offering optional column selection, filtering, and sorting. It's designed for flexibility, allowing you to chain additional SQLAlchemy methods for even more complex queries.</p>"},{"location":"advanced/crud/#features","title":"Features:","text":"<ul> <li>Column Selection: Specify columns with a Pydantic schema.</li> <li>Sorting: Define one or more columns for sorting, along with their sort order.</li> <li>Filtering: Apply filters directly through keyword arguments.</li> <li>Chaining: Chain with other SQLAlchemy methods for advanced query construction.</li> </ul>"},{"location":"advanced/crud/#usage-example","title":"Usage Example:","text":"<pre><code>class ReadMyModelSchema(BaseModel):\n    id: int\n    name: str | None = None\n    archived: bool\n    archived_at: datetime.datetime\n    date_updated: datetime.datetime\n\n\nstmt = await my_model_crud.select(\n    schema_to_select=ReadMyModelSchema,\n    sort_columns='name',\n    name__like='%example%',\n)\nstmt = stmt.where(additional_conditions).limit(10)\nresults = await db.execute(stmt)\n</code></pre> <p>This example demonstrates selecting a subset of columns, applying a filter, and chaining additional conditions like <code>where</code> and <code>limit</code>. Note that <code>select</code> returns a <code>Select</code> object, allowing for further modifications before execution.</p>"},{"location":"advanced/crud/#conclusion","title":"Conclusion","text":"<p>The advanced features of FastCRUD, such as <code>allow_multiple</code> and support for advanced filters, empower developers to efficiently manage database records with complex conditions. By leveraging these capabilities, you can build more dynamic, robust, and scalable FastAPI applications that effectively interact with your data model.</p>"},{"location":"advanced/endpoint/","title":"Advanced Use of EndpointCreator","text":""},{"location":"advanced/endpoint/#available-automatic-endpoints","title":"Available Automatic Endpoints","text":"<p>FastCRUD automates the creation of CRUD (Create, Read, Update, Delete) endpoints for your FastAPI application. Here's an overview of the available automatic endpoints and how they work, based on the automatic endpoints we've generated before:</p>"},{"location":"advanced/endpoint/#create","title":"Create","text":"<ul> <li>Endpoint: <code>/{model}</code></li> <li>Method: <code>POST</code></li> <li>Description: Creates a new item in the database.</li> <li>Request Body: JSON object based on the <code>create_schema</code>.</li> <li>Example Request: <code>POST /items</code> with JSON body.</li> </ul>"},{"location":"advanced/endpoint/#read","title":"Read","text":"<ul> <li>Endpoint: <code>/{model}/{id}</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves a single item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to retrieve.</li> <li>Example Request: <code>GET /items/1</code>.</li> <li>Example Return: <pre><code>{\n    \"id\": 1,\n    \"name\": \"Item 1\",\n    \"description\": \"Description of item 1\",\n    \"category\": \"Movies\",\n    \"price\": 5.99,\n    \"last_sold\": null,\n    \"created_at\": \"2024-01-01 12:00:00\"\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#read-multiple","title":"Read Multiple","text":"<ul> <li>Endpoint: <code>/{model}</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves multiple items with optional pagination.</li> <li>Query Parameters:<ul> <li><code>offset</code> (optional): The offset from where to start fetching items.</li> <li><code>limit</code> (optional): The maximum number of items to return.</li> <li><code>page</code> (optional): The page number, starting from 1.</li> <li><code>itemsPerPage</code> (optional): The number of items per page.</li> </ul> </li> <li>Example Request: <code>GET /items?offset=3&amp;limit=4</code>.</li> <li>Example Return: <pre><code>{\n  \"data\": [\n    {\n        \"id\": 4,\n        \"name\": \"Item 4\",\n        \"description\": \"Description of item 4\",\n        \"category\": \"Books\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:01:00\"\n    },\n    {\n        \"id\": 5,\n        \"name\": \"Item 5\",\n        \"description\": \"Description of item 5\",\n        \"category\": \"Music\",\n        \"price\": 5.99,\n        \"last_sold\": \"2024-04-01 00:00:00\",\n        \"created_at\": \"2024-01-01 12:10:00\"\n    },\n    {\n        \"id\": 6,\n        \"name\": \"Item 6\",\n        \"description\": \"Description of item 6\",\n        \"category\": \"TV\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:15:00\"\n    },\n    {\n        \"id\": 7,\n        \"name\": \"Item 7\",\n        \"description\": \"Description of item 7\",\n        \"category\": \"Books\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 13:00:30\"\n    }\n  ],\n  \"total_count\": 50\n}\n</code></pre></li> <li>Example Paginated Request: <code>GET /items?page=1&amp;itemsPerPage=3</code>.</li> <li>Example Paginated Return: <pre><code>{\n  \"data\": [\n    {\n        \"id\": 1,\n        \"name\": \"Item 1\",\n        \"description\": \"Description of item 1\",\n        \"category\": \"Movies\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:00:01\"\n    },\n    {\n        \"id\": 2,\n        \"name\": \"Item 2\",\n        \"description\": \"Description of item 2\",\n        \"category\": \"TV\",\n        \"price\": 19.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:00:15\"\n    },\n    {\n        \"id\": 3,\n        \"name\": \"Item 3\",\n        \"description\": \"Description of item 3\",\n        \"category\": \"Books\",\n        \"price\": 4.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:00:16\"\n    }\n  ],\n  \"total_count\": 50,\n  \"has_more\": true,\n  \"page\": 1,\n  \"items_per_page\": 3\n}\n</code></pre></li> </ul> <p>Note</p> <p><code>_read_paginated</code> endpoint was deprecated and mixed into <code>_read_items</code> in the release <code>0.15.0</code>. Simple <code>_read_items</code> behaviour persists with no breaking changes.</p> <p>Read items paginated: <pre><code>$ curl -X 'GET' \\\n  'http://localhost:8000/users?page=2&amp;itemsPerPage=10' \\\n  -H 'accept: application/json'\n</code></pre></p> <p>Read items unpaginated: <pre><code>$ curl -X 'GET' \\\n  'http://localhost:8000/users?offset=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre></p>"},{"location":"advanced/endpoint/#update","title":"Update","text":"<ul> <li>Endpoint: <code>/{model}/{id}</code></li> <li>Method: <code>PATCH</code></li> <li>Description: Updates an existing item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to update.</li> <li>Request Body: JSON object based on the <code>update_schema</code>.</li> <li>Example Request: <code>PATCH /items/1</code> with JSON body.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#delete","title":"Delete","text":"<ul> <li>Endpoint: <code>/{model}/{id}</code></li> <li>Method: <code>DELETE</code></li> <li>Description: Deletes (soft delete if configured) an item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to delete.</li> <li>Example Request: <code>DELETE /items/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#db-delete-hard-delete","title":"DB Delete (Hard Delete)","text":"<ul> <li>Endpoint: <code>/{model}/db_delete/{id}</code> (Available if a <code>delete_schema</code> is provided)</li> <li>Method: <code>DELETE</code></li> <li>Description: Permanently deletes an item by its ID, bypassing the soft delete mechanism.</li> <li>Path Parameters: <code>id</code> - The ID of the item to hard delete.</li> <li>Example Request: <code>DELETE /items/db_delete/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>You can control which CRUD operations are exposed by using <code>included_methods</code> and <code>deleted_methods</code>. These parameters allow you to specify exactly which CRUD methods should be included or excluded when setting up the router. By default, all CRUD endpoints are included.</p> <code>mymodel/model.py</code> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>mymodel/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass UpdateMyModelSchema(BaseModel):\n    name: str | None = None\n</code></pre>"},{"location":"advanced/endpoint/#using-included_methods","title":"Using <code>included_methods</code>","text":"<p>Using <code>included_methods</code> you may define exactly the methods you want to be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=FastCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"],  # Only these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#using-deleted_methods","title":"Using <code>deleted_methods</code>","text":"<p>Using <code>deleted_methods</code> you define the methods that will not be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=FastCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    deleted_methods=[\"update\", \"delete\"],  # All but these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre> <p>Warning</p> <p>If <code>included_methods</code> and <code>deleted_methods</code> are both provided, a <code>ValueError</code> will be raised.</p>"},{"location":"advanced/endpoint/#customizing-endpoint-names","title":"Customizing Endpoint Names","text":"<p>You can customize the names of the auto generated endpoints by passing an <code>endpoint_names</code> dictionary when initializing the <code>EndpointCreator</code> or calling the <code>crud_router</code> function. This dictionary should map the CRUD operation names (<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>db_delete</code>, <code>read_multi</code>) to your desired endpoint names.</p>"},{"location":"advanced/endpoint/#example-using-crud_router","title":"Example: Using <code>crud_router</code>","text":"<p>Here's how you can customize endpoint names using the <code>crud_router</code> function:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\n\n# Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add\",\n    \"read\": \"fetch\",\n    \"update\": \"modify\",\n    \"delete\": \"remove\",\n    \"read_multi\": \"list\",\n}\n\n# Setup CRUD router with custom endpoint names\napp.include_router(crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names=custom_endpoint_names,\n))\n</code></pre> <p>In this example, the standard CRUD endpoints will be replaced with <code>/add</code>, <code>/fetch/{id}</code>, <code>/modify/{id}</code>, <code>/remove/{id}</code>, <code>/list</code>, and <code>/paginate</code>.</p>"},{"location":"advanced/endpoint/#example-using-endpointcreator","title":"Example: Using <code>EndpointCreator</code>","text":"<p>If you are using <code>EndpointCreator</code>, you can also pass the <code>endpoint_names</code> dictionary to customize the endpoint names similarly:</p> <pre><code># Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add_new\",\n    \"read\": \"get_single\",\n    \"update\": \"change\",\n    \"delete\": \"erase\",\n    \"db_delete\": \"hard_erase\",\n    \"read_multi\": \"get_all\",\n    \"read_paginated\": \"get_page\",\n}\n\n# Initialize and use the custom EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names=custom_endpoint_names,\n)\n\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router)\n</code></pre> <p>Tip</p> <p>You only need to pass the names of the endpoints you want to change in the <code>endpoint_names</code> <code>dict</code>.</p> <p>Note</p> <p><code>default_endpoint_names</code> for <code>EndpointCreator</code> were changed to empty strings in <code>0.15.0</code>. See this issue for more details.</p>"},{"location":"advanced/endpoint/#extending-endpointcreator","title":"Extending <code>EndpointCreator</code>","text":"<p>You can create a subclass of <code>EndpointCreator</code> and override or add new methods to define custom routes. Here's an example:</p>"},{"location":"advanced/endpoint/#creating-a-custom-endpointcreator","title":"Creating a Custom <code>EndpointCreator</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#adding-custom-routes","title":"Adding custom routes","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#overriding-add_routes_to_router","title":"Overriding <code>add_routes_to_router</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<pre><code># Assuming MyCustomEndpointCreator was created\n\n...\n\n# Use the custom EndpointCreator with crud_router\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=FastCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"],  # Including selective methods\n    endpoint_creator=MyCustomEndpointCreator,\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#custom-soft-delete","title":"Custom Soft Delete","text":"<p>To implement custom soft delete columns using <code>EndpointCreator</code> and <code>crud_router</code> in FastCRUD, you need to specify the names of the columns used for indicating deletion status and the deletion timestamp in your model. FastCRUD provides flexibility in handling soft deletes by allowing you to configure these column names directly when setting up CRUD operations or API endpoints.</p> <p>Here's how to specify custom soft delete columns when utilizing <code>EndpointCreator</code> and <code>crud_router</code>:</p>"},{"location":"advanced/endpoint/#defining-models-with-custom-soft-delete-columns","title":"Defining Models with Custom Soft Delete Columns","text":"<p>First, ensure your SQLAlchemy model is equipped with the custom soft delete columns. Here's an example model with custom columns for soft deletion:</p> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)  # Custom soft delete column\n    archived_at = Column(DateTime)  # Custom timestamp column for soft delete\n</code></pre> <p>And a schema necessary to activate the soft delete endpoint:</p> <pre><code>class DeleteMyModelSchema(BaseModel):\n    pass\n</code></pre>"},{"location":"advanced/endpoint/#using-endpointcreator-and-crud_router-with-custom-soft-delete-or-update-columns","title":"Using <code>EndpointCreator</code> and <code>crud_router</code> with Custom Soft Delete or Update Columns","text":"<p>When initializing <code>crud_router</code> or creating a custom <code>EndpointCreator</code>, you can pass the names of your custom soft delete columns through the <code>FastCRUD</code> initialization. This informs FastCRUD which columns to check and update for soft deletion operations.</p> <p>Here's an example of using <code>crud_router</code> with custom soft delete columns:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\napp = FastAPI()\n\n# Assuming async_session is your AsyncSession generator\n# and MyModel is your SQLAlchemy model\n\n# Initialize FastCRUD with custom soft delete columns\nmy_model_crud = FastCRUD(\n    MyModel,\n    is_deleted_column='archived',  # Custom 'is_deleted' column name\n    deleted_at_column='archived_at',  # Custom 'deleted_at' column name\n)\n\n# Setup CRUD router with the FastCRUD instance\napp.include_router(crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=my_model_crud,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n))\n</code></pre> <p>You may also directly pass the names of the columns to <code>crud_router</code> or <code>EndpointCreator</code>:</p> <pre><code>app.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    is_deleted_column='archived',\n    deleted_at_column='archived_at',\n))\n</code></pre> <p>This setup ensures that the soft delete functionality within your application utilizes the <code>archived</code> and <code>archived_at</code> columns for marking records as deleted, rather than the default <code>is_deleted</code> and <code>deleted_at</code> fields.</p> <p>By specifying custom column names for soft deletion, you can adapt FastCRUD to fit the design of your database models, providing a flexible solution for handling deleted records in a way that best suits your application's needs.</p> <p>You can also customize your <code>updated_at</code> column:</p> <pre><code>class MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)  # Custom soft delete column\n    archived_at = Column(DateTime)  # Custom timestamp column for soft delete\n    date_updated = Column(DateTime)  # Custom timestamp column for update\n\n\napp.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    is_deleted_column='archived',\n    deleted_at_column='archived_at',\n    updated_at_column='date_updated',\n))\n</code></pre>"},{"location":"advanced/endpoint/#using-filters-in-fastcrud","title":"Using Filters in FastCRUD","text":"<p>FastCRUD provides filtering capabilities, allowing you to filter query results based on various conditions. Filters can be applied to <code>read_multi</code> endpoint. This section explains how to configure and use filters in FastCRUD.</p>"},{"location":"advanced/endpoint/#defining-filters","title":"Defining Filters","text":"<p>Filters are either defined using the <code>FilterConfig</code> class or just passed as a dictionary. This class allows you to specify default filter values and validate filter types. Here's an example of how to define filters for a model:</p> <pre><code>from fastcrud import FilterConfig\n\n# Define filter configuration for a model\nfilter_config = FilterConfig(\n    tier_id=None,  # Default filter value for tier_id\n    name=None,  # Default filter value for name\n)\n</code></pre> <p>And the same thing using a <code>dict</code>: <pre><code>filter_config = {\n    \"tier_id\": None,  # Default filter value for tier_id\n    \"name\": None,  # Default filter value for name\n}\n</code></pre></p> <p>By using <code>FilterConfig</code> you get better error messages.</p>"},{"location":"advanced/endpoint/#applying-filters-to-endpoints","title":"Applying Filters to Endpoints","text":"<p>You can apply filters to your endpoints by passing the <code>filter_config</code> to the <code>crud_router</code> or <code>EndpointCreator</code>. Here's an example:</p> <pre><code>from fastcrud import crud_router\n\nfrom .database import async_session\nfrom .yourmodel.model import YourModel\nfrom .yourmodel.schemas import CreateYourModelSchema, UpdateYourModelSchema\n\n# Apply filters using crud_router\napp.include_router(\n    crud_router(\n        session=async_session,\n        model=YourModel,\n        create_schema=CreateYourModelSchema,\n        update_schema=UpdateYourModelSchema,\n        path=\"/yourmodel\",\n        tags=[\"YourModel\"],\n        filter_config=filter_config,  # Apply the filter configuration\n    ),\n)\n</code></pre>"},{"location":"advanced/endpoint/#using-filters-in-requests","title":"Using Filters in Requests","text":"<p>Once filters are configured, you can use them in your API requests. Filters are passed as query parameters. Here's an example of how to use filters in a request to a paginated endpoint:</p> <pre><code>GET /yourmodel?page=1&amp;itemsPerPage=3&amp;tier_id=1&amp;name=Alice\n</code></pre>"},{"location":"advanced/endpoint/#custom-filter-validation","title":"Custom Filter Validation","text":"<p>The <code>FilterConfig</code> class includes a validator to check filter types. If an invalid filter type is provided, a <code>ValueError</code> is raised. You can customize the validation logic by extending the <code>FilterConfig</code> class:</p> <pre><code>from fastcrud import FilterConfig\nfrom pydantic import ValidationError\n\nclass CustomFilterConfig(FilterConfig):\n    @field_validator(\"filters\")\n    def check_filter_types(cls, filters: dict[str, Any]) -&gt; dict[str, Any]:\n        for key, value in filters.items():\n            if not isinstance(value, (type(None), str, int, float, bool)):\n                raise ValueError(f\"Invalid default value for '{key}': {value}\")\n        return filters\n\ntry:\n    # Example of invalid filter configuration\n    invalid_filter_config = CustomFilterConfig(invalid_field=[])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"advanced/endpoint/#handling-invalid-filter-columns","title":"Handling Invalid Filter Columns","text":"<p>FastCRUD ensures that filters are applied only to valid columns in your model. If an invalid filter column is specified, a <code>ValueError</code> is raised:</p> <pre><code>try:\n    # Example of invalid filter column\n    invalid_filter_config = FilterConfig(non_existent_column=None)\nexcept ValueError as e:\n    print(e)  # Output: Invalid filter column 'non_existent_column': not found in model\n</code></pre>"},{"location":"advanced/endpoint/#conclusion","title":"Conclusion","text":"<p>The <code>EndpointCreator</code> class in FastCRUD offers flexibility and control over CRUD operations and custom endpoint creation. By extending this class or using the <code>included_methods</code> and <code>deleted_methods</code> parameters, you can tailor your API's functionality to your specific requirements, ensuring a more customizable and streamlined experience.</p>"},{"location":"advanced/filters/","title":"Advanced Filtering","text":"<p>The <code>_parse_filters</code> method in FastCRUD supports complex filtering operations including OR and NOT conditions.</p>"},{"location":"advanced/filters/#basic-usage","title":"Basic Usage","text":"<p>Filters are specified as keyword arguments in the format <code>field_name__operator=value</code>:</p> <pre><code># Simple equality filter\nresults = await crud.get_multi(db, name=\"John\")\n\n# Comparison operators\nresults = await crud.get_multi(db, age__gt=18)\n</code></pre>"},{"location":"advanced/filters/#or-operations","title":"OR Operations","text":"<p>Use the <code>__or</code> suffix to apply multiple conditions to the same field with OR logic:</p> <pre><code># Find users aged under 18 OR over 65\nresults = await crud.get_multi(\n    db,\n    age__or={\n        \"lt\": 18,\n        \"gt\": 65\n    }\n)\n# Generates: WHERE age &lt; 18 OR age &gt; 65\n</code></pre>"},{"location":"advanced/filters/#not-operations","title":"NOT Operations","text":"<p>Use the <code>__not</code> suffix to negate multiple conditions on the same field:</p> <pre><code># Find users NOT aged 20 AND NOT between 30-40\nresults = await crud.get_multi(\n    db,\n    age__not={\n        \"eq\": 20,\n        \"between\": (30, 40)\n    }\n)\n# Generates: WHERE NOT age = 20 AND NOT (age BETWEEN 30 AND 40)\n</code></pre>"},{"location":"advanced/filters/#supported-operators","title":"Supported Operators","text":"<ul> <li>Comparison: <code>eq</code>, <code>gt</code>, <code>lt</code>, <code>gte</code>, <code>lte</code>, <code>ne</code></li> <li>Null checks: <code>is</code>, <code>is_not</code></li> <li>Text matching: <code>like</code>, <code>notlike</code>, <code>ilike</code>, <code>notilike</code>, <code>startswith</code>, <code>endswith</code>, <code>contains</code>, <code>match</code></li> <li>Collections: <code>in</code>, <code>not_in</code>, <code>between</code></li> <li>Logical: <code>or</code>, <code>not</code></li> </ul>"},{"location":"advanced/filters/#examples","title":"Examples","text":"<pre><code># Complex age filtering\nresults = await crud.get_multi(\n    db,\n    age__or={\n        \"between\": (20, 30),\n        \"eq\": 18\n    },\n    status__not={\n        \"in\": [\"inactive\", \"banned\"]\n    }\n)\n\n# Text search with OR conditions\nresults = await crud.get_multi(\n    db,\n    name__or={\n        \"startswith\": \"A\",\n        \"endswith\": \"smith\"\n    }\n)\n</code></pre>"},{"location":"advanced/filters/#error-handling","title":"Error Handling","text":"<ul> <li>Invalid column names raise <code>ValueError</code></li> <li>Invalid operators are ignored</li> <li>Invalid value types for operators (e.g., non-list for <code>between</code>) raise <code>ValueError</code></li> </ul>"},{"location":"advanced/joins/","title":"Comprehensive Guide to Joins in FastCRUD","text":"<p>FastCRUD simplifies CRUD operations while offering capabilities for handling complex data relationships. This guide thoroughly explores the use of <code>JoinConfig</code> for executing join operations in FastCRUD methods such as <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code>, alongside simplified join techniques for straightforward scenarios.</p>"},{"location":"advanced/joins/#understanding-joinconfig","title":"Understanding <code>JoinConfig</code>","text":"<p><code>JoinConfig</code> is a detailed configuration mechanism for specifying joins between models in FastCRUD queries. It contains the following key attributes:</p> <ul> <li><code>model</code>: The SQLAlchemy model to join.</li> <li><code>join_on</code>: The condition defining how the join connects to other models.</li> <li><code>join_prefix</code>: An optional prefix for the joined columns to avoid column name conflicts.</li> <li><code>schema_to_select</code>: An optional Pydantic schema for selecting specific columns from the joined model.</li> <li><code>join_type</code>: The type of join (e.g., <code>\"left\"</code>, <code>\"inner\"</code>).</li> <li><code>alias</code>: An optional SQLAlchemy <code>AliasedClass</code> for complex scenarios like self-referential joins or multiple joins on the same model.</li> <li><code>filters</code>: An optional dictionary to apply filters directly to the joined model.</li> <li><code>relationship_type</code>: Specifies the relationship type, such as <code>\"one-to-one\"</code> or <code>\"one-to-many\"</code>. Default is <code>\"one-to-one\"</code>.</li> </ul> <p>Tip</p> <p>For <code>\"many-to-many\"</code>, you don't need to pass a <code>relationship_type</code>.</p>"},{"location":"advanced/joins/#applying-joins-in-fastcrud-methods","title":"Applying Joins in FastCRUD Methods","text":"Models - <code>Tier</code>, <code>Department</code>, <code>User</code>, <code>Story</code>, <code>Task</code> <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre>"},{"location":"advanced/joins/#the-count-method-with-joins","title":"The <code>count</code> Method with Joins","text":"<p>The <code>count</code> method can be enhanced with join operations to perform complex aggregate queries. While <code>count</code> primarily returns the number of records matching a given condition, introducing joins allows for counting records across related models based on specific relationships and conditions.</p>"},{"location":"advanced/joins/#using-joinconfig","title":"Using <code>JoinConfig</code>","text":"<p>For join requirements, the <code>count</code> method can be invoked with join parameters passed as a list of <code>JoinConfig</code> to the <code>joins_config</code> parameter:</p> <pre><code>from fastcrud import JoinConfig\n\ntask_crud = FastCRUD(Task)\n\n# Count the number of tasks assigned to users in a specific department\ntask_count = await task_crud.count(\n    db=db,\n    joins_config=[\n        JoinConfig(\n            model=User, \n            join_on=Task.assigned_user_id == User.id,\n        ),\n        JoinConfig(\n            model=Department, \n            join_on=User.department_id == Department.id, \n            filters={\"name\": \"Engineering\"},\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/joins/#fetching-data-with-get_joined-and-get_multi_joined","title":"Fetching Data with <code>get_joined</code> and <code>get_multi_joined</code>","text":"<p>These methods are essential for retrieving records from a primary model while including related data from one or more joined models. They support both simple and complex joining scenarios, including self-referential joins and many-to-many relationships.</p>"},{"location":"advanced/joins/#simple-joins-using-base-parameters","title":"Simple Joins Using Base Parameters","text":"<p>For simpler join requirements, FastCRUD allows specifying join parameters directly:</p> <ul> <li><code>join_model</code>: The target model to join.</li> <li><code>join_on</code>: The join condition.</li> <li><code>join_prefix</code>: Optional prefix for columns from the joined model.</li> <li><code>join_schema_to_select</code>: An optional Pydantic schema for selecting specific columns from the joined model.</li> <li><code>join_type</code>: Specifies the SQL join type.</li> <li><code>alias</code>: An optional SQLAlchemy <code>AliasedClass</code> for complex scenarios like self-referential joins or multiple joins on the same model.</li> <li><code>join_filters</code>: Additional filters for the joined model.</li> </ul>"},{"location":"advanced/joins/#examples-of-simple-joining","title":"Examples of Simple Joining","text":"<pre><code># Fetch tasks with assigned user details, specifying a left join\ntasks_with_users = await task_crud.get_joined(\n    db=db,\n    join_model=User,\n    join_on=Task.assigned_user_id == User.id,\n    join_type=\"left\",\n)\n</code></pre>"},{"location":"advanced/joins/#getting-joined-data-nested","title":"Getting Joined Data Nested","text":"<p>Note that by default, <code>FastCRUD</code> joins all the data and returns it in a single dictionary.</p> <p>Let's take two of the tables from above and join them with <code>FastCRUD</code>:</p> <pre><code>user_crud = FastCRUD(User)\nuser_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    id=1,\n)\n</code></pre> <p>We'll get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre> <p>If you want the joined data in a nested dictionary instead, you may just pass <code>nest_joins=True</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>And you will get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre> <p>This works for both <code>get_joined</code> and <code>get_multi_joined</code>.</p> <p>Warning</p> <p>Note that the final <code>\"_\"</code> in the passed <code>\"tier_\"</code> is stripped.</p>"},{"location":"advanced/joins/#complex-joins-using-joinconfig","title":"Complex Joins Using <code>JoinConfig</code>","text":"<p>When dealing with more complex join conditions, such as multiple joins, self-referential joins, or needing to specify aliases and filters, <code>JoinConfig</code> instances become the norm. They offer granular control over each join's aspects, enabling precise and efficient data retrieval.</p> <p>Example:</p> <code>user/schemas.py</code> Excerpt <pre><code>class ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n</code></pre> <pre><code># Fetch users with details from related departments and tiers, using aliases for self-referential joins\nfrom fastcrud import aliased\n\nmanager_alias = aliased(User)\n\nusers = await user_crud.get_multi_joined(\n    db=db,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Department, \n            join_on=User.department_id == Department.id, \n            join_prefix=\"dept_\",\n        ),\n        JoinConfig(\n            model=Tier, \n            join_on=User.tier_id == Tier.id, \n            join_prefix=\"tier_\",\n        ),\n        JoinConfig(\n            model=User, \n            alias=manager_alias, \n            join_on=User.manager_id == manager_alias.id, \n            join_prefix=\"manager_\",\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/joins/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>\"one-to-one\"</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"advanced/joins/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul>"},{"location":"advanced/joins/#example","title":"Example","text":"<p>Let's take two of the tables from above and join them with <code>FastCRUD</code>:</p> <pre><code>user_crud = FastCRUD(User)\nuser_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    id=1,\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre>"},{"location":"advanced/joins/#one-to-one-relationship-with-nested-joins","title":"One-to-One Relationship with Nested Joins","text":"<p>To get the joined data in a nested dictionary:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre>"},{"location":"advanced/joins/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>Warning</p> <p>When using <code>nest_joins=True</code>, the performance will always be a bit worse than when using <code>nest_joins=False</code>. For cases where more performance is necessary, consider using <code>nest_joins=False</code> and remodeling your database.</p>"},{"location":"advanced/joins/#example_1","title":"Example","text":"<p>To demonstrate a one-to-many relationship, let's assume <code>Author</code> and <code>Article</code> tables:</p> <pre><code>class Author(Base):\n    __tablename__ = \"author\"\n    id = Column(Integer, primary_key=True)\n    profile_id = Column(Integer, ForeignKey(\"profile.id\"))\n    name = Column(String)\n\n\nclass Article(Base):\n    __tablename__ = \"article\"\n    id = Column(Integer, primary_key=True)\n    author_id = Column(Integer, ForeignKey(\"author.id\"))\n    title = Column(String)\n    content = Column(String)\n</code></pre> <p>Fetch a user and all their posts:</p> <pre><code>author_crud = FastCRUD(Author)\nauthor_articles = await author_crud.get_joined(\n    db=db,\n    join_model=Article,\n    join_on=Author.id == Article.author_id,\n    join_prefix=\"article_\",\n    join_type=\"left\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example Author\",\n    \"articles\": [\n        {\n            \"id\": 101,\n            \"author_id\": 1,\n            \"title\": \"First Article!\",\n            \"content\": \"First article content\"\n        },\n        {\n            \"id\": 102,\n            \"author_id\": 1,\n            \"title\": \"Second Article?\",\n            \"content\": \"Second article content\"\n        }\n    ]\n}\n</code></pre>"},{"location":"advanced/joins/#many-to-many-relationships-with-get_multi_joined","title":"Many-to-Many Relationships with <code>get_multi_joined</code>","text":"<p>FastCRUD simplifies dealing with many-to-many relationships by allowing easy fetch operations with joined models. Here, we demonstrate using <code>get_multi_joined</code> to handle a many-to-many relationship between <code>Project</code> and <code>Participant</code> models, linked through an association table.</p> <p>Note on Handling Many-to-Many Relationships:</p> <p>When using <code>get_multi_joined</code> for many-to-many relationships, it's essential to maintain a specific order in your <code>joins_config</code>: </p> <ol> <li>First, specify the main table you're querying from.</li> <li>Next, include the association table that links your main table to the other table involved in the many-to-many relationship.</li> <li>Finally, specify the other table that is connected via the association table.</li> </ol> <p>This order ensures that the SQL joins are structured correctly to reflect the many-to-many relationship and retrieve the desired data accurately.</p> <p>Tip</p> <p>Note that the first one can be the model defined in <code>FastCRUD(Model)</code>.</p>"},{"location":"advanced/joins/#scenario","title":"Scenario","text":"<p>Imagine a scenario where projects have multiple participants, and participants can be involved in multiple projects. This many-to-many relationship is facilitated through an association table.</p>"},{"location":"advanced/joins/#models","title":"Models","text":"<p>Our models include <code>Project</code>, <code>Participant</code>, and an association model <code>ProjectsParticipantsAssociation</code>:</p> Models <pre><code>class Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre>"},{"location":"advanced/joins/#fetching-data-with-get_multi_joined","title":"Fetching Data with <code>get_multi_joined</code>","text":"<p>To fetch projects along with their participants, we utilize <code>get_multi_joined</code> with appropriate <code>JoinConfig</code> settings:</p> <pre><code>from fastcrud import FastCRUD, JoinConfig\n\n# Initialize FastCRUD for the Project model\nproject_crud = FastCRUD(Project)\n\n# Define join conditions and configuration\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_prefix=\"pp_\",\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_prefix=\"participant_\",\n        join_type=\"inner\",\n    ),\n]\n\n# Fetch projects with their participants\nprojects_with_participants = await project_crud.get_multi_joined(\n    db_session, \n    joins_config=joins_config,\n)\n</code></pre> <p>Now, <code>projects_with_participants['data']</code> will contain projects along with their participant information. The full results would look like:</p> <pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"Project A\",\n            \"description\": \"Description of Project A\",\n            \"participants\": [\n                {\n                    \"id\": 1,\n                    \"name\": \"Participant 1\",\n                    \"role\": \"Developer\"\n                },\n                {\n                    \"id\": 2,\n                    \"name\": \"Participant 2\",\n                    \"role\": \"Designer\"\n                }\n            ]\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Project B\",\n            \"description\": \"Description of Project B\",\n            \"participants\": [\n                {\n                    \"id\": 3,\n                    \"name\": \"Participant 3\",\n                    \"role\": \"Manager\"\n                },\n                {\n                    \"id\": 4,\n                    \"name\": \"Participant 4\",\n                    \"role\": \"Tester\"\n                }\n            ]\n        }\n    ],\n    \"total_count\": 2\n}\n</code></pre>"},{"location":"advanced/joins/#practical-tips-for-advanced-joins","title":"Practical Tips for Advanced Joins","text":"<ul> <li>Prefixing: Always use the <code>join_prefix</code> attribute to avoid column name collisions, especially in complex joins involving multiple models or self-referential joins.</li> <li>Aliasing: Utilize the <code>alias</code> attribute for disambiguating joins on the same model or for self-referential joins.</li> <li>Filtering Joined Models: Apply filters directly to joined models using the <code>filters</code> attribute in <code>JoinConfig</code> to refine the data set returned by the query.</li> <li>Ordering Joins: In many-to-many relationships or complex join scenarios, carefully sequence your <code>JoinConfig</code> entries to ensure logical and efficient SQL join construction.</li> </ul>"},{"location":"advanced/joins/#conclusion","title":"Conclusion","text":"<p>FastCRUD's support for join operations enhances the ability to perform complex queries across related models in FastAPI applications. By understanding and utilizing the <code>JoinConfig</code> class within the <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code> methods, developers can craft powerful data retrieval queries.</p>"},{"location":"advanced/overview/","title":"Advanced Usage Overview","text":"<p>The Advanced section of our documentation delves into the sophisticated capabilities and features of our application, tailored for users looking to leverage advanced functionalities. This part of our guide aims to unlock deeper insights and efficiencies through more complex use cases and configurations.</p>"},{"location":"advanced/overview/#key-topics","title":"Key Topics","text":""},{"location":"advanced/overview/#1-advanced-filtering-and-searching","title":"1. Advanced Filtering and Searching","text":"<p>Explore how to implement advanced filtering and searching capabilities in your application. This guide covers the use of comparison operators (such as greater than, less than, etc.), pattern matching, logical operations like OR and NOT, and more to perform complex queries.</p> <ul> <li>Advanced Filtering Guide</li> <li>Legacy Filtering Options</li> </ul>"},{"location":"advanced/overview/#2-bulk-operations-and-batch-processing","title":"2. Bulk Operations and Batch Processing","text":"<p>Learn how to efficiently handle bulk operations and batch processing. This section provides insights into performing mass updates, deletes, and inserts, optimizing performance for large datasets.</p> <ul> <li>Bulk Operations Guide</li> </ul>"},{"location":"advanced/overview/#3-soft-delete-mechanisms-and-strategies","title":"3. Soft Delete Mechanisms and Strategies","text":"<p>Understand the implementation of soft delete mechanisms within our application. This guide covers configuring and using custom columns for soft deletes, restoring deleted records, and filtering queries to exclude soft-deleted entries.</p> <ul> <li>Soft Delete Strategies Guide</li> </ul>"},{"location":"advanced/overview/#4-advanced-use-of-endpointcreator-and-crud_router","title":"4. Advanced Use of EndpointCreator and crud_router","text":"<p>This topic extends the use of <code>EndpointCreator</code> and <code>crud_router</code> for advanced endpoint management, including creating custom routes, selective method exposure, and integrating soft delete functionalities.</p> <ul> <li>Advanced Endpoint Management Guide</li> </ul>"},{"location":"advanced/overview/#5-using-get_joined-and-get_multi_joined-for-multiple-models","title":"5. Using <code>get_joined</code> and <code>get_multi_joined</code> for multiple models","text":"<p>Explore the use of <code>get_joined</code> and <code>get_multi_joined</code> functions for complex queries that involve joining multiple models, including self-joins and scenarios requiring multiple joins on the same model.</p> <ul> <li>Joining Multiple Models Guide</li> </ul>"},{"location":"advanced/overview/#6-method-chaining-with-select","title":"6. Method Chaining with <code>select</code>","text":"<p>FastCRUD's <code>select</code> method introduces method chaining, allowing for the construction of detailed queries with a focus on precision. It simplifies the process of dynamically applying filters, sorting, and conditions, making it easier to manage complex query requirements.</p> <ul> <li>Method Chaining Guide</li> </ul>"},{"location":"advanced/overview/#7-in-depth-explanation-of-joined-methods","title":"7. In depth explanation of Joined methods","text":"<p>Explore different ways of joining models in FastCRUD with examples and tips.</p> <ul> <li>Joining Models</li> </ul>"},{"location":"advanced/overview/#8-filters-in-automatic-endpoints","title":"8. Filters in Automatic Endpoints","text":"<p>Learn how to add query parameters to your <code>get_multi</code> and <code>get_paginated</code> endpoints.</p> <ul> <li>Filters in Endpoints</li> </ul>"},{"location":"advanced/overview/#prerequisites","title":"Prerequisites","text":"<p>Advanced usage assumes a solid understanding of the basic features and functionalities of our application. Knowledge of FastAPI, SQLAlchemy, and Pydantic is highly recommended to fully grasp the concepts discussed.</p>"},{"location":"api/crud_router/","title":"CRUD Router API Reference","text":"<p><code>crud_router</code> is a utility function for creating and configuring a FastAPI router with CRUD endpoints for a given model.</p>"},{"location":"api/crud_router/#function-definition","title":"Function Definition","text":"<p>Creates and configures a FastAPI router with CRUD endpoints for a given model.</p> <p>This utility function streamlines the process of setting up a router for CRUD operations, using a custom <code>EndpointCreator</code> if provided, and managing dependency injections as well as selective method inclusions or exclusions.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Callable</code> <p>The SQLAlchemy async session.</p> required <code>model</code> <code>ModelType</code> <p>The SQLAlchemy model.</p> required <code>create_schema</code> <code>Type[CreateSchemaType]</code> <p>Pydantic schema for creating an item.</p> required <code>update_schema</code> <code>Type[UpdateSchemaType]</code> <p>Pydantic schema for updating an item.</p> required <code>crud</code> <code>Optional[FastCRUD]</code> <p>An optional <code>FastCRUD</code> instance. If not provided, uses <code>FastCRUD(model)</code>.</p> <code>None</code> <code>delete_schema</code> <code>Optional[Type[DeleteSchemaType]]</code> <p>Optional Pydantic schema for deleting an item.</p> <code>None</code> <code>path</code> <code>str</code> <p>Base path for the CRUD endpoints.</p> <code>''</code> <code>tags</code> <code>Optional[list[Union[str, Enum]]]</code> <p>Optional list of tags for grouping endpoints in the documentation.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>True</code> <code>create_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to include. If <code>None</code>, all methods are included.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to exclude.</p> <code>None</code> <code>endpoint_creator</code> <code>Optional[Type[EndpointCreator]]</code> <p>Optional custom class derived from <code>EndpointCreator</code> for advanced customization.</p> <code>None</code> <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to <code>\"is_deleted\"</code>.</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to <code>\"deleted_at\"</code>.</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to <code>\"updated_at\"</code>.</p> <code>'updated_at'</code> <code>endpoint_names</code> <code>Optional[dict[str, str]]</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (<code>\"create\"</code>, <code>\"read\"</code>, <code>\"update\"</code>, <code>\"delete\"</code>, <code>\"db_delete\"</code>, <code>\"read_multi\"</code>), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>None</code> <code>filter_config</code> <code>Optional[Union[FilterConfig, dict]]</code> <p>Optional <code>FilterConfig</code> instance or dictionary to configure filters for the <code>read_multi</code> endpoint.</p> <code>None</code> <code>select_schema</code> <code>Optional[Type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting an item.</p> <code>None</code> <p>Returns:</p> Type Description <code>APIRouter</code> <p>Configured <code>APIRouter</code> instance with the CRUD endpoints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> Models and Schemas Used Below <code>mymodel/model.py</code> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>mymodel/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass UpdateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteMyModelSchema(BaseModel):\n    pass\n</code></pre> <code>customer/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>customer/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateCustomerSchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadCustomerSchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateCustomerSchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteCustomerSchema(BaseModel):\n    pass\n</code></pre> <code>product/model.py</code> <pre><code>from sqlalchemy import Column, Integer, Numeric, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Product(Base):\n    __tablename__ = \"product\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Numeric)\n</code></pre> <code>product/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateProductSchema(BaseModel):\n    name: str | None = None\n    price: float | None = None\n\n\nclass ReadProductSchema(BaseModel):\n    id: int\n    name: str | None = None\n    price: float | None = None\n\n\nclass UpdateProductSchema(BaseModel):\n    name: str | None = None\n    price: float | None = None\n\n\nclass DeleteProductSchema(BaseModel):\n    pass\n</code></pre> <code>order/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n    id = Column(Integer, primary_key=True)\n    customer_id = Column(Integer, ForeignKey(\"customer.id\"))\n    product_id = Column(Integer, ForeignKey(\"product.id\"))\n    quantity = Column(Integer)\n</code></pre> <code>order/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateOrderSchema(BaseModel):\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n\n\nclass ReadOrderSchema(BaseModel):\n    id: int\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n\n\nclass UpdateOrderSchema(BaseModel):\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n\n\nclass DeleteOrderSchema(BaseModel):\n    pass\n</code></pre> <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>tier/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadTierSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>department/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadDepartmentSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>story/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadStorySchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteStorySchema(BaseModel):\n    pass\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre> <code>task/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass ReadTaskSchema(BaseModel):\n    id: int\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass UpdateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass DeleteTaskSchema(BaseModel):\n    pass\n</code></pre> <p>Basic Setup:</p> <pre><code>mymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n)\n</code></pre> <p>With Custom Dependencies:</p> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    # Implement user retrieval logic\n    return ...\n\nuser_router = crud_router(\n    session=async_session,\n    model=User,\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    path=\"/users\",\n    tags=[\"Users\"],\n)\n</code></pre> <p>Adding Delete Endpoints: <pre><code>product_router = crud_router(\n    session=async_session,\n    model=Product,\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    delete_schema=DeleteProductSchema,\n    path=\"/products\",\n    tags=[\"Products\"],\n)\n</code></pre></p> <p>Customizing Path and Tags: <pre><code>OrderCRUD = FastCRUD[\n    Order,\n    CreateOrderSchema,\n    UpdateOrderSchema,\n    UpdateOrderSchema,\n    DeleteOrderSchema,\n]\norder_router = crud_router(\n    session=async_session,\n    model=Order,\n    create_schema=CreateOrderSchema,\n    update_schema=UpdateOrderSchema,\n    crud=OrderCRUD(Order),\n    path=\"/orders\",\n    tags=[\"Orders\", \"Sales\"],\n)\n</code></pre></p> <p>Integrating Multiple Models: <pre><code>ProductCRUD = FastCRUD[\n    Product,\n    CreateProductSchema,\n    UpdateProductSchema,\n    UpdateProductSchema,\n    DeleteProductSchema,\n]\nproduct_router = crud_router(\n    session=async_session,\n    model=Product,\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    crud=ProductCRUD(Product),\n    path=\"/products\",\n    tags=[\"Inventory\"],\n)\n\nCustomerCRUD = FastCRUD[\n    Customer,\n    CreateCustomerSchema,\n    UpdateCustomerSchema,\n    UpdateCustomerSchema,\n    DeleteCustomerSchema,\n]\ncustomer_router = crud_router(\n    session=async_session,\n    model=Customer,\n    create_schema=CreateCustomerSchema,\n    update_schema=UpdateCustomerSchema,\n    crud=CustomerCRUD(Customer),\n    path=\"/customers\",\n    tags=[\"CRM\"],\n)\n</code></pre></p> <p>With Selective CRUD Methods:</p> <pre><code>MyModelCRUD = FastCRUD[\n    MyModel,\n    CreateMyModelSchema,\n    UpdateMyModelSchema,\n    UpdateMyModelSchema,\n    DeleteMyModelSchema,\n]\n# Only include 'create' and 'read' methods\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=MyModelCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\"],\n)\n</code></pre> <p>Using a Custom <code>EndpointCreator</code>:</p> <pre><code>class CustomEndpointCreator(EndpointCreator):\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n        async def add_routes_to_router(self, ...):\n            # First, add standard CRUD routes\n            super().add_routes_to_router(...)\n\n            # Now, add custom routes\n            self.router.add_api_route(\n                path=\"/custom\",\n                endpoint=self._custom_route(),\n                methods=[\"GET\"],\n                tags=self.tags,\n                # Other parameters as needed\n            )\n\nMyModelCRUD = FastCRUD[\n    MyModel,\n    CreateMyModelSchema,\n    UpdateMyModelSchema,\n    UpdateMyModelSchema,\n    DeleteMyModelSchema,\n]\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=MyModelCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_creator=CustomEndpointCreator,\n)\n\napp.include_router(mymodel_router)\n</code></pre> <p>Customizing Endpoint Names:</p> <pre><code>task_router = crud_router(\n    session=async_session,\n    model=Task,\n    create_schema=CreateTaskSchema,\n    update_schema=UpdateTaskSchema,\n    path=\"/tasks\",\n    tags=[\"Task Management\"],\n    endpoint_names={\n        \"create\": \"add_task\",\n        \"read\": \"get_task\",\n        \"update\": \"modify_task\",\n        \"delete\": \"remove_task\",\n        \"db_delete\": \"permanently_remove_task\",\n        \"read_multi\": \"list_tasks\",\n    },\n)\n</code></pre> <p>Using <code>FilterConfig</code> with <code>dict</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\n\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n)\n# Adds CRUD routes with filtering capabilities\napp.include_router(mymodel_router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> <p>Using <code>FilterConfig</code> with keyword arguments:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\n\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(id=None, name=\"default\"),\n)\n# Adds CRUD routes with filtering capabilities\napp.include_router(mymodel_router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> Source code in <code>fastcrud/endpoint/crud_router.py</code> <pre><code>def crud_router(\n    session: Callable,\n    model: ModelType,\n    create_schema: Type[CreateSchemaType],\n    update_schema: Type[UpdateSchemaType],\n    crud: Optional[FastCRUD] = None,\n    delete_schema: Optional[Type[DeleteSchemaType]] = None,\n    path: str = \"\",\n    tags: Optional[list[Union[str, Enum]]] = None,\n    include_in_schema: bool = True,\n    create_deps: Sequence[Callable] = [],\n    read_deps: Sequence[Callable] = [],\n    read_multi_deps: Sequence[Callable] = [],\n    update_deps: Sequence[Callable] = [],\n    delete_deps: Sequence[Callable] = [],\n    db_delete_deps: Sequence[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n    endpoint_creator: Optional[Type[EndpointCreator]] = None,\n    is_deleted_column: str = \"is_deleted\",\n    deleted_at_column: str = \"deleted_at\",\n    updated_at_column: str = \"updated_at\",\n    endpoint_names: Optional[dict[str, str]] = None,\n    filter_config: Optional[Union[FilterConfig, dict]] = None,\n    select_schema: Optional[Type[SelectSchemaType]] = None,\n) -&gt; APIRouter:\n    \"\"\"\n    Creates and configures a FastAPI router with CRUD endpoints for a given model.\n\n    This utility function streamlines the process of setting up a router for CRUD operations,\n    using a custom `EndpointCreator` if provided, and managing dependency injections as well\n    as selective method inclusions or exclusions.\n\n    Args:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        crud: An optional `FastCRUD` instance. If not provided, uses `FastCRUD(model)`.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: Optional list of tags for grouping endpoints in the documentation.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        create_deps: Optional list of functions to be injected as dependencies for the create endpoint.\n        read_deps: Optional list of functions to be injected as dependencies for the read endpoint.\n        read_multi_deps: Optional list of functions to be injected as dependencies for the read multiple items endpoint.\n        update_deps: Optional list of functions to be injected as dependencies for the update endpoint.\n        delete_deps: Optional list of functions to be injected as dependencies for the delete endpoint.\n        db_delete_deps: Optional list of functions to be injected as dependencies for the hard delete endpoint.\n        included_methods: Optional list of CRUD methods to include. If `None`, all methods are included.\n        deleted_methods: Optional list of CRUD methods to exclude.\n        endpoint_creator: Optional custom class derived from `EndpointCreator` for advanced customization.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to `\"is_deleted\"`.\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to `\"deleted_at\"`.\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to `\"updated_at\"`.\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (`\"create\"`, `\"read\"`, `\"update\"`, `\"delete\"`, `\"db_delete\"`, `\"read_multi\"`), and\n                        values are the custom names to use. Unspecified operations will use default names.\n        filter_config: Optional `FilterConfig` instance or dictionary to configure filters for the `read_multi` endpoint.\n        select_schema: Optional Pydantic schema for selecting an item.\n\n    Returns:\n        Configured `APIRouter` instance with the CRUD endpoints.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        ??? example \"Models and Schemas Used Below\"\n\n            ??? example \"`mymodel/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/mymodel/model.py:imports\n                fastcrud/examples/mymodel/model.py:model_simple\n                --8&lt;--\n                ```\n\n            ??? example \"`mymodel/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/mymodel/schemas.py:imports\n                fastcrud/examples/mymodel/schemas.py:createschema\n                fastcrud/examples/mymodel/schemas.py:updateschema\n                fastcrud/examples/mymodel/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`customer/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/customer/model.py:imports\n                fastcrud/examples/customer/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`customer/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/customer/schemas.py:imports\n                fastcrud/examples/customer/schemas.py:createschema\n                fastcrud/examples/customer/schemas.py:readschema\n                fastcrud/examples/customer/schemas.py:updateschema\n                fastcrud/examples/customer/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`product/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/model.py:imports\n                fastcrud/examples/product/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`product/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/schemas.py:imports\n                fastcrud/examples/product/schemas.py:createschema\n                fastcrud/examples/product/schemas.py:readschema\n                fastcrud/examples/product/schemas.py:updateschema\n                fastcrud/examples/product/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`order/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/model.py:imports\n                fastcrud/examples/order/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`order/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/schemas.py:imports\n                fastcrud/examples/order/schemas.py:createschema\n                fastcrud/examples/order/schemas.py:readschema\n                fastcrud/examples/order/schemas.py:updateschema\n                fastcrud/examples/order/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`tier/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/model.py:imports\n                fastcrud/examples/tier/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`tier/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/schemas.py:imports\n                fastcrud/examples/tier/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`department/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/model.py:imports\n                fastcrud/examples/department/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`department/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/schemas.py:imports\n                fastcrud/examples/department/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`user/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/model.py:imports\n                fastcrud/examples/user/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`user/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/schemas.py:imports\n                fastcrud/examples/user/schemas.py:createschema\n                fastcrud/examples/user/schemas.py:readschema\n                fastcrud/examples/user/schemas.py:updateschema\n                fastcrud/examples/user/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`story/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/model.py:imports\n                fastcrud/examples/story/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`story/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/schemas.py:imports\n                fastcrud/examples/story/schemas.py:createschema\n                fastcrud/examples/story/schemas.py:readschema\n                fastcrud/examples/story/schemas.py:updateschema\n                fastcrud/examples/story/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`task/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/model.py:imports\n                fastcrud/examples/task/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`task/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/schemas.py:imports\n                fastcrud/examples/task/schemas.py:createschema\n                fastcrud/examples/task/schemas.py:readschema\n                fastcrud/examples/task/schemas.py:updateschema\n                fastcrud/examples/task/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n        Basic Setup:\n\n        ```python\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n        )\n        ```\n\n        With Custom Dependencies:\n\n        ```python\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            # Implement user retrieval logic\n            return ...\n\n        user_router = crud_router(\n            session=async_session,\n            model=User,\n            create_schema=CreateUserSchema,\n            update_schema=UpdateUserSchema,\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            path=\"/users\",\n            tags=[\"Users\"],\n        )\n        ```\n\n        Adding Delete Endpoints:\n        ```python\n        product_router = crud_router(\n            session=async_session,\n            model=Product,\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            delete_schema=DeleteProductSchema,\n            path=\"/products\",\n            tags=[\"Products\"],\n        )\n        ```\n\n        Customizing Path and Tags:\n        ```python\n        OrderCRUD = FastCRUD[\n            Order,\n            CreateOrderSchema,\n            UpdateOrderSchema,\n            UpdateOrderSchema,\n            DeleteOrderSchema,\n        ]\n        order_router = crud_router(\n            session=async_session,\n            model=Order,\n            create_schema=CreateOrderSchema,\n            update_schema=UpdateOrderSchema,\n            crud=OrderCRUD(Order),\n            path=\"/orders\",\n            tags=[\"Orders\", \"Sales\"],\n        )\n        ```\n\n        Integrating Multiple Models:\n        ```python\n        ProductCRUD = FastCRUD[\n            Product,\n            CreateProductSchema,\n            UpdateProductSchema,\n            UpdateProductSchema,\n            DeleteProductSchema,\n        ]\n        product_router = crud_router(\n            session=async_session,\n            model=Product,\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            crud=ProductCRUD(Product),\n            path=\"/products\",\n            tags=[\"Inventory\"],\n        )\n\n        CustomerCRUD = FastCRUD[\n            Customer,\n            CreateCustomerSchema,\n            UpdateCustomerSchema,\n            UpdateCustomerSchema,\n            DeleteCustomerSchema,\n        ]\n        customer_router = crud_router(\n            session=async_session,\n            model=Customer,\n            create_schema=CreateCustomerSchema,\n            update_schema=UpdateCustomerSchema,\n            crud=CustomerCRUD(Customer),\n            path=\"/customers\",\n            tags=[\"CRM\"],\n        )\n        ```\n\n        With Selective CRUD Methods:\n\n        ```python\n        MyModelCRUD = FastCRUD[\n            MyModel,\n            CreateMyModelSchema,\n            UpdateMyModelSchema,\n            UpdateMyModelSchema,\n            DeleteMyModelSchema,\n        ]\n        # Only include 'create' and 'read' methods\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            crud=MyModelCRUD(MyModel),\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            included_methods=[\"create\", \"read\"],\n        )\n        ```\n\n        Using a Custom `EndpointCreator`:\n\n        ```python\n        class CustomEndpointCreator(EndpointCreator):\n            def _custom_route(self):\n                async def custom_endpoint():\n                    # Custom endpoint logic\n                    return {\"message\": \"Custom route\"}\n\n                return custom_endpoint\n\n                async def add_routes_to_router(self, ...):\n                    # First, add standard CRUD routes\n                    super().add_routes_to_router(...)\n\n                    # Now, add custom routes\n                    self.router.add_api_route(\n                        path=\"/custom\",\n                        endpoint=self._custom_route(),\n                        methods=[\"GET\"],\n                        tags=self.tags,\n                        # Other parameters as needed\n                    )\n\n        MyModelCRUD = FastCRUD[\n            MyModel,\n            CreateMyModelSchema,\n            UpdateMyModelSchema,\n            UpdateMyModelSchema,\n            DeleteMyModelSchema,\n        ]\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            crud=MyModelCRUD(MyModel),\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            endpoint_creator=CustomEndpointCreator,\n        )\n\n        app.include_router(mymodel_router)\n        ```\n\n        Customizing Endpoint Names:\n\n        ```python\n        task_router = crud_router(\n            session=async_session,\n            model=Task,\n            create_schema=CreateTaskSchema,\n            update_schema=UpdateTaskSchema,\n            path=\"/tasks\",\n            tags=[\"Task Management\"],\n            endpoint_names={\n                \"create\": \"add_task\",\n                \"read\": \"get_task\",\n                \"update\": \"modify_task\",\n                \"delete\": \"remove_task\",\n                \"db_delete\": \"permanently_remove_task\",\n                \"read_multi\": \"list_tasks\",\n            },\n        )\n        ```\n\n        Using `FilterConfig` with `dict`:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import crud_router\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n        )\n        # Adds CRUD routes with filtering capabilities\n        app.include_router(mymodel_router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n\n        Using `FilterConfig` with keyword arguments:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import crud_router\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(id=None, name=\"default\"),\n        )\n        # Adds CRUD routes with filtering capabilities\n        app.include_router(mymodel_router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n    \"\"\"\n\n    crud = crud or FastCRUD(\n        model=model,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n    )\n\n    endpoint_creator_class = endpoint_creator or EndpointCreator\n    endpoint_creator_instance = endpoint_creator_class(\n        session=session,\n        model=model,\n        crud=crud,\n        create_schema=create_schema,  # type: ignore\n        update_schema=update_schema,  # type: ignore\n        include_in_schema=include_in_schema,\n        delete_schema=delete_schema,  # type: ignore\n        path=path,\n        tags=tags,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n        endpoint_names=endpoint_names,\n        filter_config=filter_config,\n        select_schema=select_schema,  # type: ignore\n    )\n\n    endpoint_creator_instance.add_routes_to_router(\n        create_deps=create_deps,\n        read_deps=read_deps,\n        read_multi_deps=read_multi_deps,\n        update_deps=update_deps,\n        delete_deps=delete_deps,\n        db_delete_deps=db_delete_deps,\n        included_methods=included_methods,\n        deleted_methods=deleted_methods,\n    )\n\n    return endpoint_creator_instance.router\n</code></pre>"},{"location":"api/endpoint_creator/","title":"EndpointCreator API Reference","text":"<p><code>EndpointCreator</code> is a class designed to create and register CRUD endpoints for a FastAPI application. It simplifies the process of adding CRUD (Create, Read, Update, Delete) endpoints to a FastAPI router.</p>"},{"location":"api/endpoint_creator/#class-definition","title":"Class Definition","text":"<p>A class to create and register CRUD endpoints for a FastAPI application.</p> <p>This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations, and Pydantic schemas, and allows for custom dependency injection for each endpoint. The method assumes <code>id</code> is the primary key for path parameters.</p> <p>Attributes:</p> Name Type Description <code>session</code> <p>The SQLAlchemy async session.</p> <code>model</code> <p>The SQLAlchemy model.</p> <code>create_schema</code> <p>Pydantic schema for creating an item.</p> <code>update_schema</code> <p>Pydantic schema for updating an item.</p> <code>crud</code> <p>An optional FastCRUD instance. If not provided, uses <code>FastCRUD(model)</code>.</p> <code>include_in_schema</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>delete_schema</code> <p>Optional Pydantic schema for deleting an item.</p> <code>path</code> <p>Base path for the CRUD endpoints.</p> <code>tags</code> <p>List of tags for grouping endpoints in the documentation.</p> <code>is_deleted_column</code> <p>Optional column name to use for indicating a soft delete. Defaults to <code>\"is_deleted\"</code>.</p> <code>deleted_at_column</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to <code>\"deleted_at\"</code>.</p> <code>updated_at_column</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to <code>\"updated_at\"</code>.</p> <code>endpoint_names</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (<code>\"create\"</code>, <code>\"read\"</code>, <code>\"update\"</code>, <code>\"delete\"</code>, <code>\"db_delete\"</code>, <code>\"read_multi\"</code>), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>filter_config</code> <p>Optional <code>FilterConfig</code> instance or dictionary to configure filters for the <code>read_multi</code> endpoint.</p> <code>select_schema</code> <p>Optional Pydantic schema for selecting an item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Basic Setup:</p> <code>mymodel/model.py</code> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>mymodel/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass UpdateMyModelSchema(BaseModel):\n    name: str | None = None\n</code></pre> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n)\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n</code></pre> <p>With Custom Dependencies:</p> <pre><code>from fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    return ...\n\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n)\n</code></pre> <p>Selective Endpoint Creation (inclusion):</p> <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"],\n)\n</code></pre> <p>Selective Endpoint Creation (deletion):</p> <pre><code># Create all but 'update' and 'delete' endpoints\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"update\", \"delete\"],\n)\n</code></pre> <p>Integrating with Multiple Models:</p> <pre><code># Assuming definitions for OtherModel, OtherModelCRUD, etc.\n\nother_model_crud = OtherModelCRUD(OtherModel)\nother_endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=OtherModel,\n    create_schema=CreateOtherModelSchema,\n    update_schema=UpdateOtherModelSchema,\n    crud=other_model_crud,\n)\nother_endpoint_creator.add_routes_to_router()\napp.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n</code></pre> <p>Customizing Endpoint Names:</p> <pre><code>endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names={\n        \"create\": \"add\",  # Custom endpoint name for creating items\n        \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n        \"update\": \"change\",  # Custom endpoint name for updating items\n        # The delete operation will use the default name \"delete\"\n    },\n)\nendpoint_creator.add_routes_to_router()\n</code></pre> <p>Using <code>filter_config</code> with <code>dict</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n)\n# Adds CRUD routes with filtering capabilities\nendpoint_creator.add_routes_to_router()\n# Include the internal router into the FastAPI app\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> <p>Using <code>filter_config</code> with keyword arguments:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(id=None, name=\"default\"),\n)\n# Adds CRUD routes with filtering capabilities\nendpoint_creator.add_routes_to_router()\n# Include the internal router into the FastAPI app\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>class EndpointCreator:\n    \"\"\"\n    A class to create and register CRUD endpoints for a FastAPI application.\n\n    This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints\n    to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations,\n    and Pydantic schemas, and allows for custom dependency injection for each endpoint.\n    The method assumes `id` is the primary key for path parameters.\n\n    Attributes:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        crud: An optional FastCRUD instance. If not provided, uses `FastCRUD(model)`.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: List of tags for grouping endpoints in the documentation.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to `\"is_deleted\"`.\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to `\"deleted_at\"`.\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to `\"updated_at\"`.\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (`\"create\"`, `\"read\"`, `\"update\"`, `\"delete\"`, `\"db_delete\"`, `\"read_multi\"`), and\n                        values are the custom names to use. Unspecified operations will use default names.\n        filter_config: Optional `FilterConfig` instance or dictionary to configure filters for the `read_multi` endpoint.\n        select_schema: Optional Pydantic schema for selecting an item.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Basic Setup:\n\n        ??? example \"`mymodel/model.py`\"\n\n            ```python\n            --8&lt;--\n            fastcrud/examples/mymodel/model.py:imports\n            fastcrud/examples/mymodel/model.py:model_simple\n            --8&lt;--\n            ```\n\n        ??? example \"`mymodel/schemas.py`\"\n\n            ```python\n            --8&lt;--\n            fastcrud/examples/mymodel/schemas.py:imports\n            fastcrud/examples/mymodel/schemas.py:createschema\n            fastcrud/examples/mymodel/schemas.py:updateschema\n            --8&lt;--\n            ```\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n        )\n        endpoint_creator.add_routes_to_router()\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n        ```\n\n        With Custom Dependencies:\n\n        ```python\n        from fastapi.security import OAuth2PasswordBearer\n\n        oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            return ...\n\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n        )\n        ```\n\n        Selective Endpoint Creation (inclusion):\n\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"],\n        )\n        ```\n\n        Selective Endpoint Creation (deletion):\n\n        ```python\n        # Create all but 'update' and 'delete' endpoints\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"update\", \"delete\"],\n        )\n        ```\n\n        Integrating with Multiple Models:\n\n        ```python\n        # Assuming definitions for OtherModel, OtherModelCRUD, etc.\n\n        other_model_crud = OtherModelCRUD(OtherModel)\n        other_endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=OtherModel,\n            create_schema=CreateOtherModelSchema,\n            update_schema=UpdateOtherModelSchema,\n            crud=other_model_crud,\n        )\n        other_endpoint_creator.add_routes_to_router()\n        app.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n        ```\n\n        Customizing Endpoint Names:\n\n        ```python\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            endpoint_names={\n                \"create\": \"add\",  # Custom endpoint name for creating items\n                \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n                \"update\": \"change\",  # Custom endpoint name for updating items\n                # The delete operation will use the default name \"delete\"\n            },\n        )\n        endpoint_creator.add_routes_to_router()\n        ```\n\n        Using `filter_config` with `dict`:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator, FilterConfig\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n        )\n        # Adds CRUD routes with filtering capabilities\n        endpoint_creator.add_routes_to_router()\n        # Include the internal router into the FastAPI app\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n\n        Using `filter_config` with keyword arguments:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator, FilterConfig\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(id=None, name=\"default\"),\n        )\n        # Adds CRUD routes with filtering capabilities\n        endpoint_creator.add_routes_to_router()\n        # Include the internal router into the FastAPI app\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: Callable,\n        model: ModelType,\n        create_schema: Type[CreateSchemaType],\n        update_schema: Type[UpdateSchemaType],\n        crud: Optional[FastCRUD] = None,\n        include_in_schema: bool = True,\n        delete_schema: Optional[Type[DeleteSchemaType]] = None,\n        path: str = \"\",\n        tags: Optional[list[Union[str, Enum]]] = None,\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n        endpoint_names: Optional[dict[str, str]] = None,\n        filter_config: Optional[Union[FilterConfig, dict]] = None,\n        select_schema: Optional[Type[SelectSchemaType]] = None,\n    ) -&gt; None:\n        self._primary_keys = _get_primary_keys(model)\n        self._primary_keys_types = {\n            pk.name: _get_python_type(pk) for pk in self._primary_keys\n        }\n        self.primary_key_names = [pk.name for pk in self._primary_keys]\n        self.session = session\n        self.crud = crud or FastCRUD(\n            model=model,\n            is_deleted_column=is_deleted_column,\n            deleted_at_column=deleted_at_column,\n            updated_at_column=updated_at_column,\n        )\n        self.model = model\n        self.create_schema = create_schema\n        self.update_schema = update_schema\n        self.delete_schema = delete_schema\n        self.select_schema = select_schema\n        self.include_in_schema = include_in_schema\n        self.path = path\n        self.tags = tags or []\n        self.router = APIRouter()\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self.default_endpoint_names = {\n            \"create\": \"\",\n            \"read\": \"\",\n            \"update\": \"\",\n            \"delete\": \"\",\n            \"db_delete\": \"db_delete\",\n            \"read_multi\": \"\",\n        }\n        self.endpoint_names = {**self.default_endpoint_names, **(endpoint_names or {})}\n        if filter_config:\n            if isinstance(filter_config, dict):\n                filter_config = FilterConfig(**filter_config)\n            self._validate_filter_config(filter_config)\n        self.filter_config = filter_config\n        self.column_types = _get_column_types(model)\n\n        if select_schema is not None:\n            self.list_response_model: Optional[Type[ListResponse[Any]]] = type(\n                \"DynamicListResponse\",\n                (ListResponse[BaseModel],),\n                {\"__annotations__\": {\"data\": list[select_schema]}},  # type: ignore\n            )\n            self.paginated_response_model: Optional[\n                Type[PaginatedListResponse[Any]]\n            ] = type(\n                \"DynamicPaginatedResponse\",\n                (PaginatedListResponse[BaseModel],),\n                {\n                    \"__annotations__\": {\n                        \"data\": list[select_schema],  # type: ignore\n                        \"total_count\": int,\n                        \"has_more\": bool,\n                        \"page\": Optional[int],\n                        \"items_per_page\": Optional[int],\n                    }\n                },\n            )\n        else:\n            self.list_response_model = None\n            self.paginated_response_model = None\n\n    def _validate_filter_config(self, filter_config: FilterConfig) -&gt; None:\n        model_columns = self.crud.model_col_names\n        supported_filters = self.crud._SUPPORTED_FILTERS\n        for key in filter_config.filters.keys():\n            if \"__\" in key:\n                field_name, op = key.rsplit(\"__\", 1)\n                if op not in supported_filters:\n                    raise ValueError(\n                        f\"Invalid filter op '{op}': following filter ops are allowed: {supported_filters.keys()}\"\n                    )\n            else:\n                field_name = key\n\n            if field_name not in model_columns:\n                raise ValueError(\n                    f\"Invalid filter column '{key}': not found in model '{self.model.__name__}' columns\"\n                )\n\n    def _create_item(self):\n        \"\"\"Creates an endpoint for creating items in the database.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            item: self.create_schema = Body(...),  # type: ignore\n        ):\n            unique_columns = _extract_unique_columns(self.model)\n\n            for column in unique_columns:\n                col_name = column.name\n                if hasattr(item, col_name):\n                    value = getattr(item, col_name)\n                    exists = await self.crud.exists(db, **{col_name: value})\n                    if exists:  # pragma: no cover\n                        raise DuplicateValueException(\n                            f\"Value {value} is already registered\"\n                        )\n\n            return await self.crud.create(db, item)\n\n        return endpoint\n\n    def _read_item(self):\n        \"\"\"Creates an endpoint for reading a single item from the database.\"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            if self.select_schema is not None:\n                item = await self.crud.get(\n                    db,\n                    schema_to_select=cast(Type[BaseModel], self.select_schema),\n                    return_as_model=True,\n                    **pkeys,\n                )\n            else:\n                item = await self.crud.get(db, **pkeys)\n            if not item:  # pragma: no cover\n                raise NotFoundException(detail=\"Item not found\")\n            return item  # pragma: no cover\n\n        return endpoint\n\n    def _read_items(self):\n        \"\"\"Creates an endpoint for reading multiple items from the database.\"\"\"\n        dynamic_filters = _create_dynamic_filters(self.filter_config, self.column_types)\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            offset: Optional[int] = Query(\n                None, description=\"Offset for unpaginated queries\"\n            ),\n            limit: Optional[int] = Query(\n                None, description=\"Limit for unpaginated queries\"\n            ),\n            page: Optional[int] = Query(None, alias=\"page\", description=\"Page number\"),\n            items_per_page: Optional[int] = Query(\n                None, alias=\"itemsPerPage\", description=\"Number of items per page\"\n            ),\n            filters: dict = Depends(dynamic_filters),\n        ) -&gt; Union[dict[str, Any], PaginatedListResponse, ListResponse]:\n            is_paginated = (page is not None) or (items_per_page is not None)\n            has_offset_limit = (offset is not None) and (limit is not None)\n\n            if is_paginated and has_offset_limit:\n                raise BadRequestException(\n                    detail=\"Conflicting parameters: Use either 'page' and 'itemsPerPage' for paginated results or 'offset' and 'limit' for specific range queries.\"\n                )\n\n            if is_paginated:\n                if not page:\n                    page = 1\n                if not items_per_page:\n                    items_per_page = 10\n                offset = compute_offset(page=page, items_per_page=items_per_page)  # type: ignore\n                limit = items_per_page\n            elif not has_offset_limit:\n                offset = 0\n                limit = 100\n\n            if self.select_schema is not None:\n                crud_data = await self.crud.get_multi(\n                    db,\n                    offset=offset,  # type: ignore\n                    limit=limit,  # type: ignore\n                    schema_to_select=self.select_schema,\n                    return_as_model=True,\n                    **filters,\n                )\n            else:\n                crud_data = await self.crud.get_multi(\n                    db,\n                    offset=offset,  # type: ignore\n                    limit=limit,  # type: ignore\n                    **filters,\n                )\n\n            if is_paginated:\n                return paginated_response(\n                    crud_data=crud_data,\n                    page=page,  # type: ignore\n                    items_per_page=items_per_page,  # type: ignore\n                )\n\n            return crud_data  # pragma: no cover\n\n        return endpoint\n\n    def _update_item(self):\n        \"\"\"Creates an endpoint for updating an existing item in the database.\"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(\n            item: self.update_schema = Body(...),  # type: ignore\n            db: AsyncSession = Depends(self.session),\n            **pkeys,\n        ):\n            return await self.crud.update(db, item, **pkeys)\n\n        return endpoint\n\n    def _delete_item(self):\n        \"\"\"Creates an endpoint for deleting an item from the database.\"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            await self.crud.delete(db, **pkeys)\n            return {\"message\": \"Item deleted successfully\"}  # pragma: no cover\n\n        return endpoint\n\n    def _db_delete(self):\n        \"\"\"\n        Creates an endpoint for hard deleting an item from the database.\n\n        This endpoint is only added if the `delete_schema` is provided during initialization.\n        The endpoint expects an item ID as a path parameter and uses the provided SQLAlchemy\n        async session to permanently delete the item from the database.\n        \"\"\"\n\n        @_apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            await self.crud.db_delete(db, **pkeys)\n            return {\n                \"message\": \"Item permanently deleted from the database\"\n            }  # pragma: no cover\n\n        return endpoint\n\n    def _get_endpoint_path(self, operation: str):\n        endpoint_name = self.endpoint_names.get(\n            operation, self.default_endpoint_names.get(operation, operation)\n        )\n        path = f\"{self.path}/{endpoint_name}\" if endpoint_name else self.path\n\n        if operation in {\"read\", \"update\", \"delete\", \"db_delete\"}:\n            _primary_keys_path_suffix = \"/\".join(\n                f\"{{{n}}}\" for n in self.primary_key_names\n            )\n            path = f\"{path}/{_primary_keys_path_suffix}\"\n\n        return path\n\n    def add_routes_to_router(\n        self,\n        create_deps: Sequence[Callable] = [],\n        read_deps: Sequence[Callable] = [],\n        read_multi_deps: Sequence[Callable] = [],\n        update_deps: Sequence[Callable] = [],\n        delete_deps: Sequence[Callable] = [],\n        db_delete_deps: Sequence[Callable] = [],\n        included_methods: Optional[Sequence[str]] = None,\n        deleted_methods: Optional[Sequence[str]] = None,\n    ):\n        \"\"\"\n        Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n        This method registers routes for create, read, update, and delete operations with the FastAPI router,\n        allowing for custom dependency injection for each type of operation.\n\n        Args:\n            create_deps: List of functions to be injected as dependencies for the create endpoint.\n            read_deps: List of functions to be injected as dependencies for the read endpoint.\n            read_multi_deps: List of functions to be injected as dependencies for the read multiple items endpoint.\n            update_deps: List of functions to be injected as dependencies for the update endpoint.\n            delete_deps: List of functions to be injected as dependencies for the delete endpoint.\n            db_delete_deps: List of functions to be injected as dependencies for the hard delete endpoint.\n            included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n            deleted_methods: Optional list of methods to exclude. Defaults to `None`.\n\n        Raises:\n            ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n        Examples:\n            Selective Endpoint Creation:\n\n            ```python\n            # Only create 'create' and 'read' endpoints\n            endpoint_creator.add_routes_to_router(\n                included_methods=[\"create\", \"read\"],\n            )\n            ```\n\n            Excluding Specific Endpoints:\n\n            ```python\n            # Create all endpoints except 'delete' and 'db_delete'\n            endpoint_creator.add_routes_to_router(\n                deleted_methods=[\"delete\", \"db_delete\"],\n            )\n            ```\n\n            With Custom Dependencies and Selective Endpoints:\n\n            ```python\n            def get_current_user(...):\n                ...\n\n            # Create only 'read' and 'update' endpoints with custom dependencies\n            endpoint_creator.add_routes_to_router(\n                read_deps=[get_current_user],\n                update_deps=[get_current_user],\n                included_methods=[\"read\", \"update\"],\n            )\n            ```\n\n        Note:\n            This method should be called to register the endpoints with the FastAPI application.\n            If `delete_schema` is provided on class instantiation, a hard delete endpoint is also registered.\n            This method assumes `id` is the primary key for path parameters.\n        \"\"\"\n        if (included_methods is not None) and (deleted_methods is not None):\n            raise ValueError(\n                \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n            )\n\n        if included_methods is None:\n            included_methods = [\n                \"create\",\n                \"read\",\n                \"read_multi\",\n                \"update\",\n                \"delete\",\n                \"db_delete\",\n            ]\n        else:\n            try:\n                included_methods = CRUDMethods(\n                    valid_methods=included_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n        if deleted_methods is None:\n            deleted_methods = []\n        else:\n            try:\n                deleted_methods = CRUDMethods(\n                    valid_methods=deleted_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n        delete_description = \"Delete a\"\n        if self.delete_schema:\n            delete_description = \"Soft delete a\"\n\n        if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"create\"),\n                self._create_item(),\n                methods=[\"POST\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(create_deps),\n                description=f\"Create a new {self.model.__name__} row in the database.\",\n            )\n\n        if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"read\"),\n                self._read_item(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(read_deps),\n                response_model=self.select_schema if self.select_schema else None,\n                description=f\"Read a single {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n            if self.select_schema is not None:\n                response_model: Optional[\n                    Type[Union[PaginatedListResponse[Any], ListResponse[Any]]]\n                ] = Union[\n                    self.paginated_response_model,  # type: ignore\n                    self.list_response_model,  # type: ignore\n                ]\n            else:\n                response_model = None\n\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"read_multi\"),\n                self._read_items(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(read_multi_deps),\n                response_model=response_model,\n                description=(\n                    f\"Read multiple {self.model.__name__} rows from the database.\\n\\n\"\n                    f\"- Use page &amp; itemsPerPage for paginated results\\n\"\n                    f\"- Use offset &amp; limit for specific ranges\\n\"\n                    f\"- Returns paginated response when using page/itemsPerPage\\n\"\n                    f\"- Returns simple list response when using offset/limit\"\n                ),\n            )\n\n        if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"update\"),\n                self._update_item(),\n                methods=[\"PATCH\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(update_deps),\n                description=f\"Update an existing {self.model.__name__} row in the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n            path = self._get_endpoint_path(operation=\"delete\")\n            self.router.add_api_route(\n                path,\n                self._delete_item(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(delete_deps),\n                description=f\"{delete_description} {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\n            (\"db_delete\" in included_methods)\n            and (\"db_delete\" not in deleted_methods)\n            and self.delete_schema\n        ):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"db_delete\"),\n                self._db_delete(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=_inject_dependencies(db_delete_deps),\n                description=f\"Permanently delete a {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n    def add_custom_route(\n        self,\n        endpoint: Callable,\n        methods: Optional[Union[set[str], list[str]]],\n        path: Optional[str] = None,\n        dependencies: Optional[Sequence[Callable]] = None,\n        include_in_schema: bool = True,\n        tags: Optional[list[Union[str, Enum]]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n    ) -&gt; None:\n        \"\"\"\n        Adds a custom route to the FastAPI router.\n\n        Args:\n            endpoint: The endpoint function to execute when the route is called.\n            methods: A list of HTTP methods for the route (e.g., `['GET', 'POST']`).\n            path: URL path for the custom route.\n            dependencies: A list of functions to be injected as dependencies for the route.\n            include_in_schema: Whether to include this route in the OpenAPI schema.\n            tags: Tags for grouping and categorizing the route in documentation.\n            summary: A short summary of the route, for documentation.\n            description: A detailed description of the route, for documentation.\n            response_description: A description of the response, for documentation.\n\n        Example:\n            ```python\n            async def custom_endpoint(foo: int, bar: str):\n                # custom logic here\n                return {\"foo\": foo, \"bar\": bar}\n\n            endpoint_creator.add_custom_route(\n                endpoint=custom_endpoint,\n                methods=[\"GET\"],\n                path=\"/custom\",\n                tags=[\"custom\"],\n                summary=\"Custom Endpoint\",\n                description=\"This is a custom endpoint.\",\n            )\n            ```\n        \"\"\"\n        path = path or self.path\n        full_path = f\"{self.path}{path}\"\n        self.router.add_api_route(\n            path=full_path,\n            endpoint=endpoint,\n            methods=methods,\n            dependencies=_inject_dependencies(dependencies) or [],\n            include_in_schema=include_in_schema,\n            tags=tags or self.tags,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n        )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_custom_route","title":"<code>add_custom_route(endpoint, methods, path=None, dependencies=None, include_in_schema=True, tags=None, summary=None, description=None, response_description='Successful Response')</code>","text":"<p>Adds a custom route to the FastAPI router.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Callable</code> <p>The endpoint function to execute when the route is called.</p> required <code>methods</code> <code>Optional[Union[set[str], list[str]]]</code> <p>A list of HTTP methods for the route (e.g., <code>['GET', 'POST']</code>).</p> required <code>path</code> <code>Optional[str]</code> <p>URL path for the custom route.</p> <code>None</code> <code>dependencies</code> <code>Optional[Sequence[Callable]]</code> <p>A list of functions to be injected as dependencies for the route.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include this route in the OpenAPI schema.</p> <code>True</code> <code>tags</code> <code>Optional[list[Union[str, Enum]]]</code> <p>Tags for grouping and categorizing the route in documentation.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A short summary of the route, for documentation.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A detailed description of the route, for documentation.</p> <code>None</code> <code>response_description</code> <code>str</code> <p>A description of the response, for documentation.</p> <code>'Successful Response'</code> Example <pre><code>async def custom_endpoint(foo: int, bar: str):\n    # custom logic here\n    return {\"foo\": foo, \"bar\": bar}\n\nendpoint_creator.add_custom_route(\n    endpoint=custom_endpoint,\n    methods=[\"GET\"],\n    path=\"/custom\",\n    tags=[\"custom\"],\n    summary=\"Custom Endpoint\",\n    description=\"This is a custom endpoint.\",\n)\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_custom_route(\n    self,\n    endpoint: Callable,\n    methods: Optional[Union[set[str], list[str]]],\n    path: Optional[str] = None,\n    dependencies: Optional[Sequence[Callable]] = None,\n    include_in_schema: bool = True,\n    tags: Optional[list[Union[str, Enum]]] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    response_description: str = \"Successful Response\",\n) -&gt; None:\n    \"\"\"\n    Adds a custom route to the FastAPI router.\n\n    Args:\n        endpoint: The endpoint function to execute when the route is called.\n        methods: A list of HTTP methods for the route (e.g., `['GET', 'POST']`).\n        path: URL path for the custom route.\n        dependencies: A list of functions to be injected as dependencies for the route.\n        include_in_schema: Whether to include this route in the OpenAPI schema.\n        tags: Tags for grouping and categorizing the route in documentation.\n        summary: A short summary of the route, for documentation.\n        description: A detailed description of the route, for documentation.\n        response_description: A description of the response, for documentation.\n\n    Example:\n        ```python\n        async def custom_endpoint(foo: int, bar: str):\n            # custom logic here\n            return {\"foo\": foo, \"bar\": bar}\n\n        endpoint_creator.add_custom_route(\n            endpoint=custom_endpoint,\n            methods=[\"GET\"],\n            path=\"/custom\",\n            tags=[\"custom\"],\n            summary=\"Custom Endpoint\",\n            description=\"This is a custom endpoint.\",\n        )\n        ```\n    \"\"\"\n    path = path or self.path\n    full_path = f\"{self.path}{path}\"\n    self.router.add_api_route(\n        path=full_path,\n        endpoint=endpoint,\n        methods=methods,\n        dependencies=_inject_dependencies(dependencies) or [],\n        include_in_schema=include_in_schema,\n        tags=tags or self.tags,\n        summary=summary,\n        description=description,\n        response_description=response_description,\n    )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_routes_to_router","title":"<code>add_routes_to_router(create_deps=[], read_deps=[], read_multi_deps=[], update_deps=[], delete_deps=[], db_delete_deps=[], included_methods=None, deleted_methods=None)</code>","text":"<p>Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.</p> <p>This method registers routes for create, read, update, and delete operations with the FastAPI router, allowing for custom dependency injection for each type of operation.</p> <p>Parameters:</p> Name Type Description Default <code>create_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[Sequence[str]]</code> <p>Optional list of methods to include. Defaults to all CRUD methods.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[Sequence[str]]</code> <p>Optional list of methods to exclude. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Selective Endpoint Creation:</p> <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"],\n)\n</code></pre> <p>Excluding Specific Endpoints:</p> <pre><code># Create all endpoints except 'delete' and 'db_delete'\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"delete\", \"db_delete\"],\n)\n</code></pre> <p>With Custom Dependencies and Selective Endpoints:</p> <pre><code>def get_current_user(...):\n    ...\n\n# Create only 'read' and 'update' endpoints with custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    included_methods=[\"read\", \"update\"],\n)\n</code></pre> Note <p>This method should be called to register the endpoints with the FastAPI application. If <code>delete_schema</code> is provided on class instantiation, a hard delete endpoint is also registered. This method assumes <code>id</code> is the primary key for path parameters.</p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_routes_to_router(\n    self,\n    create_deps: Sequence[Callable] = [],\n    read_deps: Sequence[Callable] = [],\n    read_multi_deps: Sequence[Callable] = [],\n    update_deps: Sequence[Callable] = [],\n    delete_deps: Sequence[Callable] = [],\n    db_delete_deps: Sequence[Callable] = [],\n    included_methods: Optional[Sequence[str]] = None,\n    deleted_methods: Optional[Sequence[str]] = None,\n):\n    \"\"\"\n    Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n    This method registers routes for create, read, update, and delete operations with the FastAPI router,\n    allowing for custom dependency injection for each type of operation.\n\n    Args:\n        create_deps: List of functions to be injected as dependencies for the create endpoint.\n        read_deps: List of functions to be injected as dependencies for the read endpoint.\n        read_multi_deps: List of functions to be injected as dependencies for the read multiple items endpoint.\n        update_deps: List of functions to be injected as dependencies for the update endpoint.\n        delete_deps: List of functions to be injected as dependencies for the delete endpoint.\n        db_delete_deps: List of functions to be injected as dependencies for the hard delete endpoint.\n        included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n        deleted_methods: Optional list of methods to exclude. Defaults to `None`.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Selective Endpoint Creation:\n\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"],\n        )\n        ```\n\n        Excluding Specific Endpoints:\n\n        ```python\n        # Create all endpoints except 'delete' and 'db_delete'\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"delete\", \"db_delete\"],\n        )\n        ```\n\n        With Custom Dependencies and Selective Endpoints:\n\n        ```python\n        def get_current_user(...):\n            ...\n\n        # Create only 'read' and 'update' endpoints with custom dependencies\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            included_methods=[\"read\", \"update\"],\n        )\n        ```\n\n    Note:\n        This method should be called to register the endpoints with the FastAPI application.\n        If `delete_schema` is provided on class instantiation, a hard delete endpoint is also registered.\n        This method assumes `id` is the primary key for path parameters.\n    \"\"\"\n    if (included_methods is not None) and (deleted_methods is not None):\n        raise ValueError(\n            \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n        )\n\n    if included_methods is None:\n        included_methods = [\n            \"create\",\n            \"read\",\n            \"read_multi\",\n            \"update\",\n            \"delete\",\n            \"db_delete\",\n        ]\n    else:\n        try:\n            included_methods = CRUDMethods(\n                valid_methods=included_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n    if deleted_methods is None:\n        deleted_methods = []\n    else:\n        try:\n            deleted_methods = CRUDMethods(\n                valid_methods=deleted_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n    delete_description = \"Delete a\"\n    if self.delete_schema:\n        delete_description = \"Soft delete a\"\n\n    if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"create\"),\n            self._create_item(),\n            methods=[\"POST\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(create_deps),\n            description=f\"Create a new {self.model.__name__} row in the database.\",\n        )\n\n    if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"read\"),\n            self._read_item(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(read_deps),\n            response_model=self.select_schema if self.select_schema else None,\n            description=f\"Read a single {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n        if self.select_schema is not None:\n            response_model: Optional[\n                Type[Union[PaginatedListResponse[Any], ListResponse[Any]]]\n            ] = Union[\n                self.paginated_response_model,  # type: ignore\n                self.list_response_model,  # type: ignore\n            ]\n        else:\n            response_model = None\n\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"read_multi\"),\n            self._read_items(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(read_multi_deps),\n            response_model=response_model,\n            description=(\n                f\"Read multiple {self.model.__name__} rows from the database.\\n\\n\"\n                f\"- Use page &amp; itemsPerPage for paginated results\\n\"\n                f\"- Use offset &amp; limit for specific ranges\\n\"\n                f\"- Returns paginated response when using page/itemsPerPage\\n\"\n                f\"- Returns simple list response when using offset/limit\"\n            ),\n        )\n\n    if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"update\"),\n            self._update_item(),\n            methods=[\"PATCH\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(update_deps),\n            description=f\"Update an existing {self.model.__name__} row in the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n        path = self._get_endpoint_path(operation=\"delete\")\n        self.router.add_api_route(\n            path,\n            self._delete_item(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(delete_deps),\n            description=f\"{delete_description} {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\n        (\"db_delete\" in included_methods)\n        and (\"db_delete\" not in deleted_methods)\n        and self.delete_schema\n    ):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"db_delete\"),\n            self._db_delete(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=_inject_dependencies(db_delete_deps),\n            description=f\"Permanently delete a {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n</code></pre>"},{"location":"api/fastcrud/","title":"FastCRUD API Reference","text":"<p><code>FastCRUD</code> is a base class for CRUD operations on a model, utilizing Pydantic schemas for data validation and serialization.</p>"},{"location":"api/fastcrud/#class-definition","title":"Class Definition","text":"<p>             Bases: <code>Generic[ModelType, CreateSchemaType, UpdateSchemaType, UpdateSchemaInternalType, DeleteSchemaType, SelectSchemaType]</code></p> <p>Base class for CRUD operations on a model.</p> <p>This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model, utilizing Pydantic schemas for data validation and serialization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[ModelType]</code> <p>The SQLAlchemy model type.</p> required <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to <code>\"is_deleted\"</code>.</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to <code>\"deleted_at\"</code>.</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to <code>\"updated_at\"</code>.</p> <code>'updated_at'</code> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new record in the database from the provided Pydantic schema.</p> <code>select</code> <p>Generates a SQL Alchemy <code>Select</code> statement with optional filtering and sorting.</p> <code>get</code> <p>Retrieves a single record based on filters. Supports advanced filtering through comparison operators like <code>__gt</code>, <code>__lt</code>, etc.</p> <code>exists</code> <p>Checks if a record exists based on the provided filters.</p> <code>count</code> <p>Counts the number of records matching the provided filters.</p> <code>get_multi</code> <p>Fetches multiple records with optional sorting, pagination, and model conversion.</p> <code>get_joined</code> <p>Performs a join operation with another model, supporting custom join conditions and selection of specific columns.</p> <code>get_multi_joined</code> <p>Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.</p> <code>get_multi_by_cursor</code> <p>Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.</p> <code>update</code> <p>Updates an existing record or multiple records based on specified filters.</p> <code>db_delete</code> <p>Hard deletes a record or multiple records from the database based on provided filters.</p> <code>delete</code> <p>Soft deletes a record if it has an <code>\"is_deleted\"</code> attribute (or other attribute as defined by <code>is_deleted_column</code>); otherwise, performs a hard delete.</p> <p>Examples:</p> Models and Schemas Used Below <code>customer/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>product/model.py</code> <pre><code>from sqlalchemy import Column, Integer, Numeric, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Product(Base):\n    __tablename__ = \"product\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Numeric)\n</code></pre> <code>product/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadProductSchema(BaseModel):\n    id: int\n    name: str | None = None\n    price: float | None = None\n</code></pre> <code>order/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n    id = Column(Integer, primary_key=True)\n    customer_id = Column(Integer, ForeignKey(\"customer.id\"))\n    product_id = Column(Integer, ForeignKey(\"product.id\"))\n    quantity = Column(Integer)\n</code></pre> <code>order/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadOrderSchema(BaseModel):\n    id: int\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n</code></pre> <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>tier/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadTierSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>department/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadDepartmentSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>story/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadStorySchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteStorySchema(BaseModel):\n    pass\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre> <code>task/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass ReadTaskSchema(BaseModel):\n    id: int\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass UpdateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass DeleteTaskSchema(BaseModel):\n    pass\n</code></pre> <code>profile/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Profile(Base):\n    __tablename__ = \"profile\"\n    id = Column(Integer, primary_key=True)\n    bio = Column(String)\n</code></pre> <code>profile/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadProfileSchema(BaseModel):\n    id: int\n    bio: str | None = None\n</code></pre> <code>author/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Author(Base):\n    __tablename__ = \"author\"\n    id = Column(Integer, primary_key=True)\n    profile_id = Column(Integer, ForeignKey(\"profile.id\"))\n    name = Column(String)\n</code></pre> <code>author/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadAuthorSchema(BaseModel):\n    id: int\n    profile_id: int | None = None\n    name: str | None = None\n</code></pre> <code>article/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Article(Base):\n    __tablename__ = \"article\"\n    id = Column(Integer, primary_key=True)\n    author_id = Column(Integer, ForeignKey(\"author.id\"))\n    title = Column(String)\n    content = Column(String)\n</code></pre> <code>article/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadArticleSchema(BaseModel):\n    id: int\n    author_id: int | None = None\n    title: str | None = None\n    content: str | None = None\n</code></pre> <code>Project</code>, <code>Participant</code>, <code>ProjectsParticipantsAssociation</code> <pre><code># These models taken from tests/sqlalchemy/conftest.py\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre> <code>ReadProjectSchema</code> <pre><code>class ReadProjectSchema(BaseModel):\n    id: int\n    name: str\n    description: Optional[str] = None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-1-basic-usage","title":"Example 1: Basic Usage","text":"<p>Create a FastCRUD instance for a <code>User</code> model and perform basic CRUD operations.</p> <pre><code># Assuming you have a User model (either SQLAlchemy or SQLModel)\n# pydantic schemas for creation, update and deletion and an async session `db`\nUserCRUD = FastCRUD[User, CreateUserSchema, UpdateUserSchema, None, DeleteUserSchema]\nuser_crud = UserCRUD(User)\n\n# If you don't care about typing, you can also just ignore the UserCRUD part\n# Straight up define user_crud with FastCRUD\nuser_crud = FastCRUD(User)\n\n# Create a new user\nnew_user = await user_crud.create(db, CreateUserSchema(name=\"Alice\"))\n# Read a user\nuser = await user_crud.get(db, id=new_user.id)\n# Update a user\nawait user_crud.update(db, UpdateUserSchema(email=\"alice@example.com\"), id=new_user.id)\n# Delete a user\nawait user_crud.delete(db, id=new_user.id)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-2-advanced-filtering-and-pagination","title":"Example 2: Advanced Filtering and Pagination","text":"<p>Use advanced filtering, sorting, and pagination for fetching records.</p> <pre><code>product_crud = FastCRUD(Product)\nproducts = await product_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns=['price'],\n    sort_orders=['asc'],\n)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-3-join-operations-with-custom-schemas","title":"Example 3: Join Operations with Custom Schemas","text":"<p>Perform join operations between two models using custom schemas for selection.</p> <pre><code>order_crud = FastCRUD(Order)\norders = await order_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Product,\n    join_prefix=\"product_\",\n    join_schema_to_select=ReadProductSchema,\n    offset=0,\n    limit=5,\n)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-4-cursor-pagination","title":"Example 4: Cursor Pagination","text":"<p>Implement cursor-based pagination for efficient data retrieval in large datasets.</p> <pre><code>class Comment(Base):\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"user.id\"))\n    subject = Column(String)\n    body = Column(String)\n\ncomment_crud = FastCRUD(Comment)\n\nfirst_page = await comment_crud.get_multi_by_cursor(db, limit=10)\nnext_cursor = first_page['next_cursor']\nsecond_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-5-dynamic-filtering-and-counting","title":"Example 5: Dynamic Filtering and Counting","text":"<p>Dynamically filter records based on various criteria and count the results.</p> <pre><code>task_crud = FastCRUD(Task)\ncompleted_tasks = await task_crud.get_multi(\n    db,\n    status='completed',\n)\nhigh_priority_task_count = await task_crud.count(\n    db,\n    priority='high',\n)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-6-using-custom-column-names-for-soft-delete","title":"Example 6: Using Custom Column Names for Soft Delete","text":"<p>If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the <code>FastCRUD</code> instance.</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    ...\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n\n\ncustom_user_crud = FastCRUD(\n    User,\n    is_deleted_column=\"archived\",\n    deleted_at_column=\"archived_at\",\n)\n# Now 'archived' and 'archived_at' will be used for soft delete operations.\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>class FastCRUD(\n    Generic[\n        ModelType,\n        CreateSchemaType,\n        UpdateSchemaType,\n        UpdateSchemaInternalType,\n        DeleteSchemaType,\n        SelectSchemaType,\n    ]\n):\n    \"\"\"\n    Base class for CRUD operations on a model.\n\n    This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model,\n    utilizing Pydantic schemas for data validation and serialization.\n\n    Args:\n        model: The SQLAlchemy model type.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to `\"is_deleted\"`.\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to `\"deleted_at\"`.\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to `\"updated_at\"`.\n\n    Methods:\n        create:\n            Creates a new record in the database from the provided Pydantic schema.\n\n        select:\n            Generates a SQL Alchemy `Select` statement with optional filtering and sorting.\n\n        get:\n            Retrieves a single record based on filters. Supports advanced filtering through comparison operators like `__gt`, `__lt`, etc.\n\n        exists:\n            Checks if a record exists based on the provided filters.\n\n        count:\n            Counts the number of records matching the provided filters.\n\n        get_multi:\n            Fetches multiple records with optional sorting, pagination, and model conversion.\n\n        get_joined:\n            Performs a join operation with another model, supporting custom join conditions and selection of specific columns.\n\n        get_multi_joined:\n            Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.\n\n        get_multi_by_cursor:\n            Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.\n\n        update:\n            Updates an existing record or multiple records based on specified filters.\n\n        db_delete:\n            Hard deletes a record or multiple records from the database based on provided filters.\n\n        delete:\n            Soft deletes a record if it has an `\"is_deleted\"` attribute (or other attribute as defined by `is_deleted_column`); otherwise, performs a hard delete.\n\n    Examples:\n        ??? example \"Models and Schemas Used Below\"\n\n            ??? example \"`customer/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/customer/model.py:imports\n                fastcrud/examples/customer/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`product/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/model.py:imports\n                fastcrud/examples/product/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`product/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/schemas.py:imports\n                fastcrud/examples/product/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`order/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/model.py:imports\n                fastcrud/examples/order/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`order/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/schemas.py:imports\n                fastcrud/examples/order/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`tier/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/model.py:imports\n                fastcrud/examples/tier/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`tier/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/schemas.py:imports\n                fastcrud/examples/tier/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`department/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/model.py:imports\n                fastcrud/examples/department/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`department/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/schemas.py:imports\n                fastcrud/examples/department/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`user/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/model.py:imports\n                fastcrud/examples/user/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`user/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/schemas.py:imports\n                fastcrud/examples/user/schemas.py:createschema\n                fastcrud/examples/user/schemas.py:readschema\n                fastcrud/examples/user/schemas.py:updateschema\n                fastcrud/examples/user/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`story/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/model.py:imports\n                fastcrud/examples/story/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`story/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/schemas.py:imports\n                fastcrud/examples/story/schemas.py:createschema\n                fastcrud/examples/story/schemas.py:readschema\n                fastcrud/examples/story/schemas.py:updateschema\n                fastcrud/examples/story/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`task/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/model.py:imports\n                fastcrud/examples/task/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`task/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/schemas.py:imports\n                fastcrud/examples/task/schemas.py:createschema\n                fastcrud/examples/task/schemas.py:readschema\n                fastcrud/examples/task/schemas.py:updateschema\n                fastcrud/examples/task/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`profile/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/profile/model.py:imports\n                fastcrud/examples/profile/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`profile/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/profile/schemas.py:imports\n                fastcrud/examples/profile/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`author/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/author/model.py:imports\n                fastcrud/examples/author/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`author/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/author/schemas.py:imports\n                fastcrud/examples/author/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`article/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/article/model.py:imports\n                fastcrud/examples/article/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`article/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/article/schemas.py:imports\n                fastcrud/examples/article/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`Project`, `Participant`, `ProjectsParticipantsAssociation`\"\n\n                ```python\n                # These models taken from tests/sqlalchemy/conftest.py\n                --8&lt;--\n                tests/sqlalchemy/conftest.py:model_project\n                tests/sqlalchemy/conftest.py:model_participant\n                tests/sqlalchemy/conftest.py:model_proj_parts_assoc\n                --8&lt;--\n                ```\n\n            ??? example \"`ReadProjectSchema`\"\n\n                ```python\n                class ReadProjectSchema(BaseModel):\n                    id: int\n                    name: str\n                    description: Optional[str] = None\n                ```\n\n        Example 1: Basic Usage\n        ----------------------\n\n        Create a FastCRUD instance for a `User` model and perform basic CRUD operations.\n\n        ```python\n        # Assuming you have a User model (either SQLAlchemy or SQLModel)\n        # pydantic schemas for creation, update and deletion and an async session `db`\n        UserCRUD = FastCRUD[User, CreateUserSchema, UpdateUserSchema, None, DeleteUserSchema]\n        user_crud = UserCRUD(User)\n\n        # If you don't care about typing, you can also just ignore the UserCRUD part\n        # Straight up define user_crud with FastCRUD\n        user_crud = FastCRUD(User)\n\n        # Create a new user\n        new_user = await user_crud.create(db, CreateUserSchema(name=\"Alice\"))\n        # Read a user\n        user = await user_crud.get(db, id=new_user.id)\n        # Update a user\n        await user_crud.update(db, UpdateUserSchema(email=\"alice@example.com\"), id=new_user.id)\n        # Delete a user\n        await user_crud.delete(db, id=new_user.id)\n        ```\n\n        Example 2: Advanced Filtering and Pagination\n        --------------------------------------------\n\n        Use advanced filtering, sorting, and pagination for fetching records.\n\n        ```python\n        product_crud = FastCRUD(Product)\n        products = await product_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            sort_columns=['price'],\n            sort_orders=['asc'],\n        )\n        ```\n\n        Example 3: Join Operations with Custom Schemas\n        ----------------------------------------------\n\n        Perform join operations between two models using custom schemas for selection.\n\n        ```python\n        order_crud = FastCRUD(Order)\n        orders = await order_crud.get_multi_joined(\n            db,\n            schema_to_select=ReadOrderSchema,\n            join_model=Product,\n            join_prefix=\"product_\",\n            join_schema_to_select=ReadProductSchema,\n            offset=0,\n            limit=5,\n        )\n        ```\n\n        Example 4: Cursor Pagination\n        ----------------------------\n\n        Implement cursor-based pagination for efficient data retrieval in large datasets.\n\n        ```python\n        class Comment(Base):\n            id = Column(Integer, primary_key=True)\n            user_id = Column(Integer, ForeignKey(\"user.id\"))\n            subject = Column(String)\n            body = Column(String)\n\n        comment_crud = FastCRUD(Comment)\n\n        first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n        next_cursor = first_page['next_cursor']\n        second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n        ```\n\n        Example 5: Dynamic Filtering and Counting\n        -----------------------------------------\n        Dynamically filter records based on various criteria and count the results.\n\n        ```python\n        task_crud = FastCRUD(Task)\n        completed_tasks = await task_crud.get_multi(\n            db,\n            status='completed',\n        )\n        high_priority_task_count = await task_crud.count(\n            db,\n            priority='high',\n        )\n        ```\n\n        Example 6: Using Custom Column Names for Soft Delete\n        ----------------------------------------------------\n\n        If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the `FastCRUD` instance.\n\n        ```python\n        --8&lt;--\n        fastcrud/examples/user/model.py:model_common\n        --8&lt;--\n            ...\n        --8&lt;--\n        fastcrud/examples/user/model.py:model_archived\n        --8&lt;--\n\n\n        custom_user_crud = FastCRUD(\n            User,\n            is_deleted_column=\"archived\",\n            deleted_at_column=\"archived_at\",\n        )\n        # Now 'archived' and 'archived_at' will be used for soft delete operations.\n        ```\n    \"\"\"\n\n    _SUPPORTED_FILTERS = {\n        \"eq\": lambda column: column.__eq__,\n        \"gt\": lambda column: column.__gt__,\n        \"lt\": lambda column: column.__lt__,\n        \"gte\": lambda column: column.__ge__,\n        \"lte\": lambda column: column.__le__,\n        \"ne\": lambda column: column.__ne__,\n        \"is\": lambda column: column.is_,\n        \"is_not\": lambda column: column.is_not,\n        \"like\": lambda column: column.like,\n        \"notlike\": lambda column: column.notlike,\n        \"ilike\": lambda column: column.ilike,\n        \"notilike\": lambda column: column.notilike,\n        \"startswith\": lambda column: column.startswith,\n        \"endswith\": lambda column: column.endswith,\n        \"contains\": lambda column: column.contains,\n        \"match\": lambda column: column.match,\n        \"between\": lambda column: column.between,\n        \"in\": lambda column: column.in_,\n        \"not_in\": lambda column: column.not_in,\n        \"or\": lambda column: column.or_,\n        \"not\": lambda column: column.not_,\n    }\n\n    def __init__(\n        self,\n        model: type[ModelType],\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n    ) -&gt; None:\n        self.model = model\n        self.model_col_names = [col.key for col in model.__table__.columns]\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self._primary_keys = _get_primary_keys(self.model)\n\n    def _get_sqlalchemy_filter(\n        self,\n        operator: str,\n        value: Any,\n    ) -&gt; Optional[FilterCallable]:\n        if operator in {\"in\", \"not_in\", \"between\"}:\n            if not isinstance(value, (tuple, list, set)):\n                raise ValueError(f\"&lt;{operator}&gt; filter must be tuple, list or set\")\n        return cast(Optional[FilterCallable], self._SUPPORTED_FILTERS.get(operator))\n\n    def _parse_filters(\n            self,\n            model: Optional[Union[type[ModelType], AliasedClass]] = None,\n            **kwargs\n    ) -&gt; list[ColumnElement]:\n        \"\"\"Parse and convert filter arguments into SQLAlchemy filter conditions.\n\n        Args:\n            model: The model to apply filters to. Defaults to self.model\n            **kwargs: Filter arguments in the format field_name__operator=value\n\n        Returns:\n            List of SQLAlchemy filter conditions\n        \"\"\"\n        model = model or self.model\n        filters = []\n\n        for key, value in kwargs.items():\n            if \"__\" not in key:\n                filters.extend(self._handle_simple_filter(model, key, value))\n                continue\n\n            field_name, operator = key.rsplit(\"__\", 1)\n            model_column = self._get_column(model, field_name)\n\n            if operator == \"or\":\n                filters.extend(self._handle_or_filter(model_column, value))\n            elif operator == \"not\":\n                filters.extend(self._handle_not_filter(model_column, value))\n            else:\n                filters.extend(self._handle_standard_filter(model_column, operator, value))\n\n        return filters\n\n    def _handle_simple_filter(\n            self,\n            model: Union[type[ModelType], AliasedClass],\n            key: str,\n            value: Any\n    ) -&gt; list[ColumnElement]:\n        \"\"\"Handle simple equality filters (e.g., name='John').\"\"\"\n        col = getattr(model, key, None)\n        return [col == value] if col is not None else []\n\n    def _handle_or_filter(\n            self,\n            col: Column,\n            value: dict\n    ) -&gt; list[ColumnElement]:\n        \"\"\"Handle OR conditions (e.g., age__or={'gt': 18, 'lt': 65}).\"\"\"\n        if not isinstance(value, dict):  # pragma: no cover\n            raise ValueError(\"OR filter value must be a dictionary\")\n\n        or_conditions = []\n        for or_op, or_value in value.items():\n            sqlalchemy_filter = self._get_sqlalchemy_filter(or_op, or_value)\n            if sqlalchemy_filter:\n                condition = (\n                    sqlalchemy_filter(col)(*or_value)\n                    if or_op == \"between\"\n                    else sqlalchemy_filter(col)(or_value)\n                )\n                or_conditions.append(condition)\n\n        return [or_(*or_conditions)] if or_conditions else []\n\n    def _handle_not_filter(\n            self,\n            col: Column,\n            value: dict\n    ) -&gt; list[ColumnElement[bool]]:\n        \"\"\"Handle NOT conditions (e.g., age__not={'eq': 20, 'between': (30, 40)}).\"\"\"\n        if not isinstance(value, dict):  # pragma: no cover\n            raise ValueError(\"NOT filter value must be a dictionary\")\n\n        not_conditions = []\n        for not_op, not_value in value.items():\n            sqlalchemy_filter = self._get_sqlalchemy_filter(not_op, not_value)\n            if sqlalchemy_filter is None:  # pragma: no cover\n                continue\n\n            condition = (\n                sqlalchemy_filter(col)(*not_value)\n                if not_op == \"between\"\n                else sqlalchemy_filter(col)(not_value)\n            )\n            not_conditions.append(condition)\n\n        return [and_(*(not_(cond) for cond in not_conditions))] if not_conditions else []\n\n    def _handle_standard_filter(\n            self,\n            col: Column[Any],\n            operator: str,\n            value: Any\n    ) -&gt; list[ColumnElement[bool]]:\n        \"\"\"Handle standard comparison operators (e.g., age__gt=18).\"\"\"\n        sqlalchemy_filter = self._get_sqlalchemy_filter(operator, value)\n        if sqlalchemy_filter is None:  # pragma: no cover\n            return []\n\n        condition = (\n            sqlalchemy_filter(col)(*value)\n            if operator == \"between\"\n            else sqlalchemy_filter(col)(value)\n        )\n        return [condition]\n\n    def _get_column(\n            self,\n            model: Union[type[ModelType], AliasedClass],\n            field_name: str\n    ) -&gt; Column[Any]:\n        \"\"\"Get column from model, raising ValueError if not found.\"\"\"\n        model_column = getattr(model, field_name, None)\n        if model_column is None:\n            raise ValueError(f\"Invalid filter column: {field_name}\")\n        return cast(Column[Any], model_column)\n\n    def _apply_sorting(\n        self,\n        stmt: Select,\n        sort_columns: Union[str, list[str]],\n        sort_orders: Optional[Union[str, list[str]]] = None,\n    ) -&gt; Select:\n        \"\"\"\n        Apply sorting to a SQLAlchemy query based on specified column names and sort orders.\n\n        Args:\n            stmt: The SQLAlchemy `Select` statement to which sorting will be applied.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders corresponding\n                to the columns in `sort_columns`. If not provided, defaults to `\"asc\"` for each column.\n\n        Raises:\n            ValueError: Raised if sort orders are provided without corresponding sort columns,\n                or if an invalid sort order is provided (not `\"asc\"` or `\"desc\"`).\n            ArgumentError: Raised if an invalid column name is provided that does not exist in the model.\n\n        Returns:\n            The modified `Select` statement with sorting applied.\n\n        Examples:\n            Applying ascending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'name')\n\n            Applying descending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'age', 'desc')\n\n            Applying mixed sort orders on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'], ['asc', 'desc'])\n\n            Applying ascending sort on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'])\n\n        Note:\n            This method modifies the passed `Select` statement in-place by applying the `order_by` clause\n            based on the provided column names and sort orders.\n        \"\"\"\n        if sort_orders and not sort_columns:\n            raise ValueError(\"Sort orders provided without corresponding sort columns.\")\n\n        if sort_columns:\n            if not isinstance(sort_columns, list):\n                sort_columns = [sort_columns]\n\n            if sort_orders:\n                if not isinstance(sort_orders, list):\n                    sort_orders = [sort_orders] * len(sort_columns)\n                if len(sort_columns) != len(sort_orders):\n                    raise ValueError(\n                        \"The length of sort_columns and sort_orders must match.\"\n                    )\n\n                for idx, order in enumerate(sort_orders):\n                    if order not in [\"asc\", \"desc\"]:\n                        raise ValueError(\n                            f\"Invalid sort order: {order}. Only 'asc' or 'desc' are allowed.\"\n                        )\n\n            validated_sort_orders = (\n                [\"asc\"] * len(sort_columns) if not sort_orders else sort_orders\n            )\n\n            for idx, column_name in enumerate(sort_columns):\n                column = getattr(self.model, column_name, None)\n                if not column:\n                    raise ArgumentError(f\"Invalid column name: {column_name}\")\n\n                order = validated_sort_orders[idx]\n                stmt = stmt.order_by(asc(column) if order == \"asc\" else desc(column))\n\n        return stmt\n\n    def _prepare_and_apply_joins(\n        self,\n        stmt: Select,\n        joins_config: list[JoinConfig],\n        use_temporary_prefix: bool = False,\n    ):\n        \"\"\"\n        Applies joins to the given SQL statement based on a list of `JoinConfig` objects.\n\n        Args:\n            stmt: The initial SQL statement.\n            joins_config: Configurations for all joins.\n            use_temporary_prefix: Whether to use or not an additional prefix for joins. Default `False`.\n\n        Returns:\n            The modified SQL statement with joins applied.\n        \"\"\"\n        for join in joins_config:\n            model = join.alias or join.model\n            join_select = _extract_matching_columns_from_schema(\n                model,\n                join.schema_to_select,\n                join.join_prefix,\n                join.alias,\n                use_temporary_prefix,\n            )\n            joined_model_filters = self._parse_filters(\n                model=model, **(join.filters or {})\n            )\n\n            if join.join_type == \"left\":\n                stmt = stmt.outerjoin(model, join.join_on).add_columns(*join_select)\n            elif join.join_type == \"inner\":\n                stmt = stmt.join(model, join.join_on).add_columns(*join_select)\n            else:  # pragma: no cover\n                raise ValueError(f\"Unsupported join type: {join.join_type}.\")\n            if joined_model_filters:\n                stmt = stmt.filter(*joined_model_filters)\n\n        return stmt\n\n    async def create(\n        self, db: AsyncSession, object: CreateSchemaType, commit: bool = True\n    ) -&gt; ModelType:\n        \"\"\"\n        Create a new record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            object: The Pydantic schema containing the data to be saved.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n\n        Returns:\n            The created database object.\n        \"\"\"\n        object_dict = object.model_dump()\n        db_object: ModelType = self.model(**object_dict)\n        db.add(db_object)\n        if commit:\n            await db.commit()\n        return db_object\n\n    async def select(\n        self,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        **kwargs: Any,\n    ) -&gt; Select:\n        \"\"\"\n        Constructs a SQL Alchemy `Select` statement with optional column selection, filtering, and sorting.\n\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            schema_to_select: Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.\n            sort_columns: A single column name or list of column names to sort the query results by. Must be used in conjunction with `sort_orders`.\n            sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders, corresponding to each column in `sort_columns`. If not specified, defaults to ascending order for all `sort_columns`.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n        Returns:\n            An SQL Alchemy `Select` statement object that can be executed or further modified.\n\n        Examples:\n            Selecting specific columns with filtering and sorting:\n\n            ```python\n            stmt = await user_crud.select(\n                schema_to_select=ReadUserSchema,\n                sort_columns=['age', 'name'],\n                sort_orders=['asc', 'desc'],\n                age__gt=18,\n            )\n            ```\n\n            Creating a statement to select all users without any filters:\n\n            ```python\n            stmt = await user_crud.select()\n            ```\n\n            Selecting users with a specific `role`, ordered by `name`:\n\n            ```python\n            stmt = await user_crud.select(\n                schema_to_select=UserReadSchema,\n                sort_columns='name',\n                role='admin',\n            )\n            ```\n\n        Note:\n            This method does not execute the generated SQL statement.\n            Use `db.execute(stmt)` to run the query and fetch results.\n        \"\"\"\n        to_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        filters = self._parse_filters(**kwargs)\n        stmt = select(*to_select).filter(*filters)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n        return stmt\n\n    async def get(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict, SelectSchemaType]]:\n        \"\"\"\n        Fetches a single record based on specified filters.\n\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            schema_to_select: Optional Pydantic schema for selecting specific columns.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n            one_or_none: Flag to get strictly one or no result. Multiple results are not allowed.\n            **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n        Raises:\n            ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n        Returns:\n            A dictionary or a Pydantic model instance of the fetched database row, or `None` if no match is found.\n\n        Examples:\n            Fetch a user by ID:\n\n            ```python\n            user = await user_crud.get(db, id=1)\n            ```\n\n            Fetch a user with an age greater than 30:\n\n            ```python\n            user = await user_crud.get(db, age__gt=30)\n            ```\n\n            Fetch a user with a registration date before Jan 1, 2020:\n\n            ```python\n            user = await user_crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Fetch a user not equal to a specific username:\n\n            ```python\n            user = await user_crud.get(db, username__ne='admin')\n            ```\n        \"\"\"\n        stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n        db_row = await db.execute(stmt)\n        result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n        if result is None:\n            return None\n        out: dict = dict(result._mapping)\n        if not return_as_model:\n            return out\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        return schema_to_select(**out)\n\n    def _get_pk_dict(self, instance):\n        return {pk.name: getattr(instance, pk.name) for pk in self._primary_keys}\n\n    async def upsert(\n        self,\n        db: AsyncSession,\n        instance: Union[UpdateSchemaType, CreateSchemaType],\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n    ) -&gt; Union[SelectSchemaType, dict[str, Any], None]:\n        \"\"\"Update the instance or create it if it doesn't exists.\n\n        Note: This method will perform two transactions to the database (get and create or update).\n\n        Args:\n            db: The database session to use for the operation.\n            instance: A Pydantic schema representing the instance.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Defaults to `None`.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n\n        Returns:\n            The created or updated instance\n        \"\"\"\n        _pks = self._get_pk_dict(instance)\n        schema_to_select = schema_to_select or type(instance)  # type: ignore\n        db_instance = await self.get(\n            db,\n            schema_to_select=schema_to_select,  # type: ignore\n            return_as_model=return_as_model,\n            **_pks,\n        )\n        if db_instance is None:\n            db_instance = await self.create(db, instance)  # type: ignore\n            db_instance = schema_to_select.model_validate(  # type: ignore\n                db_instance, from_attributes=True\n            )\n        else:\n            await self.update(db, instance)  # type: ignore\n            db_instance = await self.get(\n                db,\n                schema_to_select=schema_to_select,  # type: ignore\n                return_as_model=return_as_model,\n                **_pks,\n            )\n\n        return db_instance\n\n    async def upsert_multi(\n        self,\n        db: AsyncSession,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        commit: bool = False,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        update_override: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"\n        Upsert multiple records in the database. The underlying implementation varies based on the database dialect.\n\n        Args:\n            db: The database session to use for the operation.\n            instances: A list of Pydantic schemas representing the instances to upsert.\n            commit: If True, commits the transaction immediately. Default is False.\n            return_columns: Optional list of column names to return after the upsert operation.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Required if return_as_model is True.\n            return_as_model: If True, returns data as instances of the specified Pydantic model.\n            update_override: Optional dictionary to override the update values for the upsert operation.\n            **kwargs: Filters to identify the record(s) to update on conflict, supporting advanced comparison operators for refined querying.\n\n        Returns:\n            The updated record(s) as a dictionary or Pydantic model instance or None, depending on the value of `return_as_model` and `return_columns`.\n\n        Raises:\n            ValueError: If the MySQL dialect is used with filters, return_columns, schema_to_select, or return_as_model.\n            NotImplementedError: If the database dialect is not supported for upsert multi.\n        \"\"\"\n        if update_override is None:\n            update_override = {}\n        filters = self._parse_filters(**kwargs)\n\n        if db.bind.dialect.name == \"postgresql\":\n            statement, params = await self._upsert_multi_postgresql(\n                instances, filters, update_override\n            )\n        elif db.bind.dialect.name == \"sqlite\":\n            statement, params = await self._upsert_multi_sqlite(\n                instances, filters, update_override\n            )\n        elif db.bind.dialect.name in [\"mysql\", \"mariadb\"]:\n            if filters:\n                raise ValueError(\n                    \"MySQL does not support filtering on insert operations.\"\n                )\n            if return_columns or schema_to_select or return_as_model:\n                raise ValueError(\n                    \"MySQL does not support the returning clause for insert operations.\"\n                )\n            statement, params = await self._upsert_multi_mysql(\n                instances, update_override\n            )\n        else:  # pragma: no cover\n            raise NotImplementedError(\n                f\"Upsert multi is not implemented for {db.bind.dialect.name}\"\n            )\n\n        if return_as_model:\n            return_columns = self.model_col_names\n\n        if return_columns:\n            statement = statement.returning(*[column(name) for name in return_columns])\n            db_row = await db.execute(statement, params)\n            if commit:\n                await db.commit()\n            return self._as_multi_response(\n                db_row,\n                schema_to_select=schema_to_select,\n                return_as_model=return_as_model,\n            )\n\n        await db.execute(statement, params)\n        if commit:\n            await db.commit()\n        return None\n\n    async def _upsert_multi_postgresql(\n        self,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        filters: list[ColumnElement],\n        update_set_override: dict[str, Any],\n    ) -&gt; tuple[Insert, list[dict]]:\n        statement = postgresql.insert(self.model)\n        statement = statement.on_conflict_do_update(\n            index_elements=self._primary_keys,\n            set_={\n                column.name: getattr(statement.excluded, column.name)\n                for column in self.model.__table__.columns\n                if not column.primary_key and not column.unique\n            }\n            | update_set_override,\n            where=and_(*filters) if filters else None,\n        )\n        params = [\n            self.model(**instance.model_dump()).__dict__ for instance in instances\n        ]\n        return statement, params\n\n    async def _upsert_multi_sqlite(\n        self,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        filters: list[ColumnElement],\n        update_set_override: dict[str, Any],\n    ) -&gt; tuple[Insert, list[dict]]:\n        statement = sqlite.insert(self.model)\n        statement = statement.on_conflict_do_update(\n            index_elements=self._primary_keys,\n            set_={\n                column.name: getattr(statement.excluded, column.name)\n                for column in self.model.__table__.columns\n                if not column.primary_key and not column.unique\n            }\n            | update_set_override,\n            where=and_(*filters) if filters else None,\n        )\n        params = [\n            self.model(**instance.model_dump()).__dict__ for instance in instances\n        ]\n        return statement, params\n\n    async def _upsert_multi_mysql(\n        self,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        update_set_override: dict[str, Any],\n    ) -&gt; tuple[Insert, list[dict]]:\n        statement = mysql.insert(self.model)\n        statement = statement.on_duplicate_key_update(\n            {\n                column.name: getattr(statement.inserted, column.name)\n                for column in self.model.__table__.columns\n                if not column.primary_key\n                and not column.unique\n                and column.name != self.deleted_at_column\n            }\n            | update_set_override,\n        )\n        params = [\n            self.model(**instance.model_dump()).__dict__ for instance in instances\n        ]\n        return statement, params\n\n    async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n        \"\"\"\n        Checks if any records exist that match the given filter conditions.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n        Returns:\n            `True` if at least one record matches the filter conditions, `False` otherwise.\n\n        Examples:\n            Check if a user with a specific ID exists:\n\n            ```python\n            exists = await user_crud.exists(db, id=1)\n            ```\n\n            Check if any user is older than 30:\n\n            ```python\n            exists = await user_crud.exists(db, age__gt=30)\n            ```\n\n            Check if any user was registered before Jan 1, 2020:\n\n            ```python\n            exists = await user_crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Check if a username other than `admin` exists:\n\n            ```python\n            exists = await user_crud.exists(db, username__ne='admin')\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        stmt = select(self.model).filter(*filters).limit(1)\n\n        result = await db.execute(stmt)\n        return result.first() is not None\n\n    async def count(\n        self,\n        db: AsyncSession,\n        joins_config: Optional[list[JoinConfig]] = None,\n        **kwargs: Any,\n    ) -&gt; int:\n        \"\"\"\n        Counts records that match specified filters.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Can also count records based on a configuration of joins, useful for complex queries involving relationships.\n\n        Args:\n            db: The database session to use for the operation.\n            joins_config: Optional configuration for applying joins in the count query.\n            **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n        Returns:\n            The total number of records matching the filter conditions.\n\n        Examples:\n            Count users by ID:\n\n            ```python\n            count = await user_crud.count(db, id=1)\n            ```\n\n            Count users older than 30:\n\n            ```python\n            count = await user_crud.count(db, age__gt=30)\n            ```\n\n            Count users with a username other than `admin`:\n\n            ```python\n            count = await user_crud.count(db, username__ne='admin')\n            ```\n\n            Count projects with at least one participant (many-to-many relationship):\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                ),\n            ]\n            project_crud = FastCRUD(Project)\n            count = await project_crud.count(db, joins_config=joins_config)\n            ```\n\n            Count projects by a specific participant name (filter applied on a joined model):\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'name': 'Jane Doe'},\n                ),\n            ]\n            count = await project_crud.count(db, joins_config=joins_config)\n            ```\n        \"\"\"\n        primary_filters = self._parse_filters(**kwargs)\n\n        if joins_config is not None:\n            primary_keys = [p.name for p in _get_primary_keys(self.model)]\n            if not any(primary_keys):  # pragma: no cover\n                raise ValueError(\n                    f\"The model '{self.model.__name__}' does not have a primary key defined, which is required for counting with joins.\"\n                )\n            to_select = [\n                getattr(self.model, pk).label(f\"distinct_{pk}\") for pk in primary_keys\n            ]\n            base_query = select(*to_select)\n\n            for join in joins_config:\n                join_model = join.alias or join.model\n                join_filters = (\n                    self._parse_filters(model=join_model, **join.filters)\n                    if join.filters\n                    else []\n                )\n\n                if join.join_type == \"inner\":\n                    base_query = base_query.join(join_model, join.join_on)\n                else:\n                    base_query = base_query.outerjoin(join_model, join.join_on)\n\n                if join_filters:\n                    base_query = base_query.where(*join_filters)\n\n            if primary_filters:\n                base_query = base_query.where(*primary_filters)\n\n            subquery = base_query.subquery()\n            count_query = select(func.count()).select_from(subquery)\n        else:\n            count_query = select(func.count()).select_from(self.model)\n            if primary_filters:\n                count_query = count_query.where(*primary_filters)\n\n        total_count: Optional[int] = await db.scalar(count_query)\n        if total_count is None:\n            raise ValueError(\"Could not find the count.\")\n\n        return total_count\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        return_total_count: bool = True,\n        **kwargs: Any,\n    ) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]:\n        \"\"\"\n        Fetches multiple records based on filters, supporting sorting, pagination.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            offset: Starting index for records to fetch, useful for pagination.\n            limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n            sort_columns: Column names to sort the results by.\n            sort_orders: Corresponding sort orders (`\"asc\"`, `\"desc\"`) for each column in `sort_columns`.\n            return_as_model: If `True`, returns data as instances of the specified Pydantic model.\n            return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n        Returns:\n            A dictionary containing the data list and optionally the total count:\n            - With return_as_model=True: Dict with \"data\": List[SelectSchemaType]\n            - With return_as_model=False: Dict with \"data\": List[Dict[str, Any]]\n            - If return_total_count=True, includes \"total_count\": int\n\n        Raises:\n            ValueError: If `limit` or `offset` is negative, or if `schema_to_select` is required but not provided or invalid.\n\n        Examples:\n            Fetch the first 10 users:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                0,\n                10,\n            )\n            ```\n\n            Fetch next 10 users with sorted by username:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                10,\n                10,\n                sort_columns='username',\n                sort_orders='desc',\n            )\n            ```\n\n            Fetch 10 users older than 30, sorted by age in descending order:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                offset=0,\n                limit=10,\n                sort_columns='age',\n                sort_orders='desc',\n                age__gt=30,\n            )\n            ```\n\n            Fetch 10 users with a registration date before Jan 1, 2020:\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                offset=0,\n                limit=10,\n                registration_date__lt=datetime(2020, 1, 1),\n            )\n            ```\n\n            Fetch 10 users with a username other than `admin`, returning as model instances (ensure appropriate schema is passed):\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                offset=0,\n                limit=10,\n                schema_to_select=ReadUserSchema,\n                return_as_model=True,\n                username__ne='admin',\n            )\n            ```\n\n            Fetch users with filtering and multiple column sorting:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                0,\n                10,\n                sort_columns=['username', 'email'],\n                sort_orders=['asc', 'desc'],\n                is_active=True,\n            )\n            ```\n        \"\"\"\n        if (limit is not None and limit &lt; 0) or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        stmt = await self.select(\n            schema_to_select=schema_to_select,\n            sort_columns=sort_columns,\n            sort_orders=sort_orders,\n            **kwargs,\n        )\n\n        if offset:\n            stmt = stmt.offset(offset)\n        if limit is not None:\n            stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        response: dict[str, Any] = {\"data\": data}\n\n        if return_total_count:\n            total_count = await self.count(db=db, **kwargs)\n            response[\"total_count\"] = total_count\n\n        if return_as_model:\n            if not schema_to_select:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                model_data = [schema_to_select(**row) for row in data]\n                response[\"data\"] = model_data\n            except ValidationError as e:\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n\n        return response\n\n    async def get_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_model: Optional[ModelType] = None,\n        join_on: Optional[Union[Join, BinaryExpression]] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass] = None,\n        join_filters: Optional[dict] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        nest_joins: bool = False,\n        relationship_type: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"\n        Fetches a single record with one or multiple joins on other models. If `join_on` is not provided, the method attempts\n        to automatically detect the join condition using foreign key relationships. For multiple joins, use `joins_config` to\n        specify each join configuration.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_model: The model to join with.\n            join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n            alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n            join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n            joins_config: A list of `JoinConfig` instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.\n            nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n            relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n            **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary representing the joined record, or `None` if no record matches the criteria.\n\n        Raises:\n            ValueError: If both single join parameters and `joins_config` are used simultaneously.\n            ArgumentError: If any provided model in `joins_config` is not recognized or invalid.\n            NoResultFound: If no record matches the criteria with the provided filters.\n\n        Examples:\n            Simple example: Joining `User` and `Tier` models without explicitly providing `join_on`\n\n            ```python\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n            )\n            ```\n\n            Fetch a user and their associated tier, filtering by user ID:\n\n            ```python\n            result = await user_crud.get_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                id=1,\n            )\n            ```\n\n            Fetch a user and their associated tier, where the user's age is greater than 30:\n\n            ```python\n            result = await user_crud.get_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                age__gt=30,\n            )\n            ```\n\n            Fetch a user and their associated tier, excluding users with the `admin` username:\n\n            ```python\n            result = await user_crud.get_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                username__ne='admin',\n            )\n            ```\n\n            Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n\n            ```python\n            from sqlalchemy import and_\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                username=\"john_doe\",\n            )\n            ```\n\n            Example of using `joins_config` for multiple joins:\n\n            ```python\n            from fastcrud import JoinConfig\n\n            # Using same User/Tier/Department models/schemas as above.\n\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=ReadTierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=ReadDepartmentSchema,\n                        join_type=\"inner\",\n                    ),\n                ],\n            )\n            ```\n\n            Using `alias` for joining the same model multiple times:\n            ```python\n            from fastcrud import aliased\n\n            owner_alias = aliased(ModelTest, name=\"owner\")\n            user_alias = aliased(ModelTest, name=\"user\")\n\n            result = await crud.get_joined(\n                db=session,\n                schema_to_select=BookingSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.owner_id == owner_alias.id,\n                        join_prefix=\"owner_\",\n                        alias=owner_alias,\n                        schema_to_select=UserSchema,\n                    ),\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.user_id == user_alias.id,\n                        join_prefix=\"user_\",\n                        alias=user_alias,\n                        schema_to_select=UserSchema,\n                    ),\n                ],\n                id=1,\n            )\n            ```\n\n            Fetching a single project and its associated participants where a participant has a specific role:\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'role': 'Designer'},\n                ),\n            ]\n\n            project_crud = FastCRUD(Project)\n\n            project = await project_crud.get_joined(\n                db=session,\n                schema_to_select=ReadProjectSchema,\n                joins_config=joins_config,\n            )\n            ```\n\n            Example of using `joins_config` for multiple joins with nested joins enabled:\n\n            ```python\n            from fastcrud import JoinConfig\n\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=ReadTierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=ReadDepartmentSchema,\n                        join_type=\"inner\",\n                    ),\n                ],\n                nest_joins=True,\n            )\n            # Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n            ```\n\n            Example using one-to-one relationship:\n\n            ```python\n            author_crud = FastCRUD(Author)\n            result = await author_crud.get_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Profile,\n                join_on=Author.profile_id == Profile.id,\n                join_schema_to_select=ReadProfileSchema,\n                nest_joins=True,\n                relationship_type='one-to-one', # note that this is the default behavior\n            )\n            # Expect 'result' to have 'profile' as a nested dictionary\n            ```\n\n            Example using one-to-many relationship:\n\n            ```python\n            result = await author_crud.get_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Article,\n                join_on=Author.id == Article.author_id,\n                join_schema_to_select=ReadArticleSchema,\n                nest_joins=True,\n                relationship_type='one-to-many',\n            )\n            # Expect 'result' to have 'posts' as a nested list of dictionaries\n            ```\n        \"\"\"\n        if joins_config and (\n            join_model or join_prefix or join_on or join_schema_to_select or alias\n        ):\n            raise ValueError(\n                \"Cannot use both single join parameters and joins_config simultaneously.\"\n            )\n        elif not joins_config and not join_model:\n            raise ValueError(\"You need one of join_model or joins_config.\")\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model,\n            schema=schema_to_select,\n        )\n        stmt: Select = select(*primary_select).select_from(self.model)\n\n        join_definitions = joins_config if joins_config else []\n        if join_model:\n            join_definitions.append(\n                JoinConfig(\n                    model=join_model,\n                    join_on=join_on,\n                    join_prefix=join_prefix,\n                    schema_to_select=join_schema_to_select,\n                    join_type=join_type,\n                    alias=alias,\n                    filters=join_filters,\n                    relationship_type=relationship_type,\n                )\n            )\n\n        stmt = self._prepare_and_apply_joins(\n            stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n        )\n        primary_filters = self._parse_filters(**kwargs)\n        if primary_filters:\n            stmt = stmt.filter(*primary_filters)\n\n        db_rows = await db.execute(stmt)\n        if any(join.relationship_type == \"one-to-many\" for join in join_definitions):\n            if nest_joins is False:  # pragma: no cover\n                raise ValueError(\n                    \"Cannot use one-to-many relationship with nest_joins=False\"\n                )\n            results = db_rows.fetchall()\n            data_list = [dict(row._mapping) for row in results]\n        else:\n            result = db_rows.first()\n            if result is not None:\n                data_list = [dict(result._mapping)]\n            else:\n                data_list = []\n\n        if data_list:\n            if nest_joins:\n                nested_data: dict = {}\n                for data in data_list:\n                    nested_data = _nest_join_data(\n                        data,\n                        join_definitions,\n                        nested_data=nested_data,\n                    )\n                return nested_data\n            return data_list[0]\n\n        return None\n\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_model: Optional[type[ModelType]] = None,\n        join_on: Optional[Any] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass[Any]] = None,\n        join_filters: Optional[dict] = None,\n        nest_joins: bool = False,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        joins_config: Optional[list[JoinConfig]] = None,\n        return_total_count: bool = True,\n        relationship_type: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_model: The model to join with.\n            join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n            alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n            join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n            nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n            offset: The offset (number of records to skip) for pagination.\n            limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders corresponding to the columns in `sort_columns`. If not provided, defaults to `\"asc\"` for each column.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n            joins_config: List of `JoinConfig` instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.\n            return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n            relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n            **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary containing the fetched rows under `\"data\"` key and total count under `\"total_count\"`.\n\n        Raises:\n            ValueError: If either `limit` or `offset` are negative, or if `schema_to_select` is required but not provided or invalid.\n                        Also if both `joins_config` and any of the single join parameters are provided or none of `joins_config` and `join_model` is provided.\n\n        Examples:\n            Fetching multiple `User` records joined with `Tier` records, using left join, returning raw data:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                offset=0,\n                limit=10,\n            )\n            ```\n\n            Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                sort_columns='username',\n                sort_orders='asc',\n                age__gt=30,\n            )\n            ```\n\n            Fetch users joined with their tiers, excluding users with `admin` username, returning as model instances:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                return_as_model=True,\n                username__ne='admin',\n            )\n            ```\n\n            Fetching and sorting by username in descending order, returning as Pydantic model:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                offset=0,\n                limit=10,\n                sort_columns=['username'],\n                sort_orders=['desc'],\n                return_as_model=True,\n            )\n            ```\n\n            Fetching with complex conditions and custom join, returning as Pydantic model:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_on=User.tier_id == Tier.id,\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                offset=0,\n                limit=10,\n                return_as_model=True,\n                is_active=True,\n            )\n            ```\n\n            Example using `joins_config` for multiple joins:\n\n            ```python\n            from fastcrud import JoinConfig\n\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=ReadTierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=ReadDepartmentSchema,\n                        join_type=\"inner\",\n                    ),\n                ],\n                offset=0,\n                limit=10,\n                sort_columns='username',\n                sort_orders='asc',\n            )\n            ```\n\n            Example using `alias` for multiple joins, with pagination, sorting, and model conversion:\n            ```python\n            from fastcrud import JoinConfig, FastCRUD, aliased\n\n            # Aliasing for self-joins or multiple joins on the same table\n            owner_alias = aliased(ModelTest, name=\"owner\")\n            user_alias = aliased(ModelTest, name=\"user\")\n\n            # Initialize your FastCRUD instance for BookingModel\n            crud = FastCRUD(BookingModel)\n\n            result = await crud.get_multi_joined(\n                db=session,\n                schema_to_select=BookingSchema,  # Primary model schema\n                joins_config=[\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.owner_id == owner_alias.id,\n                        join_prefix=\"owner_\",\n                        schema_to_select=UserSchema,  # Schema for the joined model\n                        alias=owner_alias,\n                    ),\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.user_id == user_alias.id,\n                        join_prefix=\"user_\",\n                        schema_to_select=UserSchema,\n                        alias=user_alias,\n                    )\n                ],\n                offset=10,  # Skip the first 10 records\n                limit=5,  # Fetch up to 5 records\n                sort_columns=['booking_date'],  # Sort by booking_date\n                sort_orders=['desc'],  # In descending order\n            )\n            ```\n\n            Fetching multiple project records and their associated participants where participants have a specific role:\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'role': 'Developer'},\n                ),\n            ]\n\n            project_crud = FastCRUD(Project)\n\n            projects = await project_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadProjectSchema,\n                limit=10,\n                joins_config=joins_config,\n            )\n            ```\n\n            Fetching a list of stories, each with nested details of associated tasks and task creators, using nested joins:\n\n            ```python\n            story_crud = FastCRUD(Story)\n            stories = await story_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadStorySchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Task,\n                        join_on=Story.id == Task.story_id,\n                        join_prefix=\"task_\",\n                        schema_to_select=ReadTaskSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=User,\n                        join_on=Task.creator_id == User.id,\n                        join_prefix=\"creator_\",\n                        schema_to_select=ReadUserSchema,\n                        join_type=\"left\",\n                        alias=aliased(User, name=\"task_creator\"),\n                    ),\n                ],\n                nest_joins=True,\n                offset=0,\n                limit=5,\n                sort_columns='name',\n                sort_orders='asc',\n            )\n            ```\n\n            Example using one-to-one relationship:\n\n            ```python\n            author_crud = FastCRUD(Author)\n            results = await author_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Profile,\n                join_on=Author.profile_id == Profile.id,\n                join_schema_to_select=ReadProfileSchema,\n                nest_joins=True,\n                offset=0,\n                limit=10,\n                relationship_type='one-to-one', # note that this is the default behavior\n            )\n            # Expect 'profile' to be nested as a dictionary under each user\n            ```\n\n            Example using one-to-many relationship:\n\n            ```python\n            results = await author_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Article,\n                join_on=Author.id == Article.author_id,\n                join_schema_to_select=ReadArticleSchema,\n                nest_joins=True,\n                offset=0,\n                limit=10,\n                relationship_type='one-to-many',\n            )\n            # Expect 'posts' to be nested as a list of dictionaries under each user\n            ```\n        \"\"\"\n        if joins_config and (\n            join_model\n            or join_prefix\n            or join_on\n            or join_schema_to_select\n            or alias\n            or relationship_type\n        ):\n            raise ValueError(\n                \"Cannot use both single join parameters and joins_config simultaneously.\"\n            )\n        elif not joins_config and not join_model:\n            raise ValueError(\"You need one of join_model or joins_config.\")\n\n        if (limit is not None and limit &lt; 0) or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        if relationship_type is None:\n            relationship_type = \"one-to-one\"\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        stmt: Select = select(*primary_select)\n\n        join_definitions = joins_config if joins_config else []\n        if join_model:\n            try:\n                join_definitions.append(\n                    JoinConfig(\n                        model=join_model,\n                        join_on=join_on\n                        if join_on is not None\n                        else _auto_detect_join_condition(self.model, join_model),\n                        join_prefix=join_prefix,\n                        schema_to_select=join_schema_to_select,\n                        join_type=join_type,\n                        alias=alias,\n                        filters=join_filters,\n                        relationship_type=relationship_type,\n                    )\n                )\n            except ValueError as e:  # pragma: no cover\n                raise ValueError(f\"Could not configure join: {str(e)}\")\n\n        stmt = self._prepare_and_apply_joins(\n            stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n        )\n\n        primary_filters = self._parse_filters(**kwargs)\n        if primary_filters:\n            stmt = stmt.filter(*primary_filters)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n        if offset:\n            stmt = stmt.offset(offset)\n        if limit is not None:\n            stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data: list[Union[dict, SelectSchemaType]] = []\n\n        for row in result.mappings().all():\n            row_dict = dict(row)\n\n            if nest_joins:\n                row_dict = _nest_join_data(\n                    data=row_dict,\n                    join_definitions=join_definitions,\n                )\n\n            if return_as_model:\n                if schema_to_select is None:\n                    raise ValueError(\n                        \"schema_to_select must be provided when return_as_model is True.\"\n                    )\n                try:\n                    model_instance = schema_to_select(**row_dict)\n                    data.append(model_instance)\n                except ValidationError as e:\n                    raise ValueError(\n                        f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                    )\n            else:\n                data.append(row_dict)\n\n        if nest_joins and any(\n            join.relationship_type == \"one-to-many\" for join in join_definitions\n        ):\n            nested_data = _nest_multi_join_data(\n                base_primary_key=self._primary_keys[0].name,  # type: ignore[misc]\n                data=data,\n                joins_config=join_definitions,\n                return_as_model=return_as_model,\n                schema_to_select=schema_to_select if return_as_model else None,\n                nested_schema_to_select={\n                    (\n                        join.join_prefix.rstrip(\"_\")\n                        if join.join_prefix\n                        else join.model.__tablename__\n                    ): join.schema_to_select\n                    for join in join_definitions\n                    if join.schema_to_select\n                },\n            )\n        else:\n            nested_data = _handle_null_primary_key_multi_join(data, join_definitions)\n\n        response: dict[str, Any] = {\"data\": nested_data}\n\n        if return_total_count:\n            total_count: int = await self.count(\n                db=db, joins_config=joins_config, **kwargs\n            )\n            response[\"total_count\"] = total_count\n\n        return response\n\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The SQLAlchemy async session.\n            cursor: The cursor value to start fetching records from. Defaults to `None`.\n            limit: Maximum number of rows to fetch.\n            schema_to_select: Pydantic schema for selecting specific columns.\n            sort_column: Column name to use for sorting and cursor pagination.\n            sort_order: Sorting direction, either `\"asc\"` or `\"desc\"`.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n        Returns:\n            A dictionary containing the fetched rows under `\"data\"` key and the next cursor value under `\"next_cursor\"`.\n\n        Examples:\n            Fetch the first set of records (e.g., the first page in an infinite scrolling scenario):\n\n            ```python\n            first_page = await user_crud.get_multi_by_cursor(\n                db,\n                limit=10,\n                sort_column='registration_date',\n            )\n\n            # Fetch the next set of records using the cursor from the first page\n            second_page = await user_crud.get_multi_by_cursor(\n                db,\n                cursor=next_cursor,\n                limit=10,\n                sort_column='registration_date',\n                sort_order='desc',\n            )\n            ```\n\n            Fetch records with age greater than 30 using cursor-based pagination:\n\n            ```python\n            first_page = await user_crud.get_multi_by_cursor(\n                db,\n                limit=10,\n                sort_column='age',\n                sort_order='asc',\n            )\n            ```\n\n            Fetch records excluding a specific username using cursor-based pagination:\n\n            ```python\n                db,\n                limit=10,\n                sort_column='username',\n                sort_order='asc',\n                username__ne='admin',\n            )\n            ```\n\n        Note:\n            This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n            Make sure the column used for cursor pagination is indexed for performance.\n        \"\"\"\n        if limit == 0:\n            return {\"data\": [], \"next_cursor\": None}\n\n        stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n        if cursor:\n            if sort_order == \"asc\":\n                stmt = stmt.filter(getattr(self.model, sort_column) &gt; cursor)\n            else:\n                stmt = stmt.filter(getattr(self.model, sort_column) &lt; cursor)\n\n        stmt = stmt.order_by(\n            asc(getattr(self.model, sort_column))\n            if sort_order == \"asc\"\n            else desc(getattr(self.model, sort_column))\n        )\n        stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        next_cursor = None\n        if len(data) == limit:\n            if sort_order == \"asc\":\n                next_cursor = data[-1][sort_column]\n            else:\n                data[0][sort_column]\n\n        return {\"data\": data, \"next_cursor\": next_cursor}\n\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        allow_multiple: bool = False,\n        commit: bool = True,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict, SelectSchemaType]]:\n        \"\"\"\n        Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            object: A Pydantic schema or dictionary containing the update data.\n            allow_multiple: If `True`, allows updating multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            return_columns: A list of column names to return after the update. If `return_as_model` is True, all columns are returned.\n            schema_to_select: Pydantic schema for selecting specific columns from the updated record(s). Required if `return_as_model` is `True`.\n            return_as_model: If `True`, returns the updated record(s) as Pydantic model instances based on `schema_to_select`. Default is False.\n            one_or_none: If `True`, returns a single record if only one record matches the filters. Default is `False`.\n            **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n        Returns:\n            The updated record(s) as a dictionary or Pydantic model instance or `None`, depending on the value of `return_as_model` and `return_columns`.\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n            NoResultFound: If no record matches the filters. (on version 0.15.3)\n            ValueError: If extra fields not present in the model are provided in the update data.\n            ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n        Examples:\n            Update a user's email based on their ID:\n\n            ```python\n            await user_crud.update(db, {'email': 'new_email@example.com'}, id=1)\n            ```\n\n            Update users to be inactive where age is greater than 30 and allow updates to multiple records:\n\n            ```python\n            await user_crud.update(\n                db,\n                {'is_active': False},\n                allow_multiple=True,\n                age__gt=30,\n            )\n            ```\n\n            Update a user's username excluding specific user ID and prevent multiple updates:\n\n            ```python\n            await user_crud.update(\n                db,\n                {'username': 'new_username'},\n                allow_multiple=False,\n                id__ne=1,\n            )\n            ```\n\n            Update a user's email and return the updated record as a Pydantic model instance:\n\n            ```python\n            user = await user_crud.update(\n                db,\n                {'email': 'new_email@example.com'},\n                schema_to_select=ReadUserSchema,\n                return_as_model=True,\n                id=1,\n            )\n            ```\n\n            Update a user's email and return the updated record as a dictionary:\n            ```python\n            user = await user_crud.update(\n                db,\n                {'email': 'new_email@example.com'},\n                return_columns=['id', 'email'],\n                id=1,\n            )\n            ```\n        \"\"\"\n        total_count = await self.count(db, **kwargs)\n        if total_count == 0:\n            raise NoResultFound(\"No record found to update.\")\n        if not allow_multiple and total_count &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to update, found {total_count}.\"\n            )\n\n        if isinstance(object, dict):\n            update_data = object\n        else:\n            update_data = object.model_dump(exclude_unset=True)\n\n        updated_at_col = getattr(self.model, self.updated_at_column, None)\n        if updated_at_col:\n            update_data[self.updated_at_column] = datetime.now(timezone.utc)\n\n        update_data_keys = set(update_data.keys())\n        model_columns = {_column.name for _column in inspect(self.model).c}\n        extra_fields = update_data_keys - model_columns\n        if extra_fields:\n            raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n        filters = self._parse_filters(**kwargs)\n        stmt = update(self.model).filter(*filters).values(update_data)\n\n        if return_as_model:\n            return_columns = self.model_col_names\n\n        if return_columns:\n            stmt = stmt.returning(*[column(name) for name in return_columns])\n            db_row = await db.execute(stmt)\n            if commit:\n                await db.commit()\n            if allow_multiple:\n                return self._as_multi_response(\n                    db_row,\n                    schema_to_select=schema_to_select,\n                    return_as_model=return_as_model,\n                )\n            return self._as_single_response(\n                db_row,\n                schema_to_select=schema_to_select,\n                return_as_model=return_as_model,\n                one_or_none=one_or_none,\n            )\n\n        await db.execute(stmt)\n        if commit:\n            await db.commit()\n        return None\n\n    def _as_single_response(\n        self,\n        db_row: Result,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n    ) -&gt; Optional[Union[dict, SelectSchemaType]]:\n        result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n        if result is None:  # pragma: no cover\n            return None\n        out: dict = dict(result._mapping)\n        if not return_as_model:\n            return out\n        if not schema_to_select:  # pragma: no cover\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        return schema_to_select(**out)\n\n    def _as_multi_response(\n        self,\n        db_row: Result,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n    ) -&gt; dict:\n        data = [dict(row) for row in db_row.mappings()]\n\n        response: dict[str, Any] = {\"data\": data}\n\n        if return_as_model:\n            if not schema_to_select:  # pragma: no cover\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                model_data = [schema_to_select(**row) for row in data]\n                response[\"data\"] = model_data\n            except ValidationError as e:  # pragma: no cover\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n\n        return response\n\n    async def db_delete(\n        self,\n        db: AsyncSession,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Deletes a record or multiple records from the database based on specified filters.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            **kwargs: Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n        Returns:\n            None\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n\n        Examples:\n            Delete a user based on their ID:\n\n            ```python\n            await user_crud.db_delete(db, id=1)\n            ```\n\n            Delete users older than 30 years and allow deletion of multiple records:\n\n            ```python\n            await user_crud.db_delete(\n                db,\n                allow_multiple=True,\n                age__gt=30,\n            )\n            ```\n\n            Delete a user with a specific username, ensuring only one record is deleted:\n\n            ```python\n            await user_crud.db_delete(\n                db,\n                allow_multiple=False,\n                username='unique_username',\n            )\n            ```\n        \"\"\"\n        if not allow_multiple and (total_count := await self.count(db, **kwargs)) &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        filters = self._parse_filters(**kwargs)\n        stmt = delete(self.model).filter(*filters)\n        await db.execute(stmt)\n        if commit:\n            await db.commit()\n\n    async def delete(\n        self,\n        db: AsyncSession,\n        db_row: Optional[Row] = None,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Soft deletes a record or optionally multiple records if it has an `\"is_deleted\"` attribute, otherwise performs a hard delete, based on specified filters.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n            allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            **kwargs: Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n            NoResultFound: If no record matches the filters.\n\n        Returns:\n            None\n\n        Examples:\n            Soft delete a specific user by ID:\n\n            ```python\n            await user_crud.delete(db, id=1)\n            ```\n\n            Soft delete users with account registration dates before 2020, allowing deletion of multiple records:\n\n            ```python\n            await user_crud.delete(\n                db,\n                allow_multiple=True,\n                creation_date__lt=datetime(2020, 1, 1),\n            )\n            ```\n\n            Soft delete a user with a specific email, ensuring only one record is deleted:\n\n            ```python\n            await user_crud.delete(\n                db,\n                allow_multiple=False,\n                email='unique@example.com',\n            )\n            ```\n        \"\"\"\n        filters = self._parse_filters(**kwargs)\n        if db_row:\n            if hasattr(db_row, self.is_deleted_column) and hasattr(\n                db_row, self.deleted_at_column\n            ):\n                setattr(db_row, self.is_deleted_column, True)\n                setattr(db_row, self.deleted_at_column, datetime.now(timezone.utc))\n                if commit:\n                    await db.commit()\n            else:\n                await db.delete(db_row)\n            if commit:\n                await db.commit()\n            return\n\n        total_count = await self.count(db, **kwargs)\n        if total_count == 0:\n            raise NoResultFound(\"No record found to delete.\")\n        if not allow_multiple and total_count &gt; 1:\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        update_values: dict[str, Union[bool, datetime]] = {}\n        if self.deleted_at_column in self.model_col_names:\n            update_values[self.deleted_at_column] = datetime.now(timezone.utc)\n        if self.is_deleted_column in self.model_col_names:\n            update_values[self.is_deleted_column] = True\n\n        if update_values:\n            update_stmt = update(self.model).filter(*filters).values(**update_values)\n            await db.execute(update_stmt)\n\n        else:\n            delete_stmt = self.model.__table__.delete().where(*filters)\n            await db.execute(delete_stmt)\n        if commit:\n            await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.count","title":"<code>count(db, joins_config=None, **kwargs)</code>  <code>async</code>","text":"<p>Counts records that match specified filters.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Can also count records based on a configuration of joins, useful for complex queries involving relationships.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>Optional configuration for applying joins in the count query.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The total number of records matching the filter conditions.</p> <p>Examples:</p> <p>Count users by ID:</p> <pre><code>count = await user_crud.count(db, id=1)\n</code></pre> <p>Count users older than 30:</p> <pre><code>count = await user_crud.count(db, age__gt=30)\n</code></pre> <p>Count users with a username other than <code>admin</code>:</p> <pre><code>count = await user_crud.count(db, username__ne='admin')\n</code></pre> <p>Count projects with at least one participant (many-to-many relationship):</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n    ),\n]\nproject_crud = FastCRUD(Project)\ncount = await project_crud.count(db, joins_config=joins_config)\n</code></pre> <p>Count projects by a specific participant name (filter applied on a joined model):</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'name': 'Jane Doe'},\n    ),\n]\ncount = await project_crud.count(db, joins_config=joins_config)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def count(\n    self,\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any,\n) -&gt; int:\n    \"\"\"\n    Counts records that match specified filters.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Can also count records based on a configuration of joins, useful for complex queries involving relationships.\n\n    Args:\n        db: The database session to use for the operation.\n        joins_config: Optional configuration for applying joins in the count query.\n        **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n    Returns:\n        The total number of records matching the filter conditions.\n\n    Examples:\n        Count users by ID:\n\n        ```python\n        count = await user_crud.count(db, id=1)\n        ```\n\n        Count users older than 30:\n\n        ```python\n        count = await user_crud.count(db, age__gt=30)\n        ```\n\n        Count users with a username other than `admin`:\n\n        ```python\n        count = await user_crud.count(db, username__ne='admin')\n        ```\n\n        Count projects with at least one participant (many-to-many relationship):\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n            ),\n        ]\n        project_crud = FastCRUD(Project)\n        count = await project_crud.count(db, joins_config=joins_config)\n        ```\n\n        Count projects by a specific participant name (filter applied on a joined model):\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'name': 'Jane Doe'},\n            ),\n        ]\n        count = await project_crud.count(db, joins_config=joins_config)\n        ```\n    \"\"\"\n    primary_filters = self._parse_filters(**kwargs)\n\n    if joins_config is not None:\n        primary_keys = [p.name for p in _get_primary_keys(self.model)]\n        if not any(primary_keys):  # pragma: no cover\n            raise ValueError(\n                f\"The model '{self.model.__name__}' does not have a primary key defined, which is required for counting with joins.\"\n            )\n        to_select = [\n            getattr(self.model, pk).label(f\"distinct_{pk}\") for pk in primary_keys\n        ]\n        base_query = select(*to_select)\n\n        for join in joins_config:\n            join_model = join.alias or join.model\n            join_filters = (\n                self._parse_filters(model=join_model, **join.filters)\n                if join.filters\n                else []\n            )\n\n            if join.join_type == \"inner\":\n                base_query = base_query.join(join_model, join.join_on)\n            else:\n                base_query = base_query.outerjoin(join_model, join.join_on)\n\n            if join_filters:\n                base_query = base_query.where(*join_filters)\n\n        if primary_filters:\n            base_query = base_query.where(*primary_filters)\n\n        subquery = base_query.subquery()\n        count_query = select(func.count()).select_from(subquery)\n    else:\n        count_query = select(func.count()).select_from(self.model)\n        if primary_filters:\n            count_query = count_query.where(*primary_filters)\n\n    total_count: Optional[int] = await db.scalar(count_query)\n    if total_count is None:\n        raise ValueError(\"Could not find the count.\")\n\n    return total_count\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.create","title":"<code>create(db, object, commit=True)</code>  <code>async</code>","text":"<p>Create a new record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>object</code> <code>CreateSchemaType</code> <p>The Pydantic schema containing the data to be saved.</p> required <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>ModelType</code> <p>The created database object.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def create(\n    self, db: AsyncSession, object: CreateSchemaType, commit: bool = True\n) -&gt; ModelType:\n    \"\"\"\n    Create a new record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        object: The Pydantic schema containing the data to be saved.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n\n    Returns:\n        The created database object.\n    \"\"\"\n    object_dict = object.model_dump()\n    db_object: ModelType = self.model(**object_dict)\n    db.add(db_object)\n    if commit:\n        await db.commit()\n    return db_object\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.db_delete","title":"<code>db_delete(db, allow_multiple=False, commit=True, **kwargs)</code>  <code>async</code>","text":"<p>Deletes a record or multiple records from the database based on specified filters.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>allow_multiple</code> <code>bool</code> <p>If <code>True</code>, allows deleting multiple records that match the filters. If <code>False</code>, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is <code>False</code> and more than one record matches the filters.</p> <p>Examples:</p> <p>Delete a user based on their ID:</p> <pre><code>await user_crud.db_delete(db, id=1)\n</code></pre> <p>Delete users older than 30 years and allow deletion of multiple records:</p> <pre><code>await user_crud.db_delete(\n    db,\n    allow_multiple=True,\n    age__gt=30,\n)\n</code></pre> <p>Delete a user with a specific username, ensuring only one record is deleted:</p> <pre><code>await user_crud.db_delete(\n    db,\n    allow_multiple=False,\n    username='unique_username',\n)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def db_delete(\n    self,\n    db: AsyncSession,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Deletes a record or multiple records from the database based on specified filters.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        **kwargs: Filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n    Returns:\n        None\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n\n    Examples:\n        Delete a user based on their ID:\n\n        ```python\n        await user_crud.db_delete(db, id=1)\n        ```\n\n        Delete users older than 30 years and allow deletion of multiple records:\n\n        ```python\n        await user_crud.db_delete(\n            db,\n            allow_multiple=True,\n            age__gt=30,\n        )\n        ```\n\n        Delete a user with a specific username, ensuring only one record is deleted:\n\n        ```python\n        await user_crud.db_delete(\n            db,\n            allow_multiple=False,\n            username='unique_username',\n        )\n        ```\n    \"\"\"\n    if not allow_multiple and (total_count := await self.count(db, **kwargs)) &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    filters = self._parse_filters(**kwargs)\n    stmt = delete(self.model).filter(*filters)\n    await db.execute(stmt)\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.delete","title":"<code>delete(db, db_row=None, allow_multiple=False, commit=True, **kwargs)</code>  <code>async</code>","text":"<p>Soft deletes a record or optionally multiple records if it has an <code>\"is_deleted\"</code> attribute, otherwise performs a hard delete, based on specified filters.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>db_row</code> <code>Optional[Row]</code> <p>Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.</p> <code>None</code> <code>allow_multiple</code> <code>bool</code> <p>If <code>True</code>, allows deleting multiple records that match the filters. If <code>False</code>, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is <code>False</code> and more than one record matches the filters.</p> <code>NoResultFound</code> <p>If no record matches the filters.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <p>Soft delete a specific user by ID:</p> <pre><code>await user_crud.delete(db, id=1)\n</code></pre> <p>Soft delete users with account registration dates before 2020, allowing deletion of multiple records:</p> <pre><code>await user_crud.delete(\n    db,\n    allow_multiple=True,\n    creation_date__lt=datetime(2020, 1, 1),\n)\n</code></pre> <p>Soft delete a user with a specific email, ensuring only one record is deleted:</p> <pre><code>await user_crud.delete(\n    db,\n    allow_multiple=False,\n    email='unique@example.com',\n)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def delete(\n    self,\n    db: AsyncSession,\n    db_row: Optional[Row] = None,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Soft deletes a record or optionally multiple records if it has an `\"is_deleted\"` attribute, otherwise performs a hard delete, based on specified filters.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n        allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        **kwargs: Filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n        NoResultFound: If no record matches the filters.\n\n    Returns:\n        None\n\n    Examples:\n        Soft delete a specific user by ID:\n\n        ```python\n        await user_crud.delete(db, id=1)\n        ```\n\n        Soft delete users with account registration dates before 2020, allowing deletion of multiple records:\n\n        ```python\n        await user_crud.delete(\n            db,\n            allow_multiple=True,\n            creation_date__lt=datetime(2020, 1, 1),\n        )\n        ```\n\n        Soft delete a user with a specific email, ensuring only one record is deleted:\n\n        ```python\n        await user_crud.delete(\n            db,\n            allow_multiple=False,\n            email='unique@example.com',\n        )\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    if db_row:\n        if hasattr(db_row, self.is_deleted_column) and hasattr(\n            db_row, self.deleted_at_column\n        ):\n            setattr(db_row, self.is_deleted_column, True)\n            setattr(db_row, self.deleted_at_column, datetime.now(timezone.utc))\n            if commit:\n                await db.commit()\n        else:\n            await db.delete(db_row)\n        if commit:\n            await db.commit()\n        return\n\n    total_count = await self.count(db, **kwargs)\n    if total_count == 0:\n        raise NoResultFound(\"No record found to delete.\")\n    if not allow_multiple and total_count &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    update_values: dict[str, Union[bool, datetime]] = {}\n    if self.deleted_at_column in self.model_col_names:\n        update_values[self.deleted_at_column] = datetime.now(timezone.utc)\n    if self.is_deleted_column in self.model_col_names:\n        update_values[self.is_deleted_column] = True\n\n    if update_values:\n        update_stmt = update(self.model).filter(*filters).values(**update_values)\n        await db.execute(update_stmt)\n\n    else:\n        delete_stmt = self.model.__table__.delete().where(*filters)\n        await db.execute(delete_stmt)\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.exists","title":"<code>exists(db, **kwargs)</code>  <code>async</code>","text":"<p>Checks if any records exist that match the given filter conditions.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if at least one record matches the filter conditions, <code>False</code> otherwise.</p> <p>Examples:</p> <p>Check if a user with a specific ID exists:</p> <pre><code>exists = await user_crud.exists(db, id=1)\n</code></pre> <p>Check if any user is older than 30:</p> <pre><code>exists = await user_crud.exists(db, age__gt=30)\n</code></pre> <p>Check if any user was registered before Jan 1, 2020:</p> <pre><code>exists = await user_crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre> <p>Check if a username other than <code>admin</code> exists:</p> <pre><code>exists = await user_crud.exists(db, username__ne='admin')\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n    \"\"\"\n    Checks if any records exist that match the given filter conditions.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n    Returns:\n        `True` if at least one record matches the filter conditions, `False` otherwise.\n\n    Examples:\n        Check if a user with a specific ID exists:\n\n        ```python\n        exists = await user_crud.exists(db, id=1)\n        ```\n\n        Check if any user is older than 30:\n\n        ```python\n        exists = await user_crud.exists(db, age__gt=30)\n        ```\n\n        Check if any user was registered before Jan 1, 2020:\n\n        ```python\n        exists = await user_crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Check if a username other than `admin` exists:\n\n        ```python\n        exists = await user_crud.exists(db, username__ne='admin')\n        ```\n    \"\"\"\n    filters = self._parse_filters(**kwargs)\n    stmt = select(self.model).filter(*filters).limit(1)\n\n    result = await db.execute(stmt)\n    return result.first() is not None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get","title":"<code>get(db, schema_to_select=None, return_as_model=False, one_or_none=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record based on specified filters.</p> <p>This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <code>one_or_none</code> <code>bool</code> <p>Flag to get strictly one or no result. Multiple results are not allowed.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>return_as_model</code> is <code>True</code> but <code>schema_to_select</code> is not provided.</p> <p>Returns:</p> Type Description <code>Optional[Union[dict, SelectSchemaType]]</code> <p>A dictionary or a Pydantic model instance of the fetched database row, or <code>None</code> if no match is found.</p> <p>Examples:</p> <p>Fetch a user by ID:</p> <pre><code>user = await user_crud.get(db, id=1)\n</code></pre> <p>Fetch a user with an age greater than 30:</p> <pre><code>user = await user_crud.get(db, age__gt=30)\n</code></pre> <p>Fetch a user with a registration date before Jan 1, 2020:</p> <pre><code>user = await user_crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre> <p>Fetch a user not equal to a specific username:</p> <pre><code>user = await user_crud.get(db, username__ne='admin')\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, SelectSchemaType]]:\n    \"\"\"\n    Fetches a single record based on specified filters.\n\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        schema_to_select: Optional Pydantic schema for selecting specific columns.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n        one_or_none: Flag to get strictly one or no result. Multiple results are not allowed.\n        **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n    Raises:\n        ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n    Returns:\n        A dictionary or a Pydantic model instance of the fetched database row, or `None` if no match is found.\n\n    Examples:\n        Fetch a user by ID:\n\n        ```python\n        user = await user_crud.get(db, id=1)\n        ```\n\n        Fetch a user with an age greater than 30:\n\n        ```python\n        user = await user_crud.get(db, age__gt=30)\n        ```\n\n        Fetch a user with a registration date before Jan 1, 2020:\n\n        ```python\n        user = await user_crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Fetch a user not equal to a specific username:\n\n        ```python\n        user = await user_crud.get(db, username__ne='admin')\n        ```\n    \"\"\"\n    stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n    db_row = await db.execute(stmt)\n    result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n    if result is None:\n        return None\n    out: dict = dict(result._mapping)\n    if not return_as_model:\n        return out\n    if not schema_to_select:\n        raise ValueError(\n            \"schema_to_select must be provided when return_as_model is True.\"\n        )\n    return schema_to_select(**out)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_joined","title":"<code>get_joined(db, schema_to_select=None, join_model=None, join_on=None, join_prefix=None, join_schema_to_select=None, join_type='left', alias=None, join_filters=None, joins_config=None, nest_joins=False, relationship_type=None, **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record with one or multiple joins on other models. If <code>join_on</code> is not provided, the method attempts to automatically detect the join condition using foreign key relationships. For multiple joins, use <code>joins_config</code> to specify each join configuration.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_model</code> <code>Optional[ModelType]</code> <p>The model to join with.</p> <code>None</code> <code>join_on</code> <code>Optional[Union[Join, BinaryExpression]]</code> <p>SQLAlchemy Join object for specifying the <code>ON</code> clause of the join. If <code>None</code>, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If <code>None</code>, no prefix is added.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be <code>\"left\"</code> for a left outer join or <code>\"inner\"</code> for an inner join.</p> <code>'left'</code> <code>alias</code> <code>Optional[AliasedClass]</code> <p>An instance of <code>AliasedClass</code> for the join model, useful for self-joins or multiple joins on the same model. Result of <code>aliased(join_model)</code>.</p> <code>None</code> <code>join_filters</code> <code>Optional[dict]</code> <p>Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.</p> <code>None</code> <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>A list of <code>JoinConfig</code> instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.</p> <code>None</code> <code>nest_joins</code> <code>bool</code> <p>If <code>True</code>, nested data structures will be returned where joined model data are nested under the <code>join_prefix</code> as a dictionary.</p> <code>False</code> <code>relationship_type</code> <code>Optional[str]</code> <p>Specifies the relationship type, such as <code>\"one-to-one\"</code> or <code>\"one-to-many\"</code>. Used to determine how to nest the joined data. If <code>None</code>, uses <code>\"one-to-one\"</code>.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>A dictionary representing the joined record, or <code>None</code> if no record matches the criteria.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both single join parameters and <code>joins_config</code> are used simultaneously.</p> <code>ArgumentError</code> <p>If any provided model in <code>joins_config</code> is not recognized or invalid.</p> <code>NoResultFound</code> <p>If no record matches the criteria with the provided filters.</p> <p>Examples:</p> <p>Simple example: Joining <code>User</code> and <code>Tier</code> models without explicitly providing <code>join_on</code></p> <pre><code>result = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n)\n</code></pre> <p>Fetch a user and their associated tier, filtering by user ID:</p> <pre><code>result = await user_crud.get_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    id=1,\n)\n</code></pre> <p>Fetch a user and their associated tier, where the user's age is greater than 30:</p> <pre><code>result = await user_crud.get_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    age__gt=30,\n)\n</code></pre> <p>Fetch a user and their associated tier, excluding users with the <code>admin</code> username:</p> <pre><code>result = await user_crud.get_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    username__ne='admin',\n)\n</code></pre> <p>Complex example: Joining with a custom join condition, additional filter parameters, and a prefix</p> <pre><code>from sqlalchemy import and_\nresult = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    username=\"john_doe\",\n)\n</code></pre> <p>Example of using <code>joins_config</code> for multiple joins:</p> <pre><code>from fastcrud import JoinConfig\n\n# Using same User/Tier/Department models/schemas as above.\n\nresult = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=ReadTierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=ReadDepartmentSchema,\n            join_type=\"inner\",\n        ),\n    ],\n)\n</code></pre> <p>Using <code>alias</code> for joining the same model multiple times: <pre><code>from fastcrud import aliased\n\nowner_alias = aliased(ModelTest, name=\"owner\")\nuser_alias = aliased(ModelTest, name=\"user\")\n\nresult = await crud.get_joined(\n    db=session,\n    schema_to_select=BookingSchema,\n    joins_config=[\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.owner_id == owner_alias.id,\n            join_prefix=\"owner_\",\n            alias=owner_alias,\n            schema_to_select=UserSchema,\n        ),\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.user_id == user_alias.id,\n            join_prefix=\"user_\",\n            alias=user_alias,\n            schema_to_select=UserSchema,\n        ),\n    ],\n    id=1,\n)\n</code></pre></p> <p>Fetching a single project and its associated participants where a participant has a specific role:</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'role': 'Designer'},\n    ),\n]\n\nproject_crud = FastCRUD(Project)\n\nproject = await project_crud.get_joined(\n    db=session,\n    schema_to_select=ReadProjectSchema,\n    joins_config=joins_config,\n)\n</code></pre> <p>Example of using <code>joins_config</code> for multiple joins with nested joins enabled:</p> <pre><code>from fastcrud import JoinConfig\n\nresult = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=ReadTierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=ReadDepartmentSchema,\n            join_type=\"inner\",\n        ),\n    ],\n    nest_joins=True,\n)\n# Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n</code></pre> <p>Example using one-to-one relationship:</p> <pre><code>author_crud = FastCRUD(Author)\nresult = await author_crud.get_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Profile,\n    join_on=Author.profile_id == Profile.id,\n    join_schema_to_select=ReadProfileSchema,\n    nest_joins=True,\n    relationship_type='one-to-one', # note that this is the default behavior\n)\n# Expect 'result' to have 'profile' as a nested dictionary\n</code></pre> <p>Example using one-to-many relationship:</p> <pre><code>result = await author_crud.get_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Article,\n    join_on=Author.id == Article.author_id,\n    join_schema_to_select=ReadArticleSchema,\n    nest_joins=True,\n    relationship_type='one-to-many',\n)\n# Expect 'result' to have 'posts' as a nested list of dictionaries\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_joined(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_model: Optional[ModelType] = None,\n    join_on: Optional[Union[Join, BinaryExpression]] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass] = None,\n    join_filters: Optional[dict] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    nest_joins: bool = False,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"\n    Fetches a single record with one or multiple joins on other models. If `join_on` is not provided, the method attempts\n    to automatically detect the join condition using foreign key relationships. For multiple joins, use `joins_config` to\n    specify each join configuration.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_model: The model to join with.\n        join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n        alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n        join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n        joins_config: A list of `JoinConfig` instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.\n        nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n        relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n        **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary representing the joined record, or `None` if no record matches the criteria.\n\n    Raises:\n        ValueError: If both single join parameters and `joins_config` are used simultaneously.\n        ArgumentError: If any provided model in `joins_config` is not recognized or invalid.\n        NoResultFound: If no record matches the criteria with the provided filters.\n\n    Examples:\n        Simple example: Joining `User` and `Tier` models without explicitly providing `join_on`\n\n        ```python\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n        )\n        ```\n\n        Fetch a user and their associated tier, filtering by user ID:\n\n        ```python\n        result = await user_crud.get_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            id=1,\n        )\n        ```\n\n        Fetch a user and their associated tier, where the user's age is greater than 30:\n\n        ```python\n        result = await user_crud.get_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            age__gt=30,\n        )\n        ```\n\n        Fetch a user and their associated tier, excluding users with the `admin` username:\n\n        ```python\n        result = await user_crud.get_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            username__ne='admin',\n        )\n        ```\n\n        Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n\n        ```python\n        from sqlalchemy import and_\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            username=\"john_doe\",\n        )\n        ```\n\n        Example of using `joins_config` for multiple joins:\n\n        ```python\n        from fastcrud import JoinConfig\n\n        # Using same User/Tier/Department models/schemas as above.\n\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=ReadTierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=ReadDepartmentSchema,\n                    join_type=\"inner\",\n                ),\n            ],\n        )\n        ```\n\n        Using `alias` for joining the same model multiple times:\n        ```python\n        from fastcrud import aliased\n\n        owner_alias = aliased(ModelTest, name=\"owner\")\n        user_alias = aliased(ModelTest, name=\"user\")\n\n        result = await crud.get_joined(\n            db=session,\n            schema_to_select=BookingSchema,\n            joins_config=[\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.owner_id == owner_alias.id,\n                    join_prefix=\"owner_\",\n                    alias=owner_alias,\n                    schema_to_select=UserSchema,\n                ),\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.user_id == user_alias.id,\n                    join_prefix=\"user_\",\n                    alias=user_alias,\n                    schema_to_select=UserSchema,\n                ),\n            ],\n            id=1,\n        )\n        ```\n\n        Fetching a single project and its associated participants where a participant has a specific role:\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'role': 'Designer'},\n            ),\n        ]\n\n        project_crud = FastCRUD(Project)\n\n        project = await project_crud.get_joined(\n            db=session,\n            schema_to_select=ReadProjectSchema,\n            joins_config=joins_config,\n        )\n        ```\n\n        Example of using `joins_config` for multiple joins with nested joins enabled:\n\n        ```python\n        from fastcrud import JoinConfig\n\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=ReadTierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=ReadDepartmentSchema,\n                    join_type=\"inner\",\n                ),\n            ],\n            nest_joins=True,\n        )\n        # Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n        ```\n\n        Example using one-to-one relationship:\n\n        ```python\n        author_crud = FastCRUD(Author)\n        result = await author_crud.get_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Profile,\n            join_on=Author.profile_id == Profile.id,\n            join_schema_to_select=ReadProfileSchema,\n            nest_joins=True,\n            relationship_type='one-to-one', # note that this is the default behavior\n        )\n        # Expect 'result' to have 'profile' as a nested dictionary\n        ```\n\n        Example using one-to-many relationship:\n\n        ```python\n        result = await author_crud.get_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Article,\n            join_on=Author.id == Article.author_id,\n            join_schema_to_select=ReadArticleSchema,\n            nest_joins=True,\n            relationship_type='one-to-many',\n        )\n        # Expect 'result' to have 'posts' as a nested list of dictionaries\n        ```\n    \"\"\"\n    if joins_config and (\n        join_model or join_prefix or join_on or join_schema_to_select or alias\n    ):\n        raise ValueError(\n            \"Cannot use both single join parameters and joins_config simultaneously.\"\n        )\n    elif not joins_config and not join_model:\n        raise ValueError(\"You need one of join_model or joins_config.\")\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model,\n        schema=schema_to_select,\n    )\n    stmt: Select = select(*primary_select).select_from(self.model)\n\n    join_definitions = joins_config if joins_config else []\n    if join_model:\n        join_definitions.append(\n            JoinConfig(\n                model=join_model,\n                join_on=join_on,\n                join_prefix=join_prefix,\n                schema_to_select=join_schema_to_select,\n                join_type=join_type,\n                alias=alias,\n                filters=join_filters,\n                relationship_type=relationship_type,\n            )\n        )\n\n    stmt = self._prepare_and_apply_joins(\n        stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n    )\n    primary_filters = self._parse_filters(**kwargs)\n    if primary_filters:\n        stmt = stmt.filter(*primary_filters)\n\n    db_rows = await db.execute(stmt)\n    if any(join.relationship_type == \"one-to-many\" for join in join_definitions):\n        if nest_joins is False:  # pragma: no cover\n            raise ValueError(\n                \"Cannot use one-to-many relationship with nest_joins=False\"\n            )\n        results = db_rows.fetchall()\n        data_list = [dict(row._mapping) for row in results]\n    else:\n        result = db_rows.first()\n        if result is not None:\n            data_list = [dict(result._mapping)]\n        else:\n            data_list = []\n\n    if data_list:\n        if nest_joins:\n            nested_data: dict = {}\n            for data in data_list:\n                nested_data = _nest_join_data(\n                    data,\n                    join_definitions,\n                    nested_data=nested_data,\n                )\n            return nested_data\n        return data_list[0]\n\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi","title":"<code>get_multi(db, offset=0, limit=100, schema_to_select=None, sort_columns=None, sort_orders=None, return_as_model=False, return_total_count=True, **kwargs)</code>  <code>async</code>","text":"<p>Fetches multiple records based on filters, supporting sorting, pagination.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>offset</code> <code>int</code> <p>Starting index for records to fetch, useful for pagination.</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to fetch in one call. Use <code>None</code> for \"no limit\", fetching all matching rows. Note that in order to use <code>limit=None</code>, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>Column names to sort the results by.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>Corresponding sort orders (<code>\"asc\"</code>, <code>\"desc\"</code>) for each column in <code>sort_columns</code>.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, returns data as instances of the specified Pydantic model.</p> <code>False</code> <code>return_total_count</code> <code>bool</code> <p>If <code>True</code>, also returns the total count of rows with the selected filters. Useful for pagination.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for more detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <p>A dictionary containing the data list and optionally the total count:</p> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>With return_as_model=True: Dict with \"data\": List[SelectSchemaType]</li> </ul> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>With return_as_model=False: Dict with \"data\": List[Dict[str, Any]]</li> </ul> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>If return_total_count=True, includes \"total_count\": int</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>limit</code> or <code>offset</code> is negative, or if <code>schema_to_select</code> is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetch the first 10 users:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    0,\n    10,\n)\n</code></pre> <p>Fetch next 10 users with sorted by username:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    10,\n    10,\n    sort_columns='username',\n    sort_orders='desc',\n)\n</code></pre> <p>Fetch 10 users older than 30, sorted by age in descending order:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns='age',\n    sort_orders='desc',\n    age__gt=30,\n)\n</code></pre> <p>Fetch 10 users with a registration date before Jan 1, 2020: <pre><code>users = await user_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    registration_date__lt=datetime(2020, 1, 1),\n)\n</code></pre></p> <p>Fetch 10 users with a username other than <code>admin</code>, returning as model instances (ensure appropriate schema is passed):</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    username__ne='admin',\n)\n</code></pre> <p>Fetch users with filtering and multiple column sorting:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    0,\n    10,\n    sort_columns=['username', 'email'],\n    sort_orders=['asc', 'desc'],\n    is_active=True,\n)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi(\n    self,\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]:\n    \"\"\"\n    Fetches multiple records based on filters, supporting sorting, pagination.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        offset: Starting index for records to fetch, useful for pagination.\n        limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n        sort_columns: Column names to sort the results by.\n        sort_orders: Corresponding sort orders (`\"asc\"`, `\"desc\"`) for each column in `sort_columns`.\n        return_as_model: If `True`, returns data as instances of the specified Pydantic model.\n        return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n    Returns:\n        A dictionary containing the data list and optionally the total count:\n        - With return_as_model=True: Dict with \"data\": List[SelectSchemaType]\n        - With return_as_model=False: Dict with \"data\": List[Dict[str, Any]]\n        - If return_total_count=True, includes \"total_count\": int\n\n    Raises:\n        ValueError: If `limit` or `offset` is negative, or if `schema_to_select` is required but not provided or invalid.\n\n    Examples:\n        Fetch the first 10 users:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            0,\n            10,\n        )\n        ```\n\n        Fetch next 10 users with sorted by username:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            10,\n            10,\n            sort_columns='username',\n            sort_orders='desc',\n        )\n        ```\n\n        Fetch 10 users older than 30, sorted by age in descending order:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            sort_columns='age',\n            sort_orders='desc',\n            age__gt=30,\n        )\n        ```\n\n        Fetch 10 users with a registration date before Jan 1, 2020:\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            registration_date__lt=datetime(2020, 1, 1),\n        )\n        ```\n\n        Fetch 10 users with a username other than `admin`, returning as model instances (ensure appropriate schema is passed):\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            schema_to_select=ReadUserSchema,\n            return_as_model=True,\n            username__ne='admin',\n        )\n        ```\n\n        Fetch users with filtering and multiple column sorting:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            0,\n            10,\n            sort_columns=['username', 'email'],\n            sort_orders=['asc', 'desc'],\n            is_active=True,\n        )\n        ```\n    \"\"\"\n    if (limit is not None and limit &lt; 0) or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    stmt = await self.select(\n        schema_to_select=schema_to_select,\n        sort_columns=sort_columns,\n        sort_orders=sort_orders,\n        **kwargs,\n    )\n\n    if offset:\n        stmt = stmt.offset(offset)\n    if limit is not None:\n        stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    response: dict[str, Any] = {\"data\": data}\n\n    if return_total_count:\n        total_count = await self.count(db=db, **kwargs)\n        response[\"total_count\"] = total_count\n\n    if return_as_model:\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        try:\n            model_data = [schema_to_select(**row) for row in data]\n            response[\"data\"] = model_data\n        except ValidationError as e:\n            raise ValueError(\n                f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n            )\n\n    return response\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor","title":"<code>get_multi_by_cursor(db, cursor=None, limit=100, schema_to_select=None, sort_column='id', sort_order='asc', **kwargs)</code>  <code>async</code>","text":"<p>Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>cursor</code> <code>Any</code> <p>The cursor value to start fetching records from. Defaults to <code>None</code>.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of rows to fetch.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns.</p> <code>None</code> <code>sort_column</code> <code>str</code> <p>Column name to use for sorting and cursor pagination.</p> <code>'id'</code> <code>sort_order</code> <code>str</code> <p>Sorting direction, either <code>\"asc\"</code> or <code>\"desc\"</code>.</p> <code>'asc'</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under <code>\"data\"</code> key and the next cursor value under <code>\"next_cursor\"</code>.</p> <p>Examples:</p> <p>Fetch the first set of records (e.g., the first page in an infinite scrolling scenario):</p> <pre><code>first_page = await user_crud.get_multi_by_cursor(\n    db,\n    limit=10,\n    sort_column='registration_date',\n)\n\n# Fetch the next set of records using the cursor from the first page\nsecond_page = await user_crud.get_multi_by_cursor(\n    db,\n    cursor=next_cursor,\n    limit=10,\n    sort_column='registration_date',\n    sort_order='desc',\n)\n</code></pre> <p>Fetch records with age greater than 30 using cursor-based pagination:</p> <pre><code>first_page = await user_crud.get_multi_by_cursor(\n    db,\n    limit=10,\n    sort_column='age',\n    sort_order='asc',\n)\n</code></pre> <p>Fetch records excluding a specific username using cursor-based pagination:</p> <pre><code>    db,\n    limit=10,\n    sort_column='username',\n    sort_order='asc',\n    username__ne='admin',\n)\n</code></pre> Note <p>This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features. Make sure the column used for cursor pagination is indexed for performance.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_by_cursor(\n    self,\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The SQLAlchemy async session.\n        cursor: The cursor value to start fetching records from. Defaults to `None`.\n        limit: Maximum number of rows to fetch.\n        schema_to_select: Pydantic schema for selecting specific columns.\n        sort_column: Column name to use for sorting and cursor pagination.\n        sort_order: Sorting direction, either `\"asc\"` or `\"desc\"`.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n    Returns:\n        A dictionary containing the fetched rows under `\"data\"` key and the next cursor value under `\"next_cursor\"`.\n\n    Examples:\n        Fetch the first set of records (e.g., the first page in an infinite scrolling scenario):\n\n        ```python\n        first_page = await user_crud.get_multi_by_cursor(\n            db,\n            limit=10,\n            sort_column='registration_date',\n        )\n\n        # Fetch the next set of records using the cursor from the first page\n        second_page = await user_crud.get_multi_by_cursor(\n            db,\n            cursor=next_cursor,\n            limit=10,\n            sort_column='registration_date',\n            sort_order='desc',\n        )\n        ```\n\n        Fetch records with age greater than 30 using cursor-based pagination:\n\n        ```python\n        first_page = await user_crud.get_multi_by_cursor(\n            db,\n            limit=10,\n            sort_column='age',\n            sort_order='asc',\n        )\n        ```\n\n        Fetch records excluding a specific username using cursor-based pagination:\n\n        ```python\n            db,\n            limit=10,\n            sort_column='username',\n            sort_order='asc',\n            username__ne='admin',\n        )\n        ```\n\n    Note:\n        This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n        Make sure the column used for cursor pagination is indexed for performance.\n    \"\"\"\n    if limit == 0:\n        return {\"data\": [], \"next_cursor\": None}\n\n    stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n    if cursor:\n        if sort_order == \"asc\":\n            stmt = stmt.filter(getattr(self.model, sort_column) &gt; cursor)\n        else:\n            stmt = stmt.filter(getattr(self.model, sort_column) &lt; cursor)\n\n    stmt = stmt.order_by(\n        asc(getattr(self.model, sort_column))\n        if sort_order == \"asc\"\n        else desc(getattr(self.model, sort_column))\n    )\n    stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    next_cursor = None\n    if len(data) == limit:\n        if sort_order == \"asc\":\n            next_cursor = data[-1][sort_column]\n        else:\n            data[0][sort_column]\n\n    return {\"data\": data, \"next_cursor\": next_cursor}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_joined","title":"<code>get_multi_joined(db, schema_to_select=None, join_model=None, join_on=None, join_prefix=None, join_schema_to_select=None, join_type='left', alias=None, join_filters=None, nest_joins=False, offset=0, limit=100, sort_columns=None, sort_orders=None, return_as_model=False, joins_config=None, return_total_count=True, relationship_type=None, **kwargs)</code>  <code>async</code>","text":"<p>Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_model</code> <code>Optional[type[ModelType]]</code> <p>The model to join with.</p> <code>None</code> <code>join_on</code> <code>Optional[Any]</code> <p>SQLAlchemy Join object for specifying the <code>ON</code> clause of the join. If <code>None</code>, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If <code>None</code>, no prefix is added.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be <code>\"left\"</code> for a left outer join or <code>\"inner\"</code> for an inner join.</p> <code>'left'</code> <code>alias</code> <code>Optional[AliasedClass[Any]]</code> <p>An instance of <code>AliasedClass</code> for the join model, useful for self-joins or multiple joins on the same model. Result of <code>aliased(join_model)</code>.</p> <code>None</code> <code>join_filters</code> <code>Optional[dict]</code> <p>Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.</p> <code>None</code> <code>nest_joins</code> <code>bool</code> <p>If <code>True</code>, nested data structures will be returned where joined model data are nested under the <code>join_prefix</code> as a dictionary.</p> <code>False</code> <code>offset</code> <code>int</code> <p>The offset (number of records to skip) for pagination.</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to fetch in one call. Use <code>None</code> for \"no limit\", fetching all matching rows. Note that in order to use <code>limit=None</code>, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.</p> <code>100</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or a list of column names on which to apply sorting.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order (<code>\"asc\"</code> or <code>\"desc\"</code>) or a list of sort orders corresponding to the columns in <code>sort_columns</code>. If not provided, defaults to <code>\"asc\"</code> for each column.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>List of <code>JoinConfig</code> instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.</p> <code>None</code> <code>return_total_count</code> <code>bool</code> <p>If <code>True</code>, also returns the total count of rows with the selected filters. Useful for pagination.</p> <code>True</code> <code>relationship_type</code> <code>Optional[str]</code> <p>Specifies the relationship type, such as <code>\"one-to-one\"</code> or <code>\"one-to-many\"</code>. Used to determine how to nest the joined data. If <code>None</code>, uses <code>\"one-to-one\"</code>.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary query, including advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under <code>\"data\"</code> key and total count under <code>\"total_count\"</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either <code>limit</code> or <code>offset</code> are negative, or if <code>schema_to_select</code> is required but not provided or invalid.         Also if both <code>joins_config</code> and any of the single join parameters are provided or none of <code>joins_config</code> and <code>join_model</code> is provided.</p> <p>Examples:</p> <p>Fetching multiple <code>User</code> records joined with <code>Tier</code> records, using left join, returning raw data:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    offset=0,\n    limit=10,\n)\n</code></pre> <p>Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    sort_columns='username',\n    sort_orders='asc',\n    age__gt=30,\n)\n</code></pre> <p>Fetch users joined with their tiers, excluding users with <code>admin</code> username, returning as model instances:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    return_as_model=True,\n    username__ne='admin',\n)\n</code></pre> <p>Fetching and sorting by username in descending order, returning as Pydantic model:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    offset=0,\n    limit=10,\n    sort_columns=['username'],\n    sort_orders=['desc'],\n    return_as_model=True,\n)\n</code></pre> <p>Fetching with complex conditions and custom join, returning as Pydantic model:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    offset=0,\n    limit=10,\n    return_as_model=True,\n    is_active=True,\n)\n</code></pre> <p>Example using <code>joins_config</code> for multiple joins:</p> <pre><code>from fastcrud import JoinConfig\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=ReadTierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=ReadDepartmentSchema,\n            join_type=\"inner\",\n        ),\n    ],\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc',\n)\n</code></pre> <p>Example using <code>alias</code> for multiple joins, with pagination, sorting, and model conversion: <pre><code>from fastcrud import JoinConfig, FastCRUD, aliased\n\n# Aliasing for self-joins or multiple joins on the same table\nowner_alias = aliased(ModelTest, name=\"owner\")\nuser_alias = aliased(ModelTest, name=\"user\")\n\n# Initialize your FastCRUD instance for BookingModel\ncrud = FastCRUD(BookingModel)\n\nresult = await crud.get_multi_joined(\n    db=session,\n    schema_to_select=BookingSchema,  # Primary model schema\n    joins_config=[\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.owner_id == owner_alias.id,\n            join_prefix=\"owner_\",\n            schema_to_select=UserSchema,  # Schema for the joined model\n            alias=owner_alias,\n        ),\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.user_id == user_alias.id,\n            join_prefix=\"user_\",\n            schema_to_select=UserSchema,\n            alias=user_alias,\n        )\n    ],\n    offset=10,  # Skip the first 10 records\n    limit=5,  # Fetch up to 5 records\n    sort_columns=['booking_date'],  # Sort by booking_date\n    sort_orders=['desc'],  # In descending order\n)\n</code></pre></p> <p>Fetching multiple project records and their associated participants where participants have a specific role:</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'role': 'Developer'},\n    ),\n]\n\nproject_crud = FastCRUD(Project)\n\nprojects = await project_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadProjectSchema,\n    limit=10,\n    joins_config=joins_config,\n)\n</code></pre> <p>Fetching a list of stories, each with nested details of associated tasks and task creators, using nested joins:</p> <pre><code>story_crud = FastCRUD(Story)\nstories = await story_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadStorySchema,\n    joins_config=[\n        JoinConfig(\n            model=Task,\n            join_on=Story.id == Task.story_id,\n            join_prefix=\"task_\",\n            schema_to_select=ReadTaskSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=User,\n            join_on=Task.creator_id == User.id,\n            join_prefix=\"creator_\",\n            schema_to_select=ReadUserSchema,\n            join_type=\"left\",\n            alias=aliased(User, name=\"task_creator\"),\n        ),\n    ],\n    nest_joins=True,\n    offset=0,\n    limit=5,\n    sort_columns='name',\n    sort_orders='asc',\n)\n</code></pre> <p>Example using one-to-one relationship:</p> <pre><code>author_crud = FastCRUD(Author)\nresults = await author_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Profile,\n    join_on=Author.profile_id == Profile.id,\n    join_schema_to_select=ReadProfileSchema,\n    nest_joins=True,\n    offset=0,\n    limit=10,\n    relationship_type='one-to-one', # note that this is the default behavior\n)\n# Expect 'profile' to be nested as a dictionary under each user\n</code></pre> <p>Example using one-to-many relationship:</p> <pre><code>results = await author_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Article,\n    join_on=Author.id == Article.author_id,\n    join_schema_to_select=ReadArticleSchema,\n    nest_joins=True,\n    offset=0,\n    limit=10,\n    relationship_type='one-to-many',\n)\n# Expect 'posts' to be nested as a list of dictionaries under each user\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_joined(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    joins_config: Optional[list[JoinConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_model: The model to join with.\n        join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n        alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n        join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n        nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n        offset: The offset (number of records to skip) for pagination.\n        limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n        sort_columns: A single column name or a list of column names on which to apply sorting.\n        sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders corresponding to the columns in `sort_columns`. If not provided, defaults to `\"asc\"` for each column.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n        joins_config: List of `JoinConfig` instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.\n        return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n        relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n        **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary containing the fetched rows under `\"data\"` key and total count under `\"total_count\"`.\n\n    Raises:\n        ValueError: If either `limit` or `offset` are negative, or if `schema_to_select` is required but not provided or invalid.\n                    Also if both `joins_config` and any of the single join parameters are provided or none of `joins_config` and `join_model` is provided.\n\n    Examples:\n        Fetching multiple `User` records joined with `Tier` records, using left join, returning raw data:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            offset=0,\n            limit=10,\n        )\n        ```\n\n        Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            sort_columns='username',\n            sort_orders='asc',\n            age__gt=30,\n        )\n        ```\n\n        Fetch users joined with their tiers, excluding users with `admin` username, returning as model instances:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            return_as_model=True,\n            username__ne='admin',\n        )\n        ```\n\n        Fetching and sorting by username in descending order, returning as Pydantic model:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            offset=0,\n            limit=10,\n            sort_columns=['username'],\n            sort_orders=['desc'],\n            return_as_model=True,\n        )\n        ```\n\n        Fetching with complex conditions and custom join, returning as Pydantic model:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            offset=0,\n            limit=10,\n            return_as_model=True,\n            is_active=True,\n        )\n        ```\n\n        Example using `joins_config` for multiple joins:\n\n        ```python\n        from fastcrud import JoinConfig\n\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=ReadTierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=ReadDepartmentSchema,\n                    join_type=\"inner\",\n                ),\n            ],\n            offset=0,\n            limit=10,\n            sort_columns='username',\n            sort_orders='asc',\n        )\n        ```\n\n        Example using `alias` for multiple joins, with pagination, sorting, and model conversion:\n        ```python\n        from fastcrud import JoinConfig, FastCRUD, aliased\n\n        # Aliasing for self-joins or multiple joins on the same table\n        owner_alias = aliased(ModelTest, name=\"owner\")\n        user_alias = aliased(ModelTest, name=\"user\")\n\n        # Initialize your FastCRUD instance for BookingModel\n        crud = FastCRUD(BookingModel)\n\n        result = await crud.get_multi_joined(\n            db=session,\n            schema_to_select=BookingSchema,  # Primary model schema\n            joins_config=[\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.owner_id == owner_alias.id,\n                    join_prefix=\"owner_\",\n                    schema_to_select=UserSchema,  # Schema for the joined model\n                    alias=owner_alias,\n                ),\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.user_id == user_alias.id,\n                    join_prefix=\"user_\",\n                    schema_to_select=UserSchema,\n                    alias=user_alias,\n                )\n            ],\n            offset=10,  # Skip the first 10 records\n            limit=5,  # Fetch up to 5 records\n            sort_columns=['booking_date'],  # Sort by booking_date\n            sort_orders=['desc'],  # In descending order\n        )\n        ```\n\n        Fetching multiple project records and their associated participants where participants have a specific role:\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'role': 'Developer'},\n            ),\n        ]\n\n        project_crud = FastCRUD(Project)\n\n        projects = await project_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadProjectSchema,\n            limit=10,\n            joins_config=joins_config,\n        )\n        ```\n\n        Fetching a list of stories, each with nested details of associated tasks and task creators, using nested joins:\n\n        ```python\n        story_crud = FastCRUD(Story)\n        stories = await story_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadStorySchema,\n            joins_config=[\n                JoinConfig(\n                    model=Task,\n                    join_on=Story.id == Task.story_id,\n                    join_prefix=\"task_\",\n                    schema_to_select=ReadTaskSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=User,\n                    join_on=Task.creator_id == User.id,\n                    join_prefix=\"creator_\",\n                    schema_to_select=ReadUserSchema,\n                    join_type=\"left\",\n                    alias=aliased(User, name=\"task_creator\"),\n                ),\n            ],\n            nest_joins=True,\n            offset=0,\n            limit=5,\n            sort_columns='name',\n            sort_orders='asc',\n        )\n        ```\n\n        Example using one-to-one relationship:\n\n        ```python\n        author_crud = FastCRUD(Author)\n        results = await author_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Profile,\n            join_on=Author.profile_id == Profile.id,\n            join_schema_to_select=ReadProfileSchema,\n            nest_joins=True,\n            offset=0,\n            limit=10,\n            relationship_type='one-to-one', # note that this is the default behavior\n        )\n        # Expect 'profile' to be nested as a dictionary under each user\n        ```\n\n        Example using one-to-many relationship:\n\n        ```python\n        results = await author_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Article,\n            join_on=Author.id == Article.author_id,\n            join_schema_to_select=ReadArticleSchema,\n            nest_joins=True,\n            offset=0,\n            limit=10,\n            relationship_type='one-to-many',\n        )\n        # Expect 'posts' to be nested as a list of dictionaries under each user\n        ```\n    \"\"\"\n    if joins_config and (\n        join_model\n        or join_prefix\n        or join_on\n        or join_schema_to_select\n        or alias\n        or relationship_type\n    ):\n        raise ValueError(\n            \"Cannot use both single join parameters and joins_config simultaneously.\"\n        )\n    elif not joins_config and not join_model:\n        raise ValueError(\"You need one of join_model or joins_config.\")\n\n    if (limit is not None and limit &lt; 0) or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    if relationship_type is None:\n        relationship_type = \"one-to-one\"\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    stmt: Select = select(*primary_select)\n\n    join_definitions = joins_config if joins_config else []\n    if join_model:\n        try:\n            join_definitions.append(\n                JoinConfig(\n                    model=join_model,\n                    join_on=join_on\n                    if join_on is not None\n                    else _auto_detect_join_condition(self.model, join_model),\n                    join_prefix=join_prefix,\n                    schema_to_select=join_schema_to_select,\n                    join_type=join_type,\n                    alias=alias,\n                    filters=join_filters,\n                    relationship_type=relationship_type,\n                )\n            )\n        except ValueError as e:  # pragma: no cover\n            raise ValueError(f\"Could not configure join: {str(e)}\")\n\n    stmt = self._prepare_and_apply_joins(\n        stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n    )\n\n    primary_filters = self._parse_filters(**kwargs)\n    if primary_filters:\n        stmt = stmt.filter(*primary_filters)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n    if offset:\n        stmt = stmt.offset(offset)\n    if limit is not None:\n        stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data: list[Union[dict, SelectSchemaType]] = []\n\n    for row in result.mappings().all():\n        row_dict = dict(row)\n\n        if nest_joins:\n            row_dict = _nest_join_data(\n                data=row_dict,\n                join_definitions=join_definitions,\n            )\n\n        if return_as_model:\n            if schema_to_select is None:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                model_instance = schema_to_select(**row_dict)\n                data.append(model_instance)\n            except ValidationError as e:\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n        else:\n            data.append(row_dict)\n\n    if nest_joins and any(\n        join.relationship_type == \"one-to-many\" for join in join_definitions\n    ):\n        nested_data = _nest_multi_join_data(\n            base_primary_key=self._primary_keys[0].name,  # type: ignore[misc]\n            data=data,\n            joins_config=join_definitions,\n            return_as_model=return_as_model,\n            schema_to_select=schema_to_select if return_as_model else None,\n            nested_schema_to_select={\n                (\n                    join.join_prefix.rstrip(\"_\")\n                    if join.join_prefix\n                    else join.model.__tablename__\n                ): join.schema_to_select\n                for join in join_definitions\n                if join.schema_to_select\n            },\n        )\n    else:\n        nested_data = _handle_null_primary_key_multi_join(data, join_definitions)\n\n    response: dict[str, Any] = {\"data\": nested_data}\n\n    if return_total_count:\n        total_count: int = await self.count(\n            db=db, joins_config=joins_config, **kwargs\n        )\n        response[\"total_count\"] = total_count\n\n    return response\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.select","title":"<code>select(schema_to_select=None, sort_columns=None, sort_orders=None, **kwargs)</code>  <code>async</code>","text":"<p>Constructs a SQL Alchemy <code>Select</code> statement with optional column selection, filtering, and sorting.</p> <p>This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or list of column names to sort the query results by. Must be used in conjunction with <code>sort_orders</code>.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order (<code>\"asc\"</code> or <code>\"desc\"</code>) or a list of sort orders, corresponding to each column in <code>sort_columns</code>. If not specified, defaults to ascending order for all <code>sort_columns</code>.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for more detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Select</code> <p>An SQL Alchemy <code>Select</code> statement object that can be executed or further modified.</p> <p>Examples:</p> <p>Selecting specific columns with filtering and sorting:</p> <pre><code>stmt = await user_crud.select(\n    schema_to_select=ReadUserSchema,\n    sort_columns=['age', 'name'],\n    sort_orders=['asc', 'desc'],\n    age__gt=18,\n)\n</code></pre> <p>Creating a statement to select all users without any filters:</p> <pre><code>stmt = await user_crud.select()\n</code></pre> <p>Selecting users with a specific <code>role</code>, ordered by <code>name</code>:</p> <pre><code>stmt = await user_crud.select(\n    schema_to_select=UserReadSchema,\n    sort_columns='name',\n    role='admin',\n)\n</code></pre> Note <p>This method does not execute the generated SQL statement. Use <code>db.execute(stmt)</code> to run the query and fetch results.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def select(\n    self,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any,\n) -&gt; Select:\n    \"\"\"\n    Constructs a SQL Alchemy `Select` statement with optional column selection, filtering, and sorting.\n\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        schema_to_select: Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.\n        sort_columns: A single column name or list of column names to sort the query results by. Must be used in conjunction with `sort_orders`.\n        sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders, corresponding to each column in `sort_columns`. If not specified, defaults to ascending order for all `sort_columns`.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n    Returns:\n        An SQL Alchemy `Select` statement object that can be executed or further modified.\n\n    Examples:\n        Selecting specific columns with filtering and sorting:\n\n        ```python\n        stmt = await user_crud.select(\n            schema_to_select=ReadUserSchema,\n            sort_columns=['age', 'name'],\n            sort_orders=['asc', 'desc'],\n            age__gt=18,\n        )\n        ```\n\n        Creating a statement to select all users without any filters:\n\n        ```python\n        stmt = await user_crud.select()\n        ```\n\n        Selecting users with a specific `role`, ordered by `name`:\n\n        ```python\n        stmt = await user_crud.select(\n            schema_to_select=UserReadSchema,\n            sort_columns='name',\n            role='admin',\n        )\n        ```\n\n    Note:\n        This method does not execute the generated SQL statement.\n        Use `db.execute(stmt)` to run the query and fetch results.\n    \"\"\"\n    to_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    filters = self._parse_filters(**kwargs)\n    stmt = select(*to_select).filter(*filters)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n    return stmt\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.update","title":"<code>update(db, object, allow_multiple=False, commit=True, return_columns=None, schema_to_select=None, return_as_model=False, one_or_none=False, **kwargs)</code>  <code>async</code>","text":"<p>Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>object</code> <code>Union[UpdateSchemaType, dict[str, Any]]</code> <p>A Pydantic schema or dictionary containing the update data.</p> required <code>allow_multiple</code> <code>bool</code> <p>If <code>True</code>, allows updating multiple records that match the filters. If <code>False</code>, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>return_columns</code> <code>Optional[list[str]]</code> <p>A list of column names to return after the update. If <code>return_as_model</code> is True, all columns are returned.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the updated record(s). Required if <code>return_as_model</code> is <code>True</code>.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, returns the updated record(s) as Pydantic model instances based on <code>schema_to_select</code>. Default is False.</p> <code>False</code> <code>one_or_none</code> <code>bool</code> <p>If <code>True</code>, returns a single record if only one record matches the filters. Default is <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Union[dict, SelectSchemaType]]</code> <p>The updated record(s) as a dictionary or Pydantic model instance or <code>None</code>, depending on the value of <code>return_as_model</code> and <code>return_columns</code>.</p> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is <code>False</code> and more than one record matches the filters.</p> <code>NoResultFound</code> <p>If no record matches the filters. (on version 0.15.3)</p> <code>ValueError</code> <p>If extra fields not present in the model are provided in the update data.</p> <code>ValueError</code> <p>If <code>return_as_model</code> is <code>True</code> but <code>schema_to_select</code> is not provided.</p> <p>Examples:</p> <p>Update a user's email based on their ID:</p> <pre><code>await user_crud.update(db, {'email': 'new_email@example.com'}, id=1)\n</code></pre> <p>Update users to be inactive where age is greater than 30 and allow updates to multiple records:</p> <pre><code>await user_crud.update(\n    db,\n    {'is_active': False},\n    allow_multiple=True,\n    age__gt=30,\n)\n</code></pre> <p>Update a user's username excluding specific user ID and prevent multiple updates:</p> <pre><code>await user_crud.update(\n    db,\n    {'username': 'new_username'},\n    allow_multiple=False,\n    id__ne=1,\n)\n</code></pre> <p>Update a user's email and return the updated record as a Pydantic model instance:</p> <pre><code>user = await user_crud.update(\n    db,\n    {'email': 'new_email@example.com'},\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    id=1,\n)\n</code></pre> <p>Update a user's email and return the updated record as a dictionary: <pre><code>user = await user_crud.update(\n    db,\n    {'email': 'new_email@example.com'},\n    return_columns=['id', 'email'],\n    id=1,\n)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def update(\n    self,\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, SelectSchemaType]]:\n    \"\"\"\n    Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        object: A Pydantic schema or dictionary containing the update data.\n        allow_multiple: If `True`, allows updating multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        return_columns: A list of column names to return after the update. If `return_as_model` is True, all columns are returned.\n        schema_to_select: Pydantic schema for selecting specific columns from the updated record(s). Required if `return_as_model` is `True`.\n        return_as_model: If `True`, returns the updated record(s) as Pydantic model instances based on `schema_to_select`. Default is False.\n        one_or_none: If `True`, returns a single record if only one record matches the filters. Default is `False`.\n        **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n    Returns:\n        The updated record(s) as a dictionary or Pydantic model instance or `None`, depending on the value of `return_as_model` and `return_columns`.\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n        NoResultFound: If no record matches the filters. (on version 0.15.3)\n        ValueError: If extra fields not present in the model are provided in the update data.\n        ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n    Examples:\n        Update a user's email based on their ID:\n\n        ```python\n        await user_crud.update(db, {'email': 'new_email@example.com'}, id=1)\n        ```\n\n        Update users to be inactive where age is greater than 30 and allow updates to multiple records:\n\n        ```python\n        await user_crud.update(\n            db,\n            {'is_active': False},\n            allow_multiple=True,\n            age__gt=30,\n        )\n        ```\n\n        Update a user's username excluding specific user ID and prevent multiple updates:\n\n        ```python\n        await user_crud.update(\n            db,\n            {'username': 'new_username'},\n            allow_multiple=False,\n            id__ne=1,\n        )\n        ```\n\n        Update a user's email and return the updated record as a Pydantic model instance:\n\n        ```python\n        user = await user_crud.update(\n            db,\n            {'email': 'new_email@example.com'},\n            schema_to_select=ReadUserSchema,\n            return_as_model=True,\n            id=1,\n        )\n        ```\n\n        Update a user's email and return the updated record as a dictionary:\n        ```python\n        user = await user_crud.update(\n            db,\n            {'email': 'new_email@example.com'},\n            return_columns=['id', 'email'],\n            id=1,\n        )\n        ```\n    \"\"\"\n    total_count = await self.count(db, **kwargs)\n    if total_count == 0:\n        raise NoResultFound(\"No record found to update.\")\n    if not allow_multiple and total_count &gt; 1:\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to update, found {total_count}.\"\n        )\n\n    if isinstance(object, dict):\n        update_data = object\n    else:\n        update_data = object.model_dump(exclude_unset=True)\n\n    updated_at_col = getattr(self.model, self.updated_at_column, None)\n    if updated_at_col:\n        update_data[self.updated_at_column] = datetime.now(timezone.utc)\n\n    update_data_keys = set(update_data.keys())\n    model_columns = {_column.name for _column in inspect(self.model).c}\n    extra_fields = update_data_keys - model_columns\n    if extra_fields:\n        raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n    filters = self._parse_filters(**kwargs)\n    stmt = update(self.model).filter(*filters).values(update_data)\n\n    if return_as_model:\n        return_columns = self.model_col_names\n\n    if return_columns:\n        stmt = stmt.returning(*[column(name) for name in return_columns])\n        db_row = await db.execute(stmt)\n        if commit:\n            await db.commit()\n        if allow_multiple:\n            return self._as_multi_response(\n                db_row,\n                schema_to_select=schema_to_select,\n                return_as_model=return_as_model,\n            )\n        return self._as_single_response(\n            db_row,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n            one_or_none=one_or_none,\n        )\n\n    await db.execute(stmt)\n    if commit:\n        await db.commit()\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.upsert","title":"<code>upsert(db, instance, schema_to_select=None, return_as_model=False)</code>  <code>async</code>","text":"<p>Update the instance or create it if it doesn't exists.</p> <p>Note: This method will perform two transactions to the database (get and create or update).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>instance</code> <code>Union[UpdateSchemaType, CreateSchemaType]</code> <p>A Pydantic schema representing the instance.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SelectSchemaType, dict[str, Any], None]</code> <p>The created or updated instance</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def upsert(\n    self,\n    db: AsyncSession,\n    instance: Union[UpdateSchemaType, CreateSchemaType],\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n) -&gt; Union[SelectSchemaType, dict[str, Any], None]:\n    \"\"\"Update the instance or create it if it doesn't exists.\n\n    Note: This method will perform two transactions to the database (get and create or update).\n\n    Args:\n        db: The database session to use for the operation.\n        instance: A Pydantic schema representing the instance.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Defaults to `None`.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n\n    Returns:\n        The created or updated instance\n    \"\"\"\n    _pks = self._get_pk_dict(instance)\n    schema_to_select = schema_to_select or type(instance)  # type: ignore\n    db_instance = await self.get(\n        db,\n        schema_to_select=schema_to_select,  # type: ignore\n        return_as_model=return_as_model,\n        **_pks,\n    )\n    if db_instance is None:\n        db_instance = await self.create(db, instance)  # type: ignore\n        db_instance = schema_to_select.model_validate(  # type: ignore\n            db_instance, from_attributes=True\n        )\n    else:\n        await self.update(db, instance)  # type: ignore\n        db_instance = await self.get(\n            db,\n            schema_to_select=schema_to_select,  # type: ignore\n            return_as_model=return_as_model,\n            **_pks,\n        )\n\n    return db_instance\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.upsert_multi","title":"<code>upsert_multi(db, instances, commit=False, return_columns=None, schema_to_select=None, return_as_model=False, update_override=None, **kwargs)</code>  <code>async</code>","text":"<p>Upsert multiple records in the database. The underlying implementation varies based on the database dialect.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>instances</code> <code>list[Union[UpdateSchemaType, CreateSchemaType]]</code> <p>A list of Pydantic schemas representing the instances to upsert.</p> required <code>commit</code> <code>bool</code> <p>If True, commits the transaction immediately. Default is False.</p> <code>False</code> <code>return_columns</code> <code>Optional[list[str]]</code> <p>Optional list of column names to return after the upsert operation.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns. Required if return_as_model is True.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, returns data as instances of the specified Pydantic model.</p> <code>False</code> <code>update_override</code> <code>Optional[dict[str, Any]]</code> <p>Optional dictionary to override the update values for the upsert operation.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to update on conflict, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>The updated record(s) as a dictionary or Pydantic model instance or None, depending on the value of <code>return_as_model</code> and <code>return_columns</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the MySQL dialect is used with filters, return_columns, schema_to_select, or return_as_model.</p> <code>NotImplementedError</code> <p>If the database dialect is not supported for upsert multi.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def upsert_multi(\n    self,\n    db: AsyncSession,\n    instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n    commit: bool = False,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    update_override: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"\n    Upsert multiple records in the database. The underlying implementation varies based on the database dialect.\n\n    Args:\n        db: The database session to use for the operation.\n        instances: A list of Pydantic schemas representing the instances to upsert.\n        commit: If True, commits the transaction immediately. Default is False.\n        return_columns: Optional list of column names to return after the upsert operation.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Required if return_as_model is True.\n        return_as_model: If True, returns data as instances of the specified Pydantic model.\n        update_override: Optional dictionary to override the update values for the upsert operation.\n        **kwargs: Filters to identify the record(s) to update on conflict, supporting advanced comparison operators for refined querying.\n\n    Returns:\n        The updated record(s) as a dictionary or Pydantic model instance or None, depending on the value of `return_as_model` and `return_columns`.\n\n    Raises:\n        ValueError: If the MySQL dialect is used with filters, return_columns, schema_to_select, or return_as_model.\n        NotImplementedError: If the database dialect is not supported for upsert multi.\n    \"\"\"\n    if update_override is None:\n        update_override = {}\n    filters = self._parse_filters(**kwargs)\n\n    if db.bind.dialect.name == \"postgresql\":\n        statement, params = await self._upsert_multi_postgresql(\n            instances, filters, update_override\n        )\n    elif db.bind.dialect.name == \"sqlite\":\n        statement, params = await self._upsert_multi_sqlite(\n            instances, filters, update_override\n        )\n    elif db.bind.dialect.name in [\"mysql\", \"mariadb\"]:\n        if filters:\n            raise ValueError(\n                \"MySQL does not support filtering on insert operations.\"\n            )\n        if return_columns or schema_to_select or return_as_model:\n            raise ValueError(\n                \"MySQL does not support the returning clause for insert operations.\"\n            )\n        statement, params = await self._upsert_multi_mysql(\n            instances, update_override\n        )\n    else:  # pragma: no cover\n        raise NotImplementedError(\n            f\"Upsert multi is not implemented for {db.bind.dialect.name}\"\n        )\n\n    if return_as_model:\n        return_columns = self.model_col_names\n\n    if return_columns:\n        statement = statement.returning(*[column(name) for name in return_columns])\n        db_row = await db.execute(statement, params)\n        if commit:\n            await db.commit()\n        return self._as_multi_response(\n            db_row,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n        )\n\n    await db.execute(statement, params)\n    if commit:\n        await db.commit()\n    return None\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API Reference section of our documentation. This section provides detailed information about the various classes, functions, and modules that make up our application. Whether you are looking to extend the application, integrate with it, or simply explore its capabilities, this section will guide you through the intricacies of our codebase.</p>"},{"location":"api/overview/#key-components","title":"Key Components","text":"<p>Our application's API is comprised of several key components, each serving a specific purpose:</p> <ol> <li> <p>FastCRUD Class: This class is at the heart of our CRUD (Create, Read, Update, Delete) operations. It provides a convenient and efficient way to interact with our database models.</p> <ul> <li>FastCRUD Class Reference</li> </ul> </li> <li> <p>EndpointCreator Class: A utility class for creating and registering CRUD endpoints in a FastAPI application. It simplifies the addition of standard CRUD endpoints to your FastAPI router.</p> <ul> <li>EndpointCreator Class Reference</li> </ul> </li> <li> <p>crud_router Function: A function that creates and configures a FastAPI router with CRUD endpoints for a specific model. It's a quick way to add standard CRUD operations to your models.</p> <ul> <li>CRUD Router Function Reference</li> </ul> </li> <li> <p>paginated Module: A a utility module for offset pagination related functions.</p> <ul> <li>Pagination Module Reference</li> </ul> </li> </ol>"},{"location":"api/overview/#usage","title":"Usage","text":"<p>Each component is documented with its own dedicated page, where you can find detailed information about its methods, parameters, return types, and usage examples. These pages are designed to provide you with all the information you need to understand and work with our API effectively.</p>"},{"location":"api/overview/#contribution","title":"Contribution","text":"<p>If you wish to contribute to the development of our API, please refer to our Contributing Guidelines. We welcome contributions of all forms, from bug fixes to feature development.</p>"},{"location":"api/overview/#feedback","title":"Feedback","text":"<p>Your feedback is crucial in helping us improve this documentation. If you have any suggestions, corrections, or queries, please reach out to us.</p> <p>Navigate through each section for detailed documentation of our API components.</p>"},{"location":"api/paginated/","title":"Paginated Module Reference","text":"<p><code>paginated</code> is a utility module for offset pagination related functions.</p>"},{"location":"api/paginated/#function-definition","title":"Function Definition","text":""},{"location":"api/paginated/#fastcrud.paginated.compute_offset","title":"<code>compute_offset(page, items_per_page)</code>","text":"<p>Calculate the offset for pagination based on the given page number and items per page.</p> <p>The offset represents the starting point in a dataset for the items on a given page. For example, if each page displays 10 items and you want to display page 3, the offset will be 20, meaning the display should start with the 21st item.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The current page number. Page numbers should start from 1.</p> required <code>items_per_page</code> <code>int</code> <p>The number of items to be displayed on each page.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The calculated offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; offset(1, 10)\n0\n&gt;&gt;&gt; offset(3, 10)\n20\n</code></pre> Source code in <code>fastcrud/paginated/helper.py</code> <pre><code>def compute_offset(page: int, items_per_page: int) -&gt; int:\n    \"\"\"Calculate the offset for pagination based on the given page number and items per page.\n\n    The offset represents the starting point in a dataset for the items on a given page.\n    For example, if each page displays 10 items and you want to display page 3, the offset will be 20,\n    meaning the display should start with the 21st item.\n\n    Args:\n        page: The current page number. Page numbers should start from 1.\n        items_per_page: The number of items to be displayed on each page.\n\n    Returns:\n        The calculated offset.\n\n    Examples:\n        &gt;&gt;&gt; offset(1, 10)\n        0\n        &gt;&gt;&gt; offset(3, 10)\n        20\n    \"\"\"\n    return (page - 1) * items_per_page\n</code></pre>"},{"location":"api/paginated/#fastcrud.paginated.paginated_response","title":"<code>paginated_response(crud_data, page, items_per_page)</code>","text":"<p>Create a paginated response based on the provided data and pagination parameters.</p> <p>Parameters:</p> Name Type Description Default <code>crud_data</code> <code>dict</code> <p>Data to be paginated, including the list of items and total count.</p> required <code>page</code> <code>int</code> <p>Current page number.</p> required <code>items_per_page</code> <code>int</code> <p>Number of items per page.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.</p> Note <p>The function does not actually paginate the data but formats the response to indicate pagination metadata.</p> Source code in <code>fastcrud/paginated/response.py</code> <pre><code>def paginated_response(\n    crud_data: dict, page: int, items_per_page: int\n) -&gt; dict[str, Any]:\n    \"\"\"Create a paginated response based on the provided data and pagination parameters.\n\n    Args:\n        crud_data: Data to be paginated, including the list of items and total count.\n        page: Current page number.\n        items_per_page: Number of items per page.\n\n    Returns:\n        A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.\n\n    Note:\n        The function does not actually paginate the data but formats the response to indicate pagination metadata.\n    \"\"\"\n    return {\n        \"data\": crud_data[\"data\"],\n        \"total_count\": crud_data[\"total_count\"],\n        \"has_more\": (page * items_per_page) &lt; crud_data[\"total_count\"],\n        \"page\": page,\n        \"items_per_page\": items_per_page,\n    }\n</code></pre>"},{"location":"community/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at igor.magalhaes.r@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/CONTRIBUTING/","title":"Contributing to FastCRUD","text":"<p>Thank you for your interest in contributing to FastCRUD! This guide is meant to make it easy for you to get started.</p>"},{"location":"community/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":""},{"location":"community/CONTRIBUTING/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Start by forking and cloning the FastCRUD repository:</p> <pre><code>git clone https://github.com/YOUR-GITHUB-USERNAME/fastcrud.git\n</code></pre>"},{"location":"community/CONTRIBUTING/#using-poetry-for-dependency-management","title":"Using Poetry for Dependency Management","text":"<p>FastCRUD uses Poetry for managing dependencies. If you don't have Poetry installed, follow the instructions on the official Poetry website.</p> <p>Once Poetry is installed, navigate to the cloned repository and install the dependencies: <pre><code>cd fastcrud\npoetry install\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#activating-the-virtual-environment","title":"Activating the Virtual Environment","text":"<p>Poetry creates a virtual environment for your project. Activate it using:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"community/CONTRIBUTING/#making-contributions","title":"Making Contributions","text":""},{"location":"community/CONTRIBUTING/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 guidelines.</li> <li>Write meaningful tests for new features or bug fixes.</li> </ul>"},{"location":"community/CONTRIBUTING/#testing-with-pytest","title":"Testing with Pytest","text":"<p>FastCRUD uses pytest for testing. Run tests using: <pre><code>poetry run pytest\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#linting","title":"Linting","text":"<p>Use mypy for type checking: <pre><code>mypy fastcrud\n</code></pre></p> <p>Use ruff for style: <pre><code>ruff check --fix\nruff format\n</code></pre></p> <p>Ensure your code passes linting before submitting.</p>"},{"location":"community/CONTRIBUTING/#submitting-your-contributions","title":"Submitting Your Contributions","text":""},{"location":"community/CONTRIBUTING/#creating-a-pull-request","title":"Creating a Pull Request","text":"<p>After making your changes:</p> <ul> <li>Push your changes to your fork.</li> <li>Open a pull request with a clear description of your changes.</li> <li>Update the README.md if necessary.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-reviews","title":"Code Reviews","text":"<ul> <li>Address any feedback from code reviews.</li> <li>Once approved, your contributions will be merged into the main branch.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to our Code of Conduct to maintain a welcoming and inclusive environment.</p> <p>Thank you for contributing to FastCRUD\ud83d\ude80</p>"},{"location":"community/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Igor Magalh\u00e3es</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"community/overview/","title":"Community Overview","text":"<p>Welcome to the project's community hub. Here, you'll find essential resources and guidelines that are crucial for contributing to and participating in the project. Please take the time to familiarize yourself with the following documents:</p>"},{"location":"community/overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"community/overview/#contributing","title":"Contributing","text":"<p>View the Contributing Guidelines</p> <p>Interested in contributing to the project? Great! The contributing guidelines will provide you with all the information you need to get started. This includes how to submit issues, propose changes, and the process for submitting pull requests.</p>"},{"location":"community/overview/#code-of-conduct","title":"Code of Conduct","text":"<p>View the Code of Conduct</p> <p>The Code of Conduct outlines the standards and behaviors expected of our community members. It's crucial to ensure a welcoming and inclusive environment for everyone. Please take the time to read and adhere to these guidelines.</p>"},{"location":"community/overview/#license","title":"License","text":"<p>View the License</p> <p>The license document outlines the terms under which our project can be used, modified, and distributed. Understanding the licensing is important for both users and contributors of the project.</p> <p>Thank you for being a part of our community and for contributing to our project's success!</p>"},{"location":"community/showcase_submission/","title":"Submit Your Project","text":"<p>Share Your Work</p> <p>Have you built something with FastCRUD? We'd love to feature it in our showcase!</p>"},{"location":"community/showcase_submission/#project-categories","title":"Project Categories","text":"<p>What You Can Submit</p> <ul> <li>Tutorials: Step-by-step guides teaching others how to build with FastCRUD</li> <li>Open Source Projects: Libraries, tools, or applications others can use and learn from</li> <li>Applications: Web apps, desktop tools, or services built with FastCRUD</li> <li>Commercial Services: Products or services powered by FastCRUD</li> </ul>"},{"location":"community/showcase_submission/#how-to-submit","title":"How to Submit","text":"<p>Submission Steps</p> <ol> <li>Create a new issue using our Showcase Submission Template</li> <li>Fill in the relevant information for your project type</li> <li>We'll review your submission and add it to the showcase!</li> </ol>"},{"location":"community/showcase_submission/#requirements-by-category","title":"Requirements by Category","text":"<p>What We Look For</p> <p>For Tutorials:</p> <ul> <li>Clear step-by-step instructions</li> <li>Working code examples</li> <li>Explanation of concepts used</li> </ul> <p>For Open Source Projects:</p> <ul> <li>Public repository</li> <li>Basic documentation</li> <li>Installation/usage instructions</li> </ul> <p>For Applications/Services:</p> <ul> <li>Public demo or screenshots</li> <li>Description of FastCRUD features used</li> <li>Link to live service (if applicable)</li> </ul>"},{"location":"community/showcase_submission/#need-help","title":"Need Help?","text":"<p>Questions?</p> <p>Need help with your submission? We're here to help!</p> <ul> <li>Open a discussion on GitHub</li> </ul>"},{"location":"usage/crud/","title":"Using FastCRUD for Enhanced CRUD Operations","text":"<p>FastCRUD is a versatile tool for handling CRUD (Create, Read, Update, Delete) operations in FastAPI applications with SQLAlchemy models. It leverages Pydantic schemas for data validation and serialization, offering a streamlined approach to database interactions.</p>"},{"location":"usage/crud/#key-features","title":"Key Features","text":"<ul> <li>Simplified CRUD operations with SQLAlchemy models.</li> <li>Data validation and serialization using Pydantic.</li> <li>Support for complex queries including joins and pagination.</li> </ul>"},{"location":"usage/crud/#getting-started","title":"Getting Started","text":""},{"location":"usage/crud/#step-1-define-models-and-schemas","title":"Step 1: Define Models and Schemas","text":"<p>Define your SQLAlchemy models and Pydantic schemas for data representation.</p> Models and Schemas Used Below <code>item/model.py</code> <pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> <code>item/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n</code></pre> <code>customer/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>customer/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadCustomerSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>product/model.py</code> <pre><code>from sqlalchemy import Column, Integer, Numeric, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Product(Base):\n    __tablename__ = \"product\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Numeric)\n</code></pre> <code>order/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n    id = Column(Integer, primary_key=True)\n    customer_id = Column(Integer, ForeignKey(\"customer.id\"))\n    product_id = Column(Integer, ForeignKey(\"product.id\"))\n    quantity = Column(Integer)\n</code></pre> <code>order/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadOrderSchema(BaseModel):\n    id: int\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n</code></pre>"},{"location":"usage/crud/#step-2-initialize-fastcrud","title":"Step 2: Initialize FastCRUD","text":"<p>Create a <code>FastCRUD</code> instance for your model to handle CRUD operations.</p> <pre><code>from fastcrud import FastCRUD\n\n# Creating a FastCRUD instance\nitem_crud = FastCRUD(Item)\norder_crud = FastCRUD(Order)\n</code></pre>"},{"location":"usage/crud/#step-3-pick-your-method","title":"Step 3: Pick your Method","text":"<p>Then you just pick the method you need and use it like this:</p> <pre><code># Creating a new record\nnew_record = await item_crud.create(db_session, create_schema_instance)\n</code></pre> <p>More on available methods below.</p>"},{"location":"usage/crud/#understanding-fastcrud-methods","title":"Understanding FastCRUD Methods","text":"<p>FastCRUD offers a comprehensive suite of methods for CRUD operations, each designed to handle different aspects of database interactions efficiently.</p>"},{"location":"usage/crud/#1-create","title":"1. Create","text":"<pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType,\n    commit: bool = True,\n) -&gt; ModelType\n</code></pre> <p>Purpose: To create a new record in the database. Usage Example: Creates an item with name <code>\"New Item\"</code>.</p> <pre><code>new_item = await item_crud.create(db, CreateItemSchema(name=\"New Item\"))\n</code></pre> <p>Warning</p> <p>Note that naive <code>datetime</code> such as <code>datetime.utcnow</code> is not supported by <code>FastCRUD</code> as it was deprecated.</p> <p>Use timezone aware <code>datetime</code>, such as <code>datetime.now(UTC)</code> instead.</p>"},{"location":"usage/crud/#2-get","title":"2. Get","text":"<pre><code>get(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, BaseModel]]\n</code></pre> <p>Purpose: To fetch a single record based on filters, with an option to select specific columns using a Pydantic schema. Usage Example: Fetches the item with <code>item_id</code> as its <code>id</code>.</p> <pre><code>item = await item_crud.get(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#3-exists","title":"3. Exists","text":"<pre><code>exists(\n    db: AsyncSession,\n    **kwargs: Any,\n) -&gt; bool\n</code></pre> <p>Purpose: To check if a record exists based on provided filters. Usage Example: Checks whether an item with name <code>\"Existing Item\"</code> exists.</p> <pre><code>exists = await item_crud.exists(db, name=\"Existing Item\")\n</code></pre>"},{"location":"usage/crud/#4-count","title":"4. Count","text":"<pre><code>count(\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Purpose: To count the number of records matching provided filters. Usage Example: Counts the number of items with the <code>\"Books\"</code> category.</p> <pre><code>count = await item_crud.count(db, category=\"Books\")\n</code></pre>"},{"location":"usage/crud/#5-get-multi","title":"5. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records with optional sorting, pagination, and model conversion. Usage Example: Fetches a subset of 5 items, starting from the 11th item in the database.</p> <pre><code>items = await item_crud.get_multi(db, offset=10, limit=5)\n</code></pre>"},{"location":"usage/crud/#6-update","title":"6. Update","text":"<pre><code>update(\n    db: AsyncSession, \n    object: Union[UpdateSchemaType, dict[str, Any]], \n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, BaseModel]]\n</code></pre> <p>Purpose: To update an existing record in the database. Usage Example: Updates the description of the item with <code>item_id</code> as its <code>id</code>.</p> <pre><code>await item_crud.update(\n    db,\n    UpdateItemSchema(description=\"Updated\"),\n    id=item_id,\n)\n</code></pre>"},{"location":"usage/crud/#7-delete","title":"7. Delete","text":"<pre><code>delete(\n    db: AsyncSession, \n    db_row: Optional[Row] = None, \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Purpose: To delete a record from the database, with support for soft delete. Usage Example: Deletes the item with <code>item_id</code> as its <code>id</code>, performs a soft delete if the model has the <code>is_deleted</code> column.</p> <pre><code>await item_crud.delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#8-hard-delete","title":"8. Hard Delete","text":"<pre><code>db_delete(\n    db: AsyncSession, \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Purpose: To hard delete a record from the database. Usage Example: Hard deletes the item with <code>item_id</code> as its <code>id</code>.</p> <pre><code>await item_crud.db_delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#advanced-methods-for-complex-queries-and-joins","title":"Advanced Methods for Complex Queries and Joins","text":"<p>FastCRUD extends its functionality with advanced methods tailored for complex query operations and handling joins. These methods cater to specific use cases where more sophisticated data retrieval and manipulation are required.</p>"},{"location":"usage/crud/#1-get-multi","title":"1. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records based on specified filters, with options for sorting and pagination. Usage Example: Gets the first 10 items sorted by <code>name</code> in ascending order.</p> <pre><code>items = await item_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns=['name'],\n    sort_orders=['asc'],\n)\n</code></pre>"},{"location":"usage/crud/#2-get-joined","title":"2. Get Joined","text":"<pre><code>get_joined(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_model: Optional[ModelType] = None,\n    join_on: Optional[Union[Join, BinaryExpression]] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass] = None,\n    join_filters: Optional[dict] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    nest_joins: bool = False,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Purpose: To fetch a single record with one or multiple joins on other models. Usage Example: Fetches order details for a specific order by joining with the <code>Customer</code> table, selecting specific columns as defined in <code>ReadOrderSchema</code> and <code>ReadCustomerSchema</code>.</p> <pre><code>order_details = await order_crud.get_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Customer,\n    join_schema_to_select=ReadCustomerSchema,\n    id=order_id,\n)\n</code></pre>"},{"location":"usage/crud/#3-get-multi-joined","title":"3. Get Multi Joined","text":"<pre><code>get_multi_joined(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    joins_config: Optional[list[JoinConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Similar to <code>get_joined</code>, but for fetching multiple records. Usage Example: Retrieves a paginated list of orders (up to 5), joined with the <code>Customer</code> table, using specified schemas for selective column retrieval from both tables.</p> <pre><code>orders = await order_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Customer,\n    join_schema_to_select=ReadCustomerSchema,\n    offset=0,\n    limit=5,\n)\n</code></pre>"},{"location":"usage/crud/#4-get-multi-by-cursor","title":"4. Get Multi By Cursor","text":"<pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Implements cursor-based pagination for efficient data retrieval in large datasets. Usage Example: Fetches the next 10 items after the last cursor for efficient pagination, sorted by creation date in descending order.</p> <pre><code>paginated_items = await item_crud.get_multi_by_cursor(\n    db,\n    cursor=last_cursor,\n    limit=10,\n    sort_column='created_at',\n    sort_order='desc',\n)\n</code></pre>"},{"location":"usage/crud/#5-select","title":"5. Select","text":"<pre><code>async def select(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any,\n) -&gt; Select\n</code></pre> <p>Purpose: Constructs a SQL Alchemy <code>Select</code> statement with optional column selection, filtering, and sorting. Usage Example: Selects all items, filtering by <code>name</code> and sorting by <code>id</code>. Returns the <code>Select</code> statement.</p> <pre><code>stmt = await item_crud.select(\n    schema_to_select=ItemSchema,\n    sort_columns='id',\n    name='John',\n)\n# Note: This method returns a SQL Alchemy Select object, not the actual query result.\n</code></pre>"},{"location":"usage/crud/#6-count-for-joined-models","title":"6. Count for Joined Models","text":"<pre><code>count(\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Purpose: To count records that match specified filters, especially useful in scenarios involving joins between models. This method supports counting unique entities across relationships, a common requirement in many-to-many or complex relationships. Usage Example: Count the number of unique projects a participant is involved in, considering a many-to-many relationship between <code>Project</code> and <code>Participant</code> models.</p> Models <pre><code>class Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre> <pre><code>project_crud = FastCRUD(Project)\nprojects_count = await project_crud.count(\n    db=session,\n    joins_config=[\n        JoinConfig(\n            model=Participant,\n            join_on=ProjectsParticipantsAssociation.project_id == Project.id,\n            join_type=\"inner\",\n        ),\n    ],\n    participant_id=specific_participant_id,\n)\n</code></pre>"},{"location":"usage/crud/#error-handling","title":"Error Handling","text":"<p>FastCRUD provides mechanisms to handle common database errors, ensuring robust API behavior.</p>"},{"location":"usage/endpoint/","title":"Automatic Endpoint Creation with <code>crud_router</code>","text":"<p>This section of the documentation explains how to use the <code>crud_router</code> utility function from the FastCRUD package for automatic endpoint creation in a FastAPI application. The <code>crud_router</code> simplifies the process of creating standard CRUD (Create, Read, Update, Delete) endpoints for your models.</p>"},{"location":"usage/endpoint/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have FastAPI and FastCRUD installed in your environment. FastCRUD streamlines interactions with the database using SQLAlchemy models and Pydantic schemas.</p>"},{"location":"usage/endpoint/#using-crud_router","title":"Using <code>crud_router</code>","text":""},{"location":"usage/endpoint/#step-1-define-your-model-and-schema","title":"Step 1: Define Your Model and Schema","text":"<p>First, define your SQLAlchemy model and corresponding Pydantic schemas for creating and updating data.</p> <code>item/model.py</code> <pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> <code>item/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application, you can optionally set up a custom FastCRUD instance as well. This involves configuring the database connection.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n</code></pre>"},{"location":"usage/endpoint/#step-3-use-crud_router-to-create-endpoints","title":"Step 3: Use <code>crud_router</code> to Create Endpoints","text":"<pre><code># CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"],\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"usage/endpoint/#available-endpoints","title":"Available Endpoints","text":"<p>For a comprehensive list of all available endpoints, read the advanced section.</p>"},{"location":"usage/endpoint/#usage-and-testing","title":"Usage and Testing","text":"<p>Once the application is running, you can test the automatically created endpoints using tools like Swagger UI, which FastAPI provides by default. The endpoints for creating, reading, updating, and deleting Item instances are now accessible at <code>/items</code>.</p>"},{"location":"usage/endpoint/#using-endpointcreator-directly","title":"Using <code>EndpointCreator</code> Directly","text":"<p>Using the <code>EndpointCreator</code> class in FastCRUD is a more flexible way to add CRUD endpoints to a FastAPI application.</p>"},{"location":"usage/endpoint/#step-1-define-your-model-and-schema_1","title":"Step 1: Define Your Model and Schema","text":"<p>Define your SQLAlchemy models and corresponding Pydantic schemas for data validation.</p> <code>item/model.py</code> <pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> <code>item/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass DeleteItemSchema(BaseModel):\n    pass\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud_1","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application and FastCRUD instances. This involves configuring the database connection and creating a CRUD instance for your model.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\nitem_crud = FastCRUD(Item)\n</code></pre>"},{"location":"usage/endpoint/#step-3-initialize-endpointcreator","title":"Step 3: Initialize <code>EndpointCreator</code>","text":"<p>Create an instance of <code>EndpointCreator</code> by passing the necessary parameters, including your model, session, CRUD instance, and schemas.</p> <pre><code>from fastcrud import EndpointCreator\n\n# Initialize EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=get_session,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    crud=item_crud,\n    delete_schema=DeleteItemSchema,\n    path=\"/itempath\",\n    tags=[\"ItemTag\"]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-4-add-custom-endpoints","title":"Step 4: Add Custom Endpoints","text":"<p>Add custom endpoints using <code>EndpointCreator</code>. You can inject dependencies as needed.</p> <pre><code># Example of adding custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[custom_dependency],\n    update_deps=[another_custom_dependency],\n)\n</code></pre>"},{"location":"usage/endpoint/#step-5-include-the-router-in-your-application","title":"Step 5: Include the Router in Your Application","text":"<p>Finally, include the router from the <code>EndpointCreator</code> in your FastAPI application.</p> <pre><code>app.include_router(endpoint_creator.router)\n</code></pre>"},{"location":"usage/endpoint/#advanced-customization","title":"Advanced Customization","text":"<p>You can override the default methods in <code>EndpointCreator</code> for more control over the CRUD operations. You can also specify the operations you want to include. Read more in the advanced section.</p>"},{"location":"usage/endpoint/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can quickly set up CRUD endpoints for your models in a FastAPI application using <code>crud_router</code> or <code>EndpointCreator</code>. This utility function reduces boilerplate code and increases development efficiency by automating the creation of standard API endpoints.</p>"},{"location":"usage/overview/","title":"Usage Overview","text":"<p>The Usage section of our documentation provides comprehensive guides on how to effectively use key features of our application. This section is divided into various topics, each focusing on a specific aspect of usage, ensuring that you have all the information you need to leverage the full potential of our tools and functionalities.</p>"},{"location":"usage/overview/#key-topics","title":"Key Topics","text":""},{"location":"usage/overview/#1-automatic-endpoint-creation-with-crud_router","title":"1. Automatic Endpoint Creation with <code>crud_router</code>","text":"<p>This guide covers the use of <code>crud_router</code> for automatic endpoint creation in FastAPI applications. It provides a step-by-step approach to streamline the creation of standard CRUD endpoints.</p> <ul> <li>Automatic Endpoint Creation Guide</li> </ul>"},{"location":"usage/overview/#2-enhanced-crud-operations-with-fastcrud","title":"2. Enhanced CRUD Operations with FastCRUD","text":"<p>Learn how to use the <code>FastCRUD</code> class for enhanced CRUD operations. This guide delves into the functionalities offered by <code>FastCRUD</code>, including advanced query capabilities, pagination, and error handling.</p> <ul> <li>FastCRUD Usage Guide</li> </ul>"},{"location":"usage/overview/#getting-started","title":"Getting Started","text":"<p>To make the most out of these guides, we recommend familiarizing yourself with FastAPI and SQLAlchemy basics, as our application leverages these frameworks extensively.</p>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>If you have suggestions or contributions to these guides, please refer to our Contributing Guidelines. We appreciate your input in improving our documentation.</p>"}]}